print("\n>>MoveTable");
// 行動リストテーブル

local t = {};

//-----------------------------------------------------------------------------
// 固有関数
//-----------------------------------------------------------------------------

// Mv_Null_FFCancelChecker オブジェクトがある間は1になってると同じ
// btl_Define_Chara.txtで定義
// const CDef_Tsu_PP_FFKeep = 0; // 構え中1になっていて、Dを押すと0になる

local sousai = {};

sousai.HitInterrupt <- function(_num=0, _effy=-200) // _num:相殺回数, _effy:表示座標
{
	// 相殺後に派生を出しやすくする
	BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
	
	// 連続して大きなガードポイントエフェクトが出ないようにする
	local eff_pat = ( _num==0 )? "eff_TsuSousai" : "eff_TsuSousai_Limit"

	// ガードポイント成立時のエフェクトを呼ぶ
	local eff = BMvEff.CreateObject( { start_pat=eff_pat , y=_effy<<7 } );
}

//-----------------------------------------------------------------------------
// スマートステア
//-----------------------------------------------------------------------------

t.Mv_Skill_SSRelayAtk <-
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			// スマートステア以外から出したら相手との距離を見て減速処理をする
			local isDirectSS = BMvTbl.GetLPEx(1,1); // A+Bで直接出したか
			if( isDirectSS )
			{
				local now_vec = BMvTbl.GetVector();
				local vec_x = Battle_Std.GetEnemyDistance()/5 - now_vec.x; //5F後に到達
				// _dpn("vec_x:"+vec_x);

				// 近すぎたら減速、遠かったら加速
				if( vec_x < -6000 ) vec_x = -6000;
				if( vec_x > 3000 ) vec_x = 3000;
				BMvTbl.SetVector({ x=vec_x, flags=_VecFlag_Add });
			}
			break;
		}
	}
}
//-----------------------------------------------------------------------------
// フォースファンクション
//-----------------------------------------------------------------------------

//B+Cで構える

//必殺技からキャンセルするときに経由するMv
//専用エフェクトを出しつつVPかどうかで構えまでのフレームが変わるようにする
t.Mv_Atk_RelayBandC <-
{
	function Init()
	{
		// 通過のみでエフェクトを出して強引なキャンセルだと分かるようにしているだけ
		BMvTbl.SetFinalize(0);

		// 非VP時は構えはじめが4F遅くなる
		BMvTbl.SetLP(0,0);// 非VPからキャンセルで出したら1
		if( BMvEff.GRD_GetJudgeResult() <= 0 )
		{
			BMvTbl.SetLP(0,1);// 非VPからキャンセルで出した
		}
		BMvEff.CreateObject( { datatype=1, start_pat=509, x=0, y=-250*128 } );
		BSound.SE_Play( { type=_SeType_Player, num=10 } );
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable("Mv_Atk_StdBandC");
	}
}

// FF状態中は持続するオブジェクト
// 無関係なMvになったりDを押すとPPを初期化しつつ消滅する
t.Mv_Null_FFCancelChecker <-
{
	function Init_After()
	{
		BMvTbl.SetPP(CDef_Tsu_PP_FFKeep,1); // 構え中か 0:構え解除 1:構え中
		BMvTbl.SetLP(0,45); // GRD減少開始までの時間
	}
	function Update_After()
	{
		if( BMvTbl.AddLP(0,-1) < 0 )
		{
			BMvTbl.SetLP(0,0); // 減りすぎないように
		}
	}
	function FrameUpdate_After()
	{
		local left_time = BMvTbl.GetLP(0); // GRD減少開始までの時間
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local isPushD = BMvTbl.CheckButtonHold( (1<<3) ); // Dを押しているか
			local isFFMv = Battle_Std.MoveCode.CheckFlag( def_MC_CharaFlag1 );
			if( left_time <= 0 )
			{
				// 十分時間が経過したらGRDを減らす
				Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(-80), pressure=0, });//FF発動でも減るので抑えめ
			}
			
			player.pop();
			if( isPushD || !isFFMv || Battle_Std.RoundisEnd() )
			{
				BMvTbl.SetPP(CDef_Tsu_PP_FFKeep,0); // 構え中か 0:構え解除 1:構え中
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function LastUpdate_After()
	{
		BMvTbl.SetPP(CDef_Tsu_PP_FFKeep,0); // 構え中か 0:構え解除 1:構え中
	}
}

t.Mv_Atk_StdBandC <-
{
	function Init_After()
	{
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag1 ); // FF状態

		//Dでの解除を受け付ける監視オブジェクト生成
		BMvEff.CreateObject( { mvname="Mv_Null_FFCancelChecker" } );
		
		// 非VPからキャンセルで出したら4F長いPATに飛ぶ（※LP0は中継のMvで更新している）
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_Atk_RelayBandC" && BMvTbl.GetLP(0)==1 )
		{
			BMvTbl.SetPattern("B+C_wait");
		}
		BMvTbl.SetLP(0,0);// 非VPからキャンセルで出したら1　使い終わったので初期化
	}
	function FrameUpdate_After()
	{
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_FFBase" );
	}
}

//構え状態
t.Mv_Skill_FFBase <-
{
	flags = def_TmplFlags_NoFurimuki|def_TmplFlags_NoAddComboRate //振り向きを行わない,コンボレートを加算しない
	function Init_After()
	{
		BMvTbl.SetLP(0,0);//何回相殺したか
		
		Battle_Std.MoveCode.AddFlag( def_MC_EnableCansel_SkilltoSkill ); // 必殺Ｃで必殺技へのキャンセル可
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag1 ); // FF状態
		Battle_Std.MoveCode.AddFlag( def_MC_BCAction );//FF扱い
		
		//前のMvがB+CならIDジャンプする
		local lastMv = BMvTbl.ChangeMv_GetMvName();
		if( lastMv == "Mv_Atk_StdBandC" )
		{
			BMvTbl.JumpFrameID(100);
			
			local eff = BMvEff.CreateObject( { mvname="Mv_Obj_eff_Tsugp", x=0*128, y=0 } );
			
			BSound.SE_Play( { type=_SeType_Normal, num=60 } ); // 盾のゴイーン
		}
		// FF派生のダッシュかプッシュから来たらスクリプトでガードポイント受付中のエフェクト出す
		else if( lastMv == "Mv_Skill_FF_Dash" || lastMv == "Mv_Atk_FF_AtkPush" )
		{
			// _dpn("ダッシュorプッシュから来た")
			local eff = BMvEff.CreateObject( { mvname="Mv_Obj_eff_Tsugp", x=0*128, y=0 } );
		}
		Battle_Std.Atemi.Init( { hantei=5, flags=def_PP_SFS_NoGedan } );
	}
	function FrameUpdate_After()
	{
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.JumpFrameID(480);
		}
		if( BMvTbl.GetPP(CDef_Tsu_PP_FFKeep)==0 ) // 構え中か 0:構え解除 1:構え中
		{
			BMvTbl.SetFinalize(0);
		}
		Battle_Std.Atemi.FrameUpdate();
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10:// 行動可能になるとこ
			BMvTbl.SetCommandLongDelay(2); //受付時間増加
			break;
		}
	}
	function HitInterrupt_After() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, e_hitstopAdd = 7, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);//何回相殺したか
			
			//振り向きの絵で相殺するとダサいので立ちに戻す
			local mvs = BMvTbl.GetMvStatus();
			if( mvs.Param2&8 )
			{
				BMvTbl.JumpFrameID(10);
			}
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_FF_ToStand" );
	}
}

t.Mv_Obj_eff_Tsugp <- {
	
	function Init_After()
	{
		// _ObjFlags_ParentMuki _ObjFlags_MukiXPosMove は行動可能にならないと反映されないので使えない
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_EraseParentPatChange|_ObjFlags_ParentMove } );
	}
	function FrameUpdate_After()
	{
		// 常に親の向きと同じにする
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			local muki = BMvTbl.GetMuki();
			oya.pop();
			
			local set_muki = ( muki == 1 )? _Direction_Right : _Direction_Left;
			BMvTbl.SetMuki( set_muki );
		}
	}
};

//Dの構え解除
t.Mv_Skill_FF_ToStand <-
{
	flags = def_TmplFlags_NoFurimuki|def_TmplFlags_NoAddComboRate //振り向きを行わない,コンボレートを加算しない
	function Init_After()
	{
	}
	function Finalize_After()
	{
		local ad_hold = BMvTbl.CheckCommandString( { command = ["A+D"], lastdelay=1 } );
		if( ad_hold ) // A+Dを押している（投げに行きたい）
		{
			// 解除して投げに行こうとして、D>A+Dでチェインシフトが漏れやすいので対策
			BMvTbl.SetCommandFailTime( { command=def_CN_Convert, time=1 } );
		}
	}
}

//ダッシュからの解除のほうが全体F短くしている（ダッシュ投げしやすくしたかった）
t.Mv_Skill_FF_DashToStand <-
{
	flags = def_TmplFlags_NoFurimuki|def_TmplFlags_NoAddComboRate //振り向きを行わない,コンボレートを加算しない
	function Init_After()
	{
	}
	function Finalize_After()
	{
		local ad_hold = BMvTbl.CheckCommandString( { command = ["A+D"], lastdelay=1 } );
		if( ad_hold ) // A+Dを押している（投げに行きたい）
		{
			// 解除して投げに行こうとして、D>A+Dでチェインシフトが漏れやすいので対策
			BMvTbl.SetCommandFailTime( { command=def_CN_Convert, time=1 } );
		}
	}
}



t.Mv_Skill_FF_Dash <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);//何回相殺したか
		Battle_Std.MoveCode.AddFlag( def_MC_BCAction );//FF扱い
		
		Battle_Std.Atemi.Init( { hantei=5, flags=def_PP_SFS_NoGedan } );
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag1 ); // FF状態
	}
	function FrameUpdate_After()
	{
		Battle_Std.Atemi.FrameUpdate();
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.Param2&4 )
		{
			//後半は構え解除して立ちに戻れる
			//後半にParam2がある
			if( BMvTbl.GetPP(CDef_Tsu_PP_FFKeep)==0 ) // 構え中か 0:構え解除 1:構え中
			{
				BMvTbl.SetFinalize(100);
			}
		}
	}
	function HitInterrupt_After() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, e_hitstopAdd = 7, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);//何回相殺したか
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Skill_FFBase", [100,"Mv_Skill_FF_DashToStand"] ); //デフォ,[code,mv]...	
	}
	function LastUpdate_After()
	{
		// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
		// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		local vec = BMvTbl.GetVector(0); //vec に現在のベクトルを格納
		BMvTbl.SetVector( { x=vec.x, addx=-(vec.x/10),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
	}
}

//攻撃
t.Mv_Atk_FF_AtkPush <-
{
	atkflags = def_AtkTmplFlags_Enable,
	function Init_After()
	{
		BMvTbl.SetLP(0,0);//何回相殺したか
		Battle_Std.MoveCode.AddFlag( def_MC_BCAction );//FF扱い
		
		Battle_Std.Atemi.Init( { hantei=5, flags=def_PP_SFS_NoGedan } );
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag1 ); // FF状態
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // ズラし押しで別の行動に移れる
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body , time=255, flag=_ClearFlag_ChangeMv  } ); // 体属性を設定
	}
	function FrameUpdate_After()
	{
		Battle_Std.Atemi.FrameUpdate();
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.Param2&4 )
		{
			//後半は構え解除して立ちに戻れる
			//後半にParam2がある
			if( BMvTbl.GetPP(CDef_Tsu_PP_FFKeep)==0 ) // 構え中か 0:構え解除 1:構え中
			{
				BMvTbl.SetFinalize(100);
			}
		}
		// しりもちやられは初回だけ
		if( mvs.FrameID == 256 )
		{
			if( BMvTbl.HitPat_Check( { num = -1 } ) )
			{
				_dp("\n 同技");
				BMvTbl.JumpFrameID( 512 );
			}
		}
	}
	function HitInterrupt_After() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, e_hitstopAdd = 7, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);//何回相殺したか
		}
	}
	function Finalize()
	{
		// BMvTbl.SetNextMoveTable( "Mv_Skill_FFBase" );
		Battle_Std.SwitchNextMoveTable("Mv_Skill_FFBase", [100,"Mv_Skill_FF_ToStand"] ); //デフォ,[code,mv]...	
	}
}

t.Mv_Atk_FF_AtkHop <-
{
	atkflags = def_AtkTmplFlags_Enable,
	function Init_After()
	{
		Battle_Std.MoveCode.AddFlag( def_MC_BCAction );//FF扱い
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Shield_CanselNG ); // シールドされるとキャンセル不能
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // ズラし押しで別の行動に移れる
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body , time=255, flag=_ClearFlag_ChangeMv  } ); // 体属性を設定
	}
	function Start_After()
	{
		// JC>チェーン>この技>JCが出せない対策
		BMvTbl.ClearComboLimit(-1); // コンボリミット初期化
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 500:
			BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
			break;
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

t.Mv_Atk_FF_AtkSlide <-
{
	atkflags = def_AtkTmplFlags_Enable,
	function Init_After()
	{
		Battle_Std.MoveCode.AddFlag( def_MC_BCAction );//FF扱い
		
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカる
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // ズラし押しで別の行動に移れる
	}
	function FrameUpdate_After()
	{
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardStand|_GuardFlag_GuardAir, time=255, flag=_ClearFlag_ChangeMv } );
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}


//-----------------------------------------------------------------------------
// イベント
//-----------------------------------------------------------------------------

t.Mv_Startup <-
{
	function Init_After()
	{
	}
}

t.Mv_Standby <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10:
			local eff = BMvEff.CreateObject( { x=100, mvname="Mv_Obj_InSh_Standby_eff" } );
			break;
		case 100:
			local eff = BMvEff.CreateObject( { mvname="Mv_Obj_InSh_Standby" } );
			break;
		}
	}
}

t.Mv_Neutral <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_Crouch_Wait <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_WinPattern <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		switch( Battle_Std.GetUpdateFrameID( mvs ) )
		{
		case 100:
			local eff = BMvEff.CreateObject( { mvname="Mv_Obj_OutSh_WinSerious" } );
			break;
		}
	}
}

t.Mv_Obj_InSh_Standby_eff <-
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10:
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvTbl.JumpFrameID( 100 );
				player.pop();
			}
			break;
		}
	}
}

t.Mv_Obj_InSh_Standby <-
{
	function Init_After()
	{
		//光って入る
		BMvEff.SetCharaFlash( { color = 0xFFDD66, type = 0, time = 60 } );
	}
}

t.Mv_Obj_OutSh_WinSerious <-
{
	function Init_After()
	{
		//光って入る
		BMvEff.SetCharaFlash( { color = 0xFFDD66, type = 0, time = 60 } );
	}
};

t.CheckAttackCatch <- function()
{
	local p_FF = Battle_Std.MoveCode.CheckFlag( def_MC_BCAction );//FF
	local mv_name = BMvTbl.GetMvName(); //クリーピングエッジの相殺でも入ってくるので除外する
	
	if( mv_name != "Mv_ForwardShift" )
	{
		// ここにくるのは「2[C] / 6[C] / J[C] / J2[C] / J236[B] / J236EX / B+C（派生含む） / 214EX」
		// ツルギの相殺技に対する共通対策としてVOやガースラのシステム技は相殺しないようにする（システム技には空中投げも含まれるが相殺しないのでOK）
		// FF以外の技はCSで確認した時などに無敵技で返せるようにしたいので無敵技には相殺しないようにする
		
		local enemy = BMvCore.GetParamCharaData(0);//当身で取ったオブジェクト
		if( enemy.push() )
		{
			local sysatk_move = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_SysAtk );
			local muteki_move = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki );
			enemy.pop();
			
			if( sysatk_move )
			{
				_dpn("システム技なので相殺しない"); //VOやガースラのシステム技は一律で相殺不可
				return 0;
			}
			if( !p_FF ) // 受け止める側がFF以外
			{
				if( muteki_move )
				{
					_dpn("無敵技なので相殺しない");//切り返したいので反応しない
					return 0;
				}
			}
		}
	}
	return 1; // 当身成功
}
//-----------------------------------------------------------------------------
// 通常投げ
//-----------------------------------------------------------------------------

t.Mv_Throw_F_Hit <- 
{
	function Init_After()
	{
		BMvEff.ThrowChara_SetJoint( 0 ); //掴みをくっつけない
		
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=331, frame=1, rest=2 } ); // やられ予約
			BMvCore.CallEntryBCCachePreTransfer( { pat=331, frame=2, rest=8 } ); // やられ予約
			
			enemy.pop();
		}
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			BMvEff.ThrowParam( { pattern=320, x=250, y=-150, } );
			BMvEff.ThrowRelease( { type="無声ダウン", airrecover=0, flags=0 } ); //開放のみ
			break;
		}
	}
	function LastUpdate_After()
	{
		BMvEff.ThrowChara_SetJoint( 1 ); //掴みをくっつける
	}
}

//-----------------------------------------------------------------------------
// 通常技
//-----------------------------------------------------------------------------

t.Mv_Atk_StdA <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		
	}
}

t.Mv_Atk_StdB <-
{
}

t.Mv_Atk_StdC <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_Atk_CroA <-
{
	function Init_After()
	{
	}
}

t.Mv_Atk_CroB <-
{
	function Init_After()
	{
	}
}

t.Mv_Atk_CroC <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカる
		
		Battle_Std.Atemi.Init( { hantei=5, flags=0 } );
		BMvTbl.SetLP(0,0); //何回相殺したか
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, EndFrameID=60, SetPattern="CroC_End" } ); // ButtonMask, CheckFrameID, SetPattern
		
		Battle_Std.Atemi.FrameUpdate();
	}
	function HitInterrupt_After() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num, -100); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);
		}
	}
}

t.Mv_Atk_AirA <- {};

t.Mv_Atk_AirB <- 
{
	function FrameUpdate_After()
	{
		//地上アサルトJBは、でかかり屈に空振りするように
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.Param2&4 )
		{
			if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 7, def_MC7_StdAssult ) )
			{
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_ThroughCrouch, time=4, flag=_ClearFlag_ChangeFrame } );
			}
		}
	}
}

t.Mv_Atk_AirC <-
{
	function Init_After()
	{
		Battle_Std.Atemi.Init( { hantei=5, flags=0 } );
		BMvTbl.SetLP(0,0); //何回相殺したか
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, EndFrameID=60, SetPattern="AirC_End" } ); // ButtonMask, CheckFrameID, SetPattern
		
		Battle_Std.Atemi.FrameUpdate();
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 200: // ためＪＣ
			break;
		}
	}
	function HitInterrupt_After() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);
		}
	}
}

//-----------------------------------------------------------------------------
// 特殊技
//-----------------------------------------------------------------------------


t.Mv_Atk_Std3C <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 8, _HitCheckFlag_Head ); // Param1 & 8 の時、頭無敵
	}
}

t.Mv_Atk_Air2C <-
{
	function Init_Before()
	{
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_FastJumpAtkNoThroughCrouch ); // のぼりで出しても屈に空振りさせる処理をしない
	}
	function Init_After()
	{
		Battle_Std.Atemi.Init( { hantei=5, flags=0 } );
		BMvTbl.SetLP(0,0); //何回相殺したか
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, SetPattern="J2C_End" } ); // ButtonMask, CheckFrameID, SetPattern
		Battle_Std.Atemi.FrameUpdate();
	}
	function HitInterrupt_After() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);
		}
	}
}
t.Mv_Atk_Air2C_Land <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body, time=255, flag=_ClearFlag_ChangeMv } ); // 体属性を設定
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			BMvTbl.AddHitCheckFlag( 1, _HitCheckFlag_Legs ); // 足属性を追加
			BMvTbl.EraseHitCheckFlag( 1, _HitCheckFlag_Body ); // 体属性を削除
			break;
		}
	}
}

t.Mv_Atk_Air6C <-
{
}


t.Mv_Atk_Std6C <- 
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		Battle_Std.Atemi.Init( { hantei=5, flags=0 } );
		BMvTbl.SetLP(0,0); // 何回相殺したか
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, SetPattern="6C_End" } ); // ButtonMask, CheckFrameID, SetPattern
		Battle_Std.Atemi.FrameUpdate();
	}
	function HitInterrupt_After() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);
		}
	}
}


//-----------------------------------------------------------------------------
// ダッシュ攻撃
//-----------------------------------------------------------------------------


t.Mv_Atk_DashStdB <- 
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカる
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 150:
			// もちあげ開始
			BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカるを削除して体属性に戻す
			break;
		}
	}
}

t.Mv_Atk_DashStdC <- 
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_DashStdC_Hit"]); //デフォ,[code,mv]...	
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256);
	}
}

t.Mv_Atk_DashStdC_Hit <-
{
	atkflags = def_AtkTmplFlags_Enable,
	usepat = "DashC_Hit",
	function Init_After()
	{
		Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
		BMvTbl.SetLP(0,0); // 投げ開放したかどうか
		
		//ベクトル減速・着地は絶対にしない
		local pos = BMvTbl.GetPosition();
		if( pos.y >= -20*128 )
		{
			BMvTbl.SetVector( { y=0, addy=0 } );
		}
		local nowVec = BMvTbl.GetVector( { flags=_Vector_Normal } );
		local xPar = 90;
		local yPar = 40;
		local setVec = { x=0, addx=0, y=0, addy=0 };
		setVec.x = nowVec.x*xPar/100;
		setVec.y = nowVec.y*yPar/100;
		setVec.addx = -setVec.x / 10;
		setVec.addy = -setVec.y / 10;
		
		BMvTbl.SetVector( { x=0, addx=0, y=0, addy=0, flags=_Vector_Normal } );
		BMvTbl.SetVector( { x=setVec.x, addx=setVec.addx, y=setVec.y, addy=setVec.addy, flags=_Vector_Div } );
	}
	function FrameUpdate_After()
	{
		//
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			BMvTbl.SetLP(0,1); // 投げ開放したかどうか
			BMvEff.ThrowParam( { x=200, y=-75, } );
			BMvEff.ThrowRelease( { type="斜め下叩きつけ", airrecover=0 } );
			
			//同技のときは別の判定に変更
			if( BMvTbl.HitPat_Check( { num = -1 } ) )
			{
				BMvTbl.JumpFrameID(150);
			}
			break;
		}
		
	}
	function LastUpdate_After()
	{
		if( BMvTbl.GetLP(0)==0 )
		{
			//保険処理
			BMvEff.ThrowParam( { x=200, y=-75, } );
			BMvEff.ThrowRelease( { type="斜め下叩きつけ", airrecover=0 } );
		}
	}
}


//-----------------------------------------------------------------------------
// 214攻
//-----------------------------------------------------------------------------

local makeSkillTmpl_JumpCatchBomb = function( param={} ) : (sousai)
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		techMv = 0, // 生投げ（投げ抜け可）
		techMv2 = 0, // 金投げ（長めの投げ抜け可）
		comboMv = 0, // コンボ(空中部分でキャッチと地上部分のキャッチがある)
		comboMv2 = 0, // リジェクトorブレイク
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.techMv = "Mv_Skill_214A_TechWait";
		mvparam.techMv2 = "Mv_Skill_214A_TechWait2";
		mvparam.comboMv = "Mv_Skill_214A_Hit";
		mvparam.comboMv2 = "Mv_Skill_214A_Hit";
		break;
	case "B":
		mvparam.techMv = "Mv_Skill_214B_TechWait";
		mvparam.techMv2 = "Mv_Skill_214B_TechWait2";
		mvparam.comboMv = "Mv_Skill_214B_Hit";
		mvparam.comboMv2 = "Mv_Skill_214B_Hit";
		break;
	case "EX":
		mvparam.techMv = "Mv_Skill_214EX_TechWait";
		mvparam.techMv2 = "Mv_Skill_214EX_TechWait2";
		mvparam.comboMv = "Mv_Skill_214EX_Hit";
		mvparam.comboMv2 = "Mv_Skill_214EX_Hit";
		break;
	}
	
	ret_tmpl.Init_After <- function()
	{
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SkillThrow );
		
		Battle_Std.Atemi.Init( { hantei=5, flags=0 } );
		BMvTbl.SetLP(0,0); // 何回相殺したか
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100: // 攻撃判定発生
			break;
		case 512: // つかんで投げ抜け待機
			break;
		}
		Battle_Std.Atemi.FrameUpdate();
	}
	
	ret_tmpl.HitInterrupt_After <- function() : (mvparam,sousai)
	{
		Battle_Std.SetThrowHitFinalize(512,700,256,300,300); // 投げ,　強引投げ, コンボ投げ, リジェクト＆投げを投げぬけ可, 投げ抜け失敗フレーム中
		
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);
			if( sousai_num==0 )
			{
				local mvs = BMvTbl.GetMvStatus();
				if( mvs.Param1&1 )
				{
					BMvTbl.JumpFrameID(100);// 初回のみ相殺したらすぐ掴む
				}
			}
		}
	}
	
	ret_tmpl.Finalize <- function() : (mvparam)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,mvparam.comboMv],[300,mvparam.comboMv2],[512,mvparam.techMv],[700,mvparam.techMv2]); //デフォ,[code,mv]...
	}
	
	return ret_tmpl;
}

t.Mv_Skill_214A <- makeSkillTmpl_JumpCatchBomb( { type="A" } );
t.Mv_Skill_214B <- makeSkillTmpl_JumpCatchBomb( { type="B" } );
t.Mv_Skill_214EX <- makeSkillTmpl_JumpCatchBomb( { type="EX" } );

local makeSkillTmpl_JumpCatchBombTechWait = function( param={} )
{
	local mvparam =
	{
		techFra=24,
		nextMv=0,
	}
	
	//mode==0:通常投げ抜け待機
	//mode==1:金投げ
	//def_FL_BoundTech == 30
	
	switch( param.type )
	{
	case "A":
		mvparam.nextMv = "Mv_Skill_214A_Hit";
		mvparam.techFra = (param.mode==0)? 24 : 30;
		break;
	case "B":
		mvparam.nextMv = "Mv_Skill_214B_Hit";
		mvparam.techFra = (param.mode==0)? 24 : 30;
		break;
	case "EX":
		mvparam.nextMv = "Mv_Skill_214EX_Hit";
		mvparam.techFra = (param.mode==0)? 24 : 30;
		break;
	}
	
	local ret_tmpl = Battle_Std.MakeMv.TechWait(
	{
		FrameID=512,
		ThrowParam={ pattern=17, x=160, y=0 },
		TechFrame = mvparam.techFra,
		NextMv=mvparam.nextMv,
	});

	return ret_tmpl;
}

//生投げ
//コンボのときは経由しない
//TechWait:生
//TechWait2:金
t.Mv_Skill_214A_TechWait <- makeSkillTmpl_JumpCatchBombTechWait( { type="A", mode=0 } );
t.Mv_Skill_214A_TechWait2 <- makeSkillTmpl_JumpCatchBombTechWait( { type="A", mode=1 } );
t.Mv_Skill_214B_TechWait <- makeSkillTmpl_JumpCatchBombTechWait( { type="B", mode=0 } );
t.Mv_Skill_214B_TechWait2 <- makeSkillTmpl_JumpCatchBombTechWait( { type="B", mode=1 } );
t.Mv_Skill_214EX_TechWait <- makeSkillTmpl_JumpCatchBombTechWait( { type="EX", mode=0 } );
t.Mv_Skill_214EX_TechWait2 <- makeSkillTmpl_JumpCatchBombTechWait( { type="EX", mode=1 } );

// コンボつかみ
local makeSkillTmpl_JumpCatchBombHitCombo = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		usePat = 0,
	}
	
	switch( param.type )
	{
	case "A":
		break;
	case "B":
		break;
	case "EX":
		break;
	}
	
	ret_tmpl.flags <- def_TmplFlags_NoClearVector|def_TmplFlags_NoAddComboRate, // ベクトル初期化無し,コンボレートを加算しない
	
	ret_tmpl.Init_After <- function()
	{
		local cp = BMvTbl.ComboPoint_Calc( { num=0 } );
		local border_cp = 66;
		local powerup = ( cp >= border_cp  )? 1 : 0; // 強い : 弱い ※1Pと2Pの差をなくすために同技制限は廃止
		BMvTbl.SetLP(0,powerup); // 強いやつかどうか
		if( powerup )
		{
			_dp("\n 強化バージョン");
		}
	}

	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		switch( mvs.FrameID )
		{
		case 0: //デフォルト
			Battle_Std.ThrowParam_WithHanteiEtc(320);
			break;
		case 90: // 分岐
			// CPの量に応じて分岐
			if( mvs.isFrameUpdate )
			{
				local jumpID = ( BMvTbl.GetLP(0) == 1 )? 100 : 110; // 強い : 弱い
				BMvTbl.JumpFrameID( jumpID );
				BMvEff.ThrowParam( { x=200, y=0, } );
				BMvEff.ThrowRelease( { type="腹やられ強", airrecover=0, flags=_ThrowRelease_NoGroundRecover } ); //離すだけ
			}
			break;
		case 100: // 強い
		case 110: // 弱い
			break;
		}	
	}
	
	
	return ret_tmpl;
}

t.Mv_Skill_214A_Hit <- makeSkillTmpl_JumpCatchBombHitCombo( { type="A" } );
t.Mv_Skill_214B_Hit <- makeSkillTmpl_JumpCatchBombHitCombo( { type="B" } );
t.Mv_Skill_214EX_Hit <- makeSkillTmpl_JumpCatchBombHitCombo( { type="EX" } );


//-----------------------------------------------------------------------------
// J236攻
//-----------------------------------------------------------------------------
local maketmpl_SkillAirSlash = function( param={} ) : (sousai)
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		extend_changepat = 0,
		extend_button = 0,
		karaburi_cs = 0,
	}
	
	switch( param.type )
	{
	case "A":
		break;
	case "B":
		mvparam.extend_changepat = "J236B_End";
		mvparam.extend_button = (1<<1);
		break;
	case "EX":
		mvparam.karaburi_cs = 1;
		break;
	}
	
	ret_tmpl.Init_After <- function() : (mvparam)
	{
		if( mvparam.karaburi_cs )
		{
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		}
		Battle_Std.Atemi.Init( { hantei=5, flags=0 } );
		BMvTbl.SetLP(0,0); // 何回相殺したか
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		Battle_Std.Atemi.FrameUpdate();
		
		if( mvparam.extend_changepat && mvparam.extend_button )
		{
			Battle_Std.SetPattern_NotHoldButton( { CheckFrameID=50, ButtonMask=mvparam.extend_button, SetPattern=mvparam.extend_changepat } );
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function() : (sousai)
	{
		local sousai_num = BMvTbl.GetLP(0); // 何回相殺したか
		local hitstoptime = (sousai_num==0)? 7:0; // 二回目以降は短く
		local ahs = Battle_Std.Atemi.HitInterrupt( { hitstop = hitstoptime, limiteffect=(sousai_num==0)? 0 : 1 } );
		if( ahs.IsTiming() )
		{
			sousai.HitInterrupt(sousai_num); // 相殺回数, (エフェクト表示Y座標)
			BMvTbl.AddLP(0,1);
		}
	}
	
	return ret_tmpl;
}


t.Mv_Skill_J236A <- maketmpl_SkillAirSlash( { type="A" } );
t.Mv_Skill_J236B <- maketmpl_SkillAirSlash( { type="B" } );
t.Mv_Skill_J236EX <- maketmpl_SkillAirSlash( { type="EX" } );


//-----------------------------------------------------------------------------
// 623攻
//-----------------------------------------------------------------------------
local maketmpl_SkillDP = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		karaburi_cs = 0, // ツールでCS可能なら空振りCS可能にする
		hit_lock = 0, // ヒット時の引き寄せの力
		noCancelNoAtkHit = 0, // キャンセルしないと追撃不能にする
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.hit_lock = 5;
		mvparam.karaburi_cs = 1;
		break;
	case "B":
		break;
	case "EX":
		mvparam.hit_lock = 50;
		mvparam.noCancelNoAtkHit = 1;
		break;
	}
	
	ret_tmpl.Init_After <- function() : (mvparam)
	{
		if( mvparam.karaburi_cs )
		{
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		Battle_Std.SetHitMuteki2_Param1( { [8]=_HitCheckFlag_Head, [64]=Def_HitCheckFlag_AirDive } );
	}
	
	ret_tmpl.HitInterrupt_After <- function() : (mvparam)
	{
		// 特殊判定0がある時だけDAMAGE時に引き寄せる処理
		if( mvparam.hit_lock )
		{
			if( Battle_Std.CheckDamageTiming() )
			{
				Battle_Std.SetPosition_DamageHanteiRect({ power=mvparam.hit_lock });
			}
		}
	}
	ret_tmpl.LastUpdate_After <- function() : (mvparam)
	{
		if( mvparam.noCancelNoAtkHit )
		{
			Battle_Std.NoCansel_NoAttackHit(); //何かでキャンセルしなかった場合追撃不能にする
		}
	}
	
	return ret_tmpl;
}


t.Mv_Skill_623A <- maketmpl_SkillDP( { type="A" } );
t.Mv_Skill_623B <- maketmpl_SkillDP( { type="B" } );
t.Mv_Skill_623EX <- maketmpl_SkillDP( { type="EX" } );

//-----------------------------------------------------------------------------
// 236攻
//-----------------------------------------------------------------------------

local maketmpl_SkillMovePunch = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
	}
	
	switch( param.type )
	{
	case "A":
		break;
	case "B":
		break;
	case "EX":
		break;
	}
	
	ret_tmpl.Init_After <- function()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			break;
		}
	}
	
	ret_tmpl.LastUpdate_After <- function() : (mvparam)
	{
	}	
	
	return ret_tmpl;
}


t.Mv_Skill_236A <- maketmpl_SkillMovePunch( { type="A" } );
t.Mv_Skill_236B <- maketmpl_SkillMovePunch( { type="B" } );
t.Mv_Skill_236EX <- maketmpl_SkillMovePunch( { type="EX" } );

t.Mv_Skill_236_AddOverKick <- {};
t.Mv_Skill_236_AddPress <- {};


//-----------------------------------------------------------------------------
// インフィニットワース
//-----------------------------------------------------------------------------

t.Mv_Skill_41236SP <-
{
	function Init_After()
	{
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100: // たたく
			break;
		case 150: // ヒット分岐の後（空振り確定）
			break;
		}
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256);
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_41236SP_Hit"]); //デフォ,[code,mv]...	
	}
}

t.Mv_AniSet_Ukase <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = 
[
	{ Data = [330,0,13], },
	{ Data = [330,1,8], InitVector = { x=-128, y=-11000, addy=300, flags=_Vector_Normal } },
	{ Data = [330,2,8], },
	{ Data = [330,3,8], },
	{ Data = [330,4,6], },
	{ Data = [330,5,5], },
	{ Data = [330,6,4], },
	{ Data = [330,7,4], },
	{ Data = [330,8,4], },
	{ Data = [330,9,4], RelJump = -1 },
] } );

t.Mv_AniSet_Rakka <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = 
[
	{ Data = [330,8,10],LandJump=3, InitVector = { x=0, y=8000, addy=200, flags=_Vector_Normal } },
	{ Data = [330,8,4], LandJump=3 },
	{ Data = [330,9,4], LandJump=3, RelJump = -1, },
	{ Data = [353,0,1], InitVector = { x=-128, y=-4000, addy=300, flags=_Vector_Normal }, 
		EnemyFunc=function()
		{
			// 床バウンドエフェクト表示
			BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
			BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
			BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ
		},
		Set={y=0},
	},
	{ Data = [353,1,5], },
	{ Data = [353,2,3], },
	{ Data = [353,3,3], },
	{ Data = [353,4,3], },
	{ Data = [353,5,3], },
	{ Data = [353,6,3], RelJump = -1,},
] } );

t.Mv_Skill_41236SP_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate, // コンボレートを加算しない
	function Init_After()
	{
		BMvEff.ThrowChara_SetJoint( 0 ); //くっつけない
		BMvEff.ThrowChara_SetCamera( 0 ); // 投げているキャラをカメラ処理に含めるかどうか
		BMvEff.SetCamera_Clipping( 0 ); //画面端のクリッピング補正を切る
		
		BMvEff.FadeProc_Set( { type=0, time=[0,1,6] color=0xFFFFFF } ); // 白フラッシュ

		BMvEff.CreateObject( { mvname="Mv_AniSet_Ukase" } ); // 吹き飛ばす
		
		BMvEff.SetExist( { level = _Exist_NoWall } ); // 画面外で行動する場合があるので壁判定解除
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 150: // 構え開始
			// スローにしてかっこよく
			BMvEff.Slowmotion_Set( { type=1, time=120, power=6000 } );

			local pos = BMvTbl.GetPosition( 0 );
			BMvEff.SetCamera_Focus( { num=0, zoom=1.0, time=[0,999,30] } );
			BMvEff.SetCamera_Focus( { num=1, x=pos.x-(50<<7)*BMvTbl.GetMuki(), y=0<<128, zoom=1.2, time=[90,999,30], type_in=2 } );
			break;
		case 160:
			// さらにスロー
			Battle_Std.MakeMv.LastCharaAnimeEnd(1);
			BMvEff.CreateObject( { mvname="Mv_AniSet_Rakka" } ); // 落下
			break;
		case 170:
			// 暗転
			BMvEff.Slowmotion_Set( { type=1, time=60, power=5000, power_minus=5000/20 } );
			local frame = 30;
			BMvEff.CutInProc_Set({ time=[0,frame,10], cutin_mv="",erasetype=2, bgtype=1 });
			Battle_Std.SetEXCutinGrp( { flags=(1<<0) } );
			// カメラ初期化＆揺らしてズレをごまかす
			BMvEff.SetCamera_Focus( { time=[0,0,0] } );
			BMvEff.SetCamera_Quake( { type=2, time=30, } ); // ドンッ
			break;
		case 190: // 叩く前
			// 相手の絵をキャッシュ予約
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvCore.CallEntryBCCachePreTransfer( { pat=331, frame=2, rest=5 } ); // FrameID200での相手のやられ
				
				enemy.pop();
			}
			break;
		case 200: // 強くたたく
			BMvEff.SetCamera_UpdateFlag( 0, 0 );
			Battle_Std.MakeMv.LastCharaAnimeEnd(1);
			//相手はくっついているのでカメラは固定にしてじわっと動かす
			local pos = BMvTbl.GetPosition( 0 );
			BMvEff.SetCamera_Focus( { zoom=1.0, x=pos.x+50*128*BMvTbl.GetMuki(), time=[6,999,30] } );
			break;
		case 400:
			BMvEff.SetCamera_Quake( { time=30, type=2, clear=0, } ); //フィニッシュの強め揺らし
			break;
		case 500: // とどめ
			BMvEff.FadeProc_Set({type=0, time=[4,60,20] color=0xFFFFFF});
			break;
		}
	}	
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP_End" )
	}
	function LastUpdate_After()
	{
		BMvEff.SetExist( { level = _Exist_NoWall, mode=_ExistMode_Erase } ); // 画面外判定チェックを戻す
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );
		BMvEff.FadeProc_Set({type=0, time=[0,1,20] color=0xFFFFFF});
		
		BMvEff.CutInProc_Erase(); //カットインがあったら消去する
		BMvEff.SetCamera_UpdateFlag( 0, 0 );
		
		BMvEff.ThrowChara_SetJoint( 1 ); //くっつけないを戻す
		BMvEff.ThrowChara_SetCamera( 0 ); // 投げているキャラをカメラ処理に含めるかどうか
		BMvEff.SetCamera_Clipping( 1 ); //画面端のクリッピング補正を戻す
		
		BMvEff.ThrowRelease( { type="腹吹き飛び", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover|_ThrowRelease_NoWallRecover } );
	}
}

t.Mv_Skill_41236SP_End <-
{
	flags = def_TmplFlags_NoAddComboRate, // コンボレートを加算しない
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
}


//-----------------------------------------------------------------------------
// インフィニットワースＥＸＳ
//-----------------------------------------------------------------------------

t.Mv_Skill_IWEXIST <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_IWEXIST_Hit"]); //デフォ,[code,mv]...
	}	
}

t.Mv_Skill_IWEXIST_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.InitIWExistSkill();
		
		BMvEff.SetCamera_Clipping( 0 ); //画面端のクリッピング補正を切る

		BMvEff.ThrowParam( { pattern=304, x=250, y=0, } ); //敵の座標を設定
		
		BMvEff.ThrowChara_SetJoint( 0 ); //くっつけない
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10://最初
			break;
		case 12://力をためるちょいズーム
			local pos = BMvTbl.GetPosition( 0 );
			BMvEff.SetCamera_Focus( { num=0, zoom=1.0, time=[0,999,30] } );
			BMvEff.SetCamera_Focus( { num=1, x=pos.x-(50<<7)*BMvTbl.GetMuki(), y=0<<128, zoom=1.2, time=[90,999,30], type_in=2 } );
			break;
		case 20://突進前
			// カメラ初期化＆揺らしてズレをごまかす
			BMvEff.SetCamera_Focus( { time=[0,0,0] } );
			BMvEff.SetCamera_Quake( { type=2, time=30, } ); // ドンッ
			
			// 相手の絵をキャッシュ予約
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvCore.CallEntryBCCachePreTransfer( { pat=331, frame=2, rest=10 } ); // FrameID30での相手のやられ
				
				enemy.pop();
			}
			break;
		case 30://突進開始
			// 相手を吹き飛ばす
			BMvEff.ThrowChara_SetJoint( 1 ); //くっつける
			break;
		case 40://突進ループ
			break;
		case 100://アップ
			_dpn("BGM Fade 1");
			BMvEff.Cockpit_SetView( { mode=2 } ); // 一部のみ消去
			BSound.BGM_SetFade( { val=50, time=240 } );//BGMのフェードアウト
			//白フェードでイン
			BMvEff.FadeProc_Set( { type=0, time=[ 0, 1, 20 ], color = 0xFFFFFF } );
			BMvEff.CreateObject( { mvname="Mv_Obj_SPHitCountEffect", id=1 } );
			
			// 相手非表示
			BMvEff.ThrowParam( { pattern=320, x=0, y=2500, } ); //埋めて隠す
			break;
		case 300://爆発引き
			BSound.SE_SetFade( { val=40, time=60 } ); // 遠くにいくので音を小さくする
			BMvEff.Cockpit_SetView( { mode=1 } ); // 戻す
			_dpn("BGM Fade 2");
			BSound.BGM_SetFade( { val=25, time=240 } );//BGMのフェードアウト
			break;
		case 350://とどめ前のタメ
			BSound.SE_SetFade( { val=100, time=0 } ); // 戻す
			local findobject = BMvCore.CFindObject().Get(1);
			if( findobject.push() )
			{
				BMvTbl.SetFinalize(); // 消す
				findobject.pop();
			}
			break;
		case 900://とどめ爆発
			break;
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST_End" );
	}	
	function LastUpdate_After()
	{
		Battle_Std.FinalizeIWExistSkill();

		BMvEff.SetCamera_Clipping( 1 ); //画面端のクリッピング補正を戻す
		
		BMvEff.SetCamera_Focus( { time=[0,0,30] } ); // カメラ固定を戻す
		BMvEff.SetCamera_Quake( { time=0, type=2, clear=0, } ); //揺らし
		
		BMvTbl.SetPosition( { x=-250*128*BMvTbl.GetMuki() } );
		BMvEff.ThrowParam( { x=600, y=-100, } );
		BMvEff.ThrowRelease( { type="鋭角斜め下バウンド", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		
		BMvEff.SetCamera_FocusKeep( 0 );
		BMvEff.ResetCamera(); //カメラ初期化
		BMvEff.ResetViewCamera();

		BMvEff.Cockpit_SetView( { mode=1 } ); // 戻す
		BSound.SE_SetFade( { val=100, time=0 } ); // 戻す
	}
}

t.Mv_Obj_SPHitCountEffect <-
{
	function Init_After()
	{
		// MV変更で消える
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } ); //行動変更で消滅
	}
	function Update_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			// ヒット数加算・SE再生
			// _dpn("ヒット数加算");
			BMvTbl.AddComboCount( 1 );
			break;
		}
	}
}

t.Mv_Skill_IWEXIST_End <- 
{
	function Init_After()
	{
		BMvTbl.SetMuki( _Direction_Auto );
	}
}


CHR019_MoveTable <- Battle_Std.MakeMoveTable( t, CHR019_CommandTable, Def_ChrNo_Tsu );
__dofile__("./data/chr019/chr019_se_category.txt"); //ＳＥ定義