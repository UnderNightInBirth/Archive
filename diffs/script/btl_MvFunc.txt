btl_debPrint2( "\n>>> [btl_MvFunc]" );

// _checkFurimuki : 入力後振り向き処理があるMvの場合は1、そうでない場合は0でチェックする
// 自キャラの向きや振り向きに依存せず、左か右かで記憶するべきな気はするがひとまずそのまま
Battle_Std.SetTechReverse <- function( _checkFurimuki=1 )
{
	local check_stick = (1<<4)|(1<<7)|(1<<1); //チェックするレバーの向き
	if( _checkFurimuki && BMvTbl.CheckFurimuki() ) //相手の方を向いていない
	{
		check_stick = (1<<6)|(1<<9)|(1<<3); //チェックするレバーは６
	}
	
	if( BMvTbl.CheckStickHold( check_stick ) )
	{	
		// _dpn("【逆投げです】");
		BMvTbl.SetPP( def_PP_TechReverse, 1 ); //逆向きなのを記憶
	}
	else
	{
		// _dpn("【正投げです】");
		BMvTbl.SetPP( def_PP_TechReverse, 0 );
	}
}

//投げ抜け関係の共通処理
Battle_Std.ThrowTech <- {};

Battle_Std.ThrowTech.SetMuteki <- function() //つかみ中は自分も相手も無敵にする
{
	//つかみ中は自分も相手も無敵にする
	BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } ); //つかみ中は無敵にする
	
	//相手も無敵に
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } ); //つかまれ中は無敵にする
		
		enemy.pop();
	}
}

//Battle_Std.ThrowTech.SetPos
//type=0:通常投げ 1:必殺技とか？
Battle_Std.ThrowTech.SetPos <- function(type=0) //つかむ前の自分と相手の座標を記憶する
{
	local ppos = BMvTbl.GetPosition(0);				//自分の座標
	BMvTbl.SetPP( def_PP_PlayerPosX, ppos.x );		//自分の座標を記憶

	local epos = Battle_Std.GetEnemyPosition();		//相手の座標		
	BMvTbl.SetPP( def_PP_EnemyPosX, epos.x ); 		//相手の座標を記憶
	
	if( type==1 ) //type:1 必殺技の投げ
	{
		BMvTbl.SetPP( def_PP_TechReverse, 0 ); //とりあえず逆向き開放は無いってことで
	}
}

// 硬直中だったらパニッシュということにして、色々設定してしまう
// 投げ抜け可能な場合は呼んではいけない
// この関数は投げで掴む瞬間にしか呼んではいけない(GetMvHitStatus を見るので)
Battle_Std.ThrowTech.CheckTechImpossible <- function( _setCharaFlash = 1 ) //相手が投げ抜けできない状態かチェックして演出を入れるまとめ処理
{
	_dpn("CheckTechImpossible:"+_setCharaFlash);
	//相手が行動不能かどうかチェック
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	local enemy_isMovable = true; //敵が行動可能かどうか
	local mvhs = BMvTbl.GetMvHitStatus();
	local throw_counter = 0;
	
	if( enemy.push() )
	{
		// if( BCMDTbl.CheckCancel( _SkillType_None )!=255 ) // 行動不能中 ※投げでMv_BoundCaptureになるとスクリプト操作が1Pだけ消える
		if( mvhs.isMoveable != 1 ) // 相手が行動可能じゃなかった
		{
			if( Def_Dbg_TechHitLog ) _dpn("行動不能中を掴まれた");
			
			if( Battle_Std.GetPSFlag( def_PP_PS_isThrowMv ) )
			{
				if( Def_Dbg_TechHitLog ) _dpn("投げモーション中の行動不能でした");
			}
			else
			{
				//print("\n乙");
				enemy_isMovable = false;
				if( _setCharaFlash )
				{
					throw_counter = 1;
					Battle_Std.SetCharaFlash_TechMiss(); //投げ抜け不能による発光
					Battle_Std.CreateTechObject_TechMissStart(); //投げ抜け不能にする
				}
			}
		}
		else
		{
			//行動可能中
		}
		enemy.pop();
		
		if( throw_counter )
		{
			Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_ThrowCounter );//投げで硬直を掴んだ
		}
		
		if(!enemy_isMovable)
		{
			return true;
		}
	}
	return false;
}

Battle_Std.ThrowTech.ShiftOverGamenHajiX <- function() //相手が画面端だったら埋まらないようにつかみ側と記憶してた座標をズラす
{
	local epos = Battle_Std.GetEnemyPosition();		//相手の座標		
	local sa_x = 0;
	//_dm("座標:"+epos.x);
	if( epos.x > def_POS_TechOverGamenHajiX )
	{
		sa_x = epos.x - def_POS_TechOverGamenHajiX;
	}
	else if( epos.x < -def_POS_TechOverGamenHajiX )
	{
		sa_x = epos.x - -def_POS_TechOverGamenHajiX;
	}
	//_dm("差："+sa_x);
	if( sa_x != 0 )
	{
		BMvTbl.SetPosition( { x=-sa_x, flags=_Position_Add } );
		local pposx = BMvTbl.GetPP( def_PP_PlayerPosX ); //保存してある自分の座標を取得
		pposx -= sa_x; //こっちもズラす
		BMvTbl.SetPP( def_PP_PlayerPosX, pposx );		//自分の座標を更新		
	}
}

//通常投げ成立時に呼ばれる
//特殊判定の座標にやられ絵にする
Battle_Std.ThrowTech.SetThrowParam <- function()
{
	if( Def_Rule_SetThrowType )
	{
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange|_HanteiFlag_Tool } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			if( Def_Rule_SetThrowType == 1 )
			{
				BMvEff.ThrowParam( { pattern=304, x=rc.sx, y=0, } );
			}
			else if( Def_Rule_SetThrowType == 2 )
			{
				BMvEff.ThrowParam( { x=rc.sx, y=rc.sy, pattern=320, hantei_rect=[ _Hantei_Etc, 10 ] } );
			}
		}
	}
}

//投げエフェクトよびだし
//通常投げ・必殺技共通 typeは強引の投げかどうか
//特殊判定がなかったらエフェクトは出さないように仕様を変更
Battle_Std.ThrowTech.DrawThrowEffect <- function(type=0) //ヒット座標につかみエフェクトを表示
{
	//_dm("DrawThrowEffect");
	//ヒット座標につかみエフェクト出す？足元に出たりするから…
	local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange|_HanteiFlag_Tool } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		if( type==0 ) //通常の投げ
		{
			Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
			datatype=1, pat=55,
			objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
			});
		}
		else if( type==1 ) //強引の投げ
		{
			//つかみ座標に出すタイプ
			/*
			Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
			datatype=1, pat=58,
			objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
			});
			*/
			
			//重なりを見て出すタイプ
			local enemy = BMvCore.GetCaptureCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				//つかみ相手の重なり判定を取得
				local erc = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange } );
				
				enemy.pop();

				if( erc.sx != _Hantei_Error ) // 存在するか
				{
					//敵側から出す
					if( enemy.push() )
					{
						Battle_Std.CreateObjectEX({ x=0, y=(erc.sy*65/100),
						datatype=1, pat=58,
						objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoGround
						});
					}
					enemy.pop();
				}
				else
				{
					//重なりが無いなら今までどおりつかみ側の特殊判定のところに出す
					Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
					datatype=1, pat=58,
					objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
					});				
				}
			}
		}
	}

	//画面揺らしを発生
	BMvEff.SetCamera_Quake( { time=7, type=1, } ); //横ゆれ	
}

Battle_Std.ThrowTech.DrawTechEffect <- function() //投げ抜け演出を表示
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		if( def_AISW_TechHit ) BMvEff.AttackInfoString_Set({ word=def_AISW_TechHit,} );
		Battle_Std.SetCharaFlash_TechSuccessInit(); //投げ抜け成功発光
		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=132, flags=0 } ); //投げぬけ音声
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		
		//【トロフィー】実戦で投げ抜けを成功させた。
		//BMvTbl.Achievement_Unlock(1);
		
		enemy.pop();
	}
}

Battle_Std.ThrowTech.TechRelease <- function( param={} ) //投げ抜けされた時の開放処理
{
	local release_kyori = ( "release_kyori" in param )? param.release_kyori : 0; // 0:そのまま戻す　!=0:指定座標固定
	
	//投げ前の座標に戻す処理
	local pos_x = BMvTbl.GetPP(def_PP_PlayerPosX); //予定している戻すＸ座標
	//画面外とかありえない数値だとヤバいので補正をかけよう
	if( pos_x >= def_POS_GamenHajiX )
	{
		pos_x = def_POS_GamenHajiX;
	}
	else if( pos_x <= -def_POS_GamenHajiX )
	{
		pos_x = -def_POS_GamenHajiX;
	}
	BMvTbl.SetPosition( { x = pos_x, y=0 } ); //自分の座標を戻す(Yは地面固定)
	
	local sa = (BMvTbl.GetPP(def_PP_EnemyPosX) - BMvTbl.GetPP(def_PP_PlayerPosX))/128;
	sa = ((sa >= 0)?  sa : -sa);
	
	//一度でも殴られていないとのけぞりを返す相手がいないので
	//つかみ中の相手は操作親に一度殴られたことにする
	local enemy = BMvCore.GetCaptureCharaData(); // 投げている相手を取得
	if( enemy.isdone() )
	{
		BMvCore.SetLastDamageCharaData(enemy); // 殴られたことに
	}
	
	// _dpn("sa:"+sa); // 通常投げは100〜200ぐらいだった ※ワレンとかだと240ぐらい
	if( Def_Sys_FixPosAfterThrowTech && release_kyori )
	{
		//投げ抜け後の座標固定
		sa = release_kyori;// Def_Sys_FixPosAfterThrowTech にはしないで指定可能にした
	}	
	
	//相手を投げ抜け押し返しのモーションで解放し、自分も	Mv_Techedに移動
	BMvEff.ThrowParam( { x=sa+64, y=0 } ); //ツール座標（これは座標補正がかかるからそのままで大丈夫だろ）
	BMvEff.ThrowRelease( { type="投げ抜け押し返し" } ); //適当
}

//投げ抜けMVのUpdateで呼ばれて、投げ抜けをチェックする
Battle_Std.ThrowTech.CheckTechCommand <- function() //投げ抜け入力をされたかチェック
{
	local enemyistech = false; //敵が投げ抜けコマンドを入れたかどうかフラグ
	
	if( Battle_Std.CharaisKO() ) return false; // 誰かがＫＯ状態なら常に失敗
	
	if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnemyTechImpossible ) ) return false; // 投げ抜け不能状態

	//ＫＯ状態でない時
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		local ts = Battle_Std.GetTechStatus(); //投げ抜けステータス取得
		if( ts.isDone ) // かつて投げ抜けを入れてた
		{
			if( ts.isTechOK )
			{
				enemyistech = true;			
				if( Def_Dbg_TechHitLog ) _dpn("投げ抜けを入れて通った");
			}
			else
			{
				enemyistech = false;			
				if( Def_Dbg_TechHitLog ) _dpn("投げ抜け失敗フレーム中でした");
			}
		}
		else // 入れてないなら手動も受け付ける
		{
			local check = BMvTbl.CheckCommandString( { command=["A+D"], lastdelay=1 } );
			if( check )
			{
				enemyistech = true;
				if( Def_Dbg_TechHitLog ) _dpn("投げ抜けした"); //しゃがグラとかがこの辺
			}
		}
		enemy.pop();
	}
	return enemyistech;
}

//Battle_Std.SetThrowHitFinalize()　で呼ばれる用の関数
Battle_Std.ThrowTech.CheckTechMissFrame <- function() //投げ抜け失敗フレームなのかチェック
{
	local enemyistechmiss = false; //敵が投げ抜けコマンドを入れたかどうかフラグ
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る

	if( enemy.push() )
	{
		local ts = Battle_Std.GetTechStatus(); //投げ抜けステータス取得
		if( ts.isDone && ts.isTechOK == false )
		{
			enemyistechmiss = true;			
			if( Def_Dbg_TechHitLog ) _dm("投げ抜け失敗フレーム中でした");
			Battle_Std.SetCharaFlash_TechMiss(); //投げ抜け不能による発光
		}
		enemy.pop();
	}
	return enemyistechmiss;
}


//1F後に投げ属性フラグを消去する
Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame <- function()
{
	BMvEff.CreateObject( {  mvname="Mv_Obj_DelThrowMv" } ); //1F後にフラグを消すMvを作成
}

Battle_Std.ThrowTech.SetThrowMvFlag <- function()
{
	Battle_Std.SetPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを設定
}

//投げ属性モーションを設定し、一定時間orMvの変更により自動で属性を消す
Battle_Std.ThrowTech.SetThrowMvFlag_AutoDel <- function( frame=0 )
{
	Battle_Std.SetPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを設定
	
	local eff = BMvEff.CreateObject( {  mvname="Mv_Obj_SetAutoThrowMv" } );
	if( eff.push() )
	{
		BMvTbl.SetLP( 0, frame );
		
		eff.pop();
	}
}



Battle_Std.Reversal <- {};

Battle_Std.Reversal.SetTime <- function( frame=1 )
{
	//実際の関数は1F早く進んでしまうのでtime=frame+1となる
	local time = frame+1;
	//print("\nここではいってくるー");
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		BMvTbl.SetCommandLongDelay(time); //リバーサルを一定時間受け付ける
		BMvTbl.SetPP( def_PP_ReversalLeftTime, time+1 ); //このオブジェクトはさらに先に1F減っちゃうので+1Fする
		//さらにのこり時間を減らすオブジェクトを生成する
		BMvEff.CreateObject( {  mvname="Mv_Obj_ReversalTime" } ); //1F後にフラグを消すMvを作成
		
		player.pop();
	}
}

Battle_Std.Reversal.GetTime <- function()
{
	return( BMvTbl.GetPP( def_PP_ReversalLeftTime ) );
}

//リバーサルの残り時間があったら１を返して文字列表示
Battle_Std.Reversal.CheckTime_DrawInfo <- function( _drawinfo = 1 )
{
	if( GetTime() > 0 )
	{
		if( _drawinfo ) BMvEff.AttackInfoString_Set({ word=def_AISW_Reversal,} ); //リバサ必殺技だと思う
		
		BMvTbl.SetPP( def_PP_ReversalLeftTime, 0 ); // リバーサル表示はもう出さない
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_Reversal ); // リバサ状態のMvなのを記憶
		
		return 1;
	}
	return 0;
}


//よくやるJumpFrameIDをまとめる
//設定FrameID, 上書きPattern, 失敗時FinalizeCode
Battle_Std.JumpFrameIDEX <- function( _frameID, _pat=-1, _code=-1 )
{
	if( _pat!=-1 )
	{
		Battle_Std.SetPattern_NotEqual(_pat); //パターンが違っていたら変える
	}
	if( BMvTbl.JumpFrameID(_frameID)==-1 ) //飛び先FrameIDが無かったらもうFinalizeしちゃう
	{
		if( _code!=-1 )
		{
			BMvTbl.SetFinalize(_code);
			//_dm("FrameIDが無いんだけど…");
		}
	}
}

//パターンセット（既に同じパターンだったらやらないおまじない的なもの）
Battle_Std.SetPattern_NotEqual <- function(_pat)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.DataPattern!=_pat )
	{
		//_dm("PATが違うようだ"+_pat+" 今:"+mvs.DataPattern);
		BMvTbl.SetPattern(_pat); //違うのでパターンセット
		return 1;
	}
	//_dm("ＯＫ牧場");
	return 0; //同じなので特に変更しない
}

//調整用のデバッグメッセージ
Battle_Std.DrawDebugAttackInfo <- function(str)
{
	//return; //見られるとアレなので
	if( Def_Dbg_LocalAnnounce )
	{
		BMvEff.AttackInfoString_Set({ word=str,} );		
	}
}

Battle_Std.Create_TechDelayCheckObject <- function( delay=0 )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		//ここから相手の投げコマンドチェックオブジェクト生成
		BMvEff.CreateObject( { mvname="Mv_Obj_CheckTechDelay", } ); //
		
		enemy.pop();
	}
}

// 個別に再生していいかのチェックと再生処理
local individual_se_check = function( target, num, flags )
{
	local result = { 
		ret_val = -1,
		flags = 0,
	}
	//再生個別チェック
	if( "playfunc" in target )
	{
		if( target.playfunc()!=1 )
		{
			result.ret_val = 0;
			return result;
		}
	}
	
	// 以下は大体再生確定してるがディレイのものもある

	//再生時にパターンを変更する（超限定的処理）
	if( "pattern" in target )
	{
		BMvTbl.SetPattern( target.pattern );
	}
	if( "flags" in target )
	{
		result.flags = target.flags;
	}

	//割と確定かつディレイ系の処理(return1する)
	if( "delayframe" in target )
	{
		//ディレイ再生が登録されていた
		//_dm("ディレイ再生！");
		local frame = ( flags&(1<<1) )? BSound.SE_GetUserParam( { type=_SeType_Player, num=num, } ) : 0;//音声のフレーム数を取得
		//_dpn("ディレイ再生:"+flags+" frame:"+frame+" num:"+num);
		local eff = BMvEff.CreateObject( { mvname="Mv_Obj_DelayPlaySE" } );
		if( eff.push() )
		{
			BMvTbl.SetLP(0,target.delayframe);
			BMvTbl.SetLP(1,num);
			BMvTbl.SetLP(2,flags);
			BMvTbl.SetLP(3,frame); // 音声の長さ
			
			eff.pop();
		}
		result.ret_val = 1;
		return result;
	}
	else if( "delayParam0" in target )
	{
		//ディレイParam0再生が登録されていた
		//_dm("ディレイParam0再生！");
		local frame = ( flags&(1<<1) )? BSound.SE_GetUserParam( { type=_SeType_Player, num=num, } ) : 0;//音声のフレーム数を取得
		local eff = BMvEff.CreateObject( { mvname="Mv_Obj_DelayParam0PlaySE" } );
		if( eff.push() )
		{
			BMvTbl.SetLP(0,target.delayParam0);
			BMvTbl.SetLP(1,num);
			BMvTbl.SetLP(2,flags);
			BMvTbl.SetLP(3,frame); // 音声の長さ
			
			eff.pop();
		}
		result.ret_val = 1;
		return result;
	}
	return result;
}


//ちょっと適当に分離
local play_se = function( info, flags ) : (individual_se_check)
{
	local targetar = info.selist.common; // 使うSEListの配列
	local enemy_chara_no = 0;//敵のcharano

	local enemy = BMvCore.GetEnemyCharaData(); // 敵の情報を得る			
	
	if( enemy.push() )
	{
		//_dm("TypeSE_Play 相手がいた")
		local es = BMvTbl.GetMvStatus(); // ステータス取得
		enemy_chara_no = es.CharaNo;
		
		enemy.pop();
		
		if(es.CharaNo in info.selist)
		{
			// 相手キャラ用の定義があれば使う
			// checkfuncで抽選に入れるかを調整できるようにした
			local tmp_list = info.selist[es.CharaNo];
			if( typeof tmp_list == "table" )
			{
				if( "checkfunc" in tmp_list && tmp_list.checkfunc()!=1 )
				{
				}
				else if( "common" in tmp_list )
				{
					targetar = tmp_list.common;
				}
			}
			else
			{
				targetar = tmp_list;
			}
		}
		else if( "common_combo" in info.selist && Battle_Std.CheckEnemyisDamage() )
		{
			targetar = info.selist.common_combo;
		}
	}
	
	
//			local targetar = (es.CharaNo in info.selist)? info.selist[es.CharaNo] : info.selist.common;
//			local targetar = info.selist.common;
	if( targetar.len()==0 ) return 0; //ないじゃん
	
	if( "Param0" in info )
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\n "+s.Param0);
		if( !s.isFrameUpdate ) return 0; //最初の１Ｆだけだよ
		if( s.Param0 != info.Param0 ) return 0; //ないじゃん
	}
	
	if( "MvCount" in info )
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if( !mvs.CallCount==1 ) return 0;
		if( mvs.MvCount != info.MvCount ) return 0; //タイミング違い
	}	

	if( "LastSE" in info )
	{
		local lastplay_senum = BMvTbl.GetPP(def_PP_LastPlaySound);
		
		if( typeof info.LastSE == "array" )
		{
			local find = 0;
			foreach( slot, val in info.LastSE )
			{
				if( val == lastplay_senum )
				{
					find = 1;
					break;
				}
			}
			if( !find ) return 0; //最後に再生したのじゃなかった
		}
		else
		{
			if( info.LastSE != lastplay_senum ) return 0; //最後に再生したのじゃなかった
		}
	}
	if( "NotLastSE" in info )
	{
		//最後に再生したのがこれじゃなかったら入る（LastSEとセットで使うイメージ）
		local lastplay_senum = BMvTbl.GetPP(def_PP_LastPlaySound);
		
		//最後に再生したのと一致したら失敗
		if( typeof info.NotLastSE == "array" )
		{
			foreach( slot, val in info.NotLastSE )
			{
				if( val == lastplay_senum )
				{
					return 0;//失敗
					break;
				}
			}
		}
		else
		{
			if( info.NotLastSE == lastplay_senum ) return 0; //最後に再生してたので失敗
		}
	}	
	
	//checkfuncで抽選に入れるかを調整
	//重みというわけではないので注意
	local pick_list = [];
	
	if( typeof targetar == "array" )
	{
		foreach( slot, val in targetar )
		{
			// _dpn(slot+":"+val);
			local pick = 1;//抽選に入れるか
			if( val in info && "checkfunc" in info[val] )
			{
				if( info[val].checkfunc()!=1 )
				{
					pick = 0;
				}
			}
			//音声被りチェック（面倒なのでタッグとかはやってない）
			if( val in info && "kaburi" in info[val] )
			{
				local use_kaburi_ar = 0;
				if( enemy_chara_no in info[val].kaburi )
				{
					use_kaburi_ar = info[val].kaburi[enemy_chara_no];
				}
				else if( "common" in info[val].kaburi )
				{
					use_kaburi_ar = info[val].kaburi.common;
				}
				
				if( use_kaburi_ar && use_kaburi_ar.len() > 0 )
				{
					if( Battle_Std.InArrayLastPlaySound( use_kaburi_ar ) ) pick = 0;
				}
			}
			
			//一気に登録する系でチェックするもの
			if( typeof val == "table" && "checkfunc" in val )
			{
				if( val.checkfunc()!=1 )
				{
					pick = 0;
				}
			}
			
			if( pick ) pick_list.append( val );
		}
	}
	
	if( pick_list.len()==0 ) return 0; //ないじゃん2
	
	//再生するファイルが確定
	//Random_Limitが原因？でエラーが出ることがある？一応エラーチェックを入れるようにした
	local num_pos = BMvEff.Random_Limit(pick_list.len());
	if( num_pos > pick_list.len()-1 )
	{
		if( _DevWindows && Def_Dbg_LocalDebugScriptPath )
		{
			Battle_Std.DebugFunc.DrawDebugCharaInfo( num_pos, pick_list.len() );
		}

		// ありえないエラーだが…何故か発生することがあった
		num_pos = pick_list.len()-1;
	}
	if( num_pos < 0 ) num_pos = 0;
	
	local num_tmp = pick_list[ num_pos ] //抽選　※intかtableの事があるので以下で分解
	local num = ( typeof num_tmp == "integer" )? num_tmp : -1; // -1はエラー
	local num_table = ( typeof num_tmp == "table" )? num_tmp : -1; // -1はエラー
	
	if( !( Battle_Std.PlayerisKO() && ((("dying" in info)? info.dying : 0 )==0) ) )
	{
		// 「KO状態かつ"dying"が無い」ではない時の処理（再生する条件）
		if( BMvEff.Random_Limit(100) < (("average" in info)? info.average : 100) )
		{
			local voice_flags = 0;
			
			if( num != -1 && num in info )
			{
				//個別に弾く処理などがないか確認 [100] = {hoge}系
				local target = info[num];
				local individual_check = individual_se_check( target, num, flags );

				//individual_check.ret_val : -1, 0, 1
				//individual_check.flags   : 0
				voice_flags = individual_check.flags;
				if( individual_check.ret_val != -1 )
				{
					// ここに着た時点で登録する
					if( voice_flags&(1<<4) )
					{
						if( typeof num == "integer" )
						{
							BMvTbl.SetPP(def_PP_LastPlaySound,num);//記憶のみ
						}
					}
					return individual_check.ret_val;
				}
			}
			
			//一気に呼ぶタイプ
			if( num_table != -1 && typeof num_table == "table" )
			{
				//テーブル定義
				foreach( slot, val in num_table )
				{
					// _dpn("音呼び:"+slot+" "+val );
					if( typeof val == "integer" && typeof slot == "integer" )
					{
						local frame = ( flags&(1<<1) )? BSound.SE_GetUserParam( { type=_SeType_Player, num=val, } ) : 0;//音声のフレーム数を取得
						
						local eff = BMvEff.CreateObject( { mvname="Mv_Obj_DelayPlaySE" } );
						if( eff.push() )
						{
							BMvTbl.SetLP(0,slot);
							BMvTbl.SetLP(1,val);
							BMvTbl.SetLP(2,flags);
							BMvTbl.SetLP(3,frame); // 音声の長さ
							
							eff.pop();
						}
					}
				}
			}
				
			//delayじゃないのが再生が確定 -------------------------------------------------------------
			if( Def_DbgMes_PlaySE )
			{
				local se_type = BMvEff.GetSeType();
				local name = Battle_Std.GetPlayerMvName();
				if( typeof num != "table" )
				{
					_vdm(format("PlaySE [%3d_%d] -- %s",num,se_type,name));
				}
			}
			
			// Battle_Std.PlayerSE_Playのフラグ flags
			//1<<0 : 再生せずにdef_PP_LastPlaySoundに記憶する
			//1<<1 : 字幕あり、音声は再生しない（事前に再生している）
			//1<<2 : 再生時に直前の音声を止める
			//1<<3 : def_PP_LastPlaySoundに記憶しない
			
			// ボイス定義側のフラグ voice_flags
			//1<<0 : 再生せずにdef_PP_LastPlaySoundに記憶する
			//1<<4 : 抽選された時点で再生前にdef_PP_LastPlaySoundに記憶
			
			if( num != -1 ) // 通常タイプで再生された
			{
				if( flags&(1<<0) || voice_flags&(1<<0) )
				{
					if( !(flags&(1<<3)) && typeof num == "integer" )
					{
						BMvTbl.SetPP(def_PP_LastPlaySound,num);//記憶のみ
					}
				}
				else if( flags&(1<<1) )
				{
					//登場掛け合いを除いた字幕表示箇所
					//勝利など
					local frame = BSound.SE_GetUserParam( { type=_SeType_Player, num=num, } );//音声のフレーム数を取得
					local use_frame = ( frame != 0 )? frame : 180;
					
					if( typeof num == "integer" )
					{
						Battle_Std.Play_SubtitleVoice( num, use_frame+10 );//10Fマージン
					}
					if( !(flags&(1<<3)) && typeof num == "integer" )
					{
						BMvTbl.SetPP(def_PP_LastPlaySound,num);//記憶(MEMO:字幕側のPlay_SubtitleVoiceで記憶するべきかもだが影響大きいので除外)
					}
				}
				else
				{
					if( flags&(1<<2) )
					{
						Battle_Std.PlayerSE_StopLastPlaySound();
					}
					Battle_Std.PlayerSE_Play( num, flags ); //_SeType_Playerのnumを再生して記憶
				}
			}
			return 1;
		}
	}
	return 0;
}

//キャラクターＳＥの再生と記憶
Battle_Std.PlayerSE_Play <- function( num=0, flags=0 )
{
	BSound.SE_Play( { type=_SeType_Player, num=num } );

	if( !(flags&(1<<3)) && typeof num == "integer" )
	{
		BMvTbl.SetPP(def_PP_LastPlaySound, num); //最後に再生したのを記憶
	}
}

//直前に再生したＳＥを停止する
Battle_Std.PlayerSE_StopLastPlaySound <- function( _checkMyKo = 0 )
{
	// KOした後はこの処理を行わない
	// ヒルダの文鎮KOみたいな、KO後に投げ判定があたると音声がとまってしまうので
	if( _checkMyKo )
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		if( rs.isMyKo ) return;
	}
	
	BSound.SE_Stop( { type=_SeType_Player, num=BMvTbl.GetPP(def_PP_LastPlaySound) } );
}

//種類で定義されてるのを再生する
//何か再生した 1
//定義されていないか何かで再生しなかった 0
Battle_Std.TypeSE_Play <- function(tbl) : (play_se)
{	
	local flags = ("flags" in tbl)? tbl.flags : 0;
	if( "type" in tbl )
	{
		//print("\n:"+tbl.type);
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		//print(" CharaNo:"+mvs.CharaNo)
		
		local SeTbl = Battle_Std.SeTable[mvs.CharaNo];
		//print(" SeTbl:"+SeTbl)
		
		if( tbl.type in SeTbl ) //この種類のSeが定義されてた
		{
			//print(" .");
			local info = SeTbl[tbl.type];
			
			if( typeof info=="array")
			{
				local ret = 0;
				for(local i = 0; i < info.len(); i++)	
				{
					local ctbl = info[i];
					local ret2 = play_se( ctbl, flags );
					// if( ret2 ) return ret2; // こうするべきな気がするが影響大きそうなので変えない
					if( ret2 ) ret = ret2;
				}
				return ret;
			}
			else
			{
				return play_se( info, flags )
			}
		}
		else
		{
			return 0;
		}
	}
	return 0;
}

local stop_se = function( info, fadetime )
{
	if( "selist" in info )
	{
		foreach( cat in info.selist )
		{
			foreach( val in cat )
			{
				BSound.SE_Stop( { type=_SeType_Player, num=val, fadetime=fadetime } );
			}
		}
	}
}
Battle_Std.TypeSE_AllStop <- function(tbl) : (stop_se)
{
	local fade_frame = ("fadetime" in tbl)? tbl.fadetime : 0;
	if( "type" in tbl )
	{
		local info = Battle_Std.TypeSE_GetInfo( tbl.type );
		
		if( info ) //この種類のSeが定義されてた
		{
			if( typeof info=="array")
			{
				//PrioPickがあって有効なら、以降は抽選しない
				for(local i = 0; i < info.len(); i++)	
				{
					local ctbl = info[i];
					if( "PrioPick" in ctbl )
					{
						if( ctbl.PrioPick() )
						{
							stop_se( ctbl, fade_frame );
							break;
						}
					}
					else
					{
						stop_se( ctbl, fade_frame );
					}
				}
			}
			else
			{
				return stop_se( info, fade_frame )
			}
		}
	}
	return 0;
}

//前回再生したボイスとの番号が一致するか調べる
Battle_Std.InArrayLastPlaySound <- function( ar )
{
	local last_se_num = BMvTbl.GetPP(def_PP_LastPlaySound);
	foreach( val in ar )
	{
		if( val == last_se_num ) return 1;
	}
	return 0;
}

//通常投げのコマンドを入れると呼び出される
//必殺技のでかかりを投げ抜けコマンドにするのにも使う
//Battle_Std.CreateTechObject(0);
Battle_Std.CreateTechObject <- function(frame=0,gouin=0)
{
	//コマンドがきたら投げ抜け管理を生成する
	//def_PP_TechHit_FrameManager 0:未生成 1〜:投げ抜け入力から何フレームたったか（投げ抜け失敗フレームまで続く）
	if( BMvTbl.GetPP( def_PP_TechHit_FrameManager ) <=0 )
	{
		//投げ抜け管理を生成
		BMvTbl.SetPP( def_PP_TechHit_FrameManager, frame ); //投げ抜け時間セット
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_TechHit_FrameManager" } );
		//_dm("生まれる"+frame+" : "+gouin);
	}
	else if( gouin==1)
	{
		BMvTbl.SetPP( def_PP_TechHit_FrameManager, frame ); //投げ抜け時間更新
		//_dm("更新"+frame);
	}
	
	// 投げ抜けを仕込んだMvであることを記憶
	Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_TechOP );
}



//投げ抜けステータステーブルを取得
//投げコマンドを入力すると Mv_Obj_TechHit_FrameManager が生成されフレームを管理する
Battle_Std.GetTechStatus <- function( _log = 1 )
{
	local ret = {
		isDone = false, // 投げ抜けを入れていたら有効
		isTechOK = false, //投げ抜け成功フレーム中（投げ抜けできるはず）
		frameType = 0, // 0:先行投げ抜けしてない 1:投げ抜け猶予あり 2:投げ抜け失敗フレーム中　※デバッグ用
	};
	
	local techframe_man = BMvTbl.GetPP( def_PP_TechHit_FrameManager );
	
	// techframe_man:0 投げor投げ抜けを入れていないか、入力してから結構時間がたった
	// techframe_man:1〜 投げor投げ抜けを入力してから何フレーム経過したか
	// 投げ抜け不可能のとき、def_FL_Tech + 1 以上の値になっていることがある
	// 投げ抜け不可にするとき、無理やり def_FL_Tech + 1 以上になっているので、本当のスロウリジェクトミスかどうかは分からない
	
	// _dpn("techframe_man:"+techframe_man+" def_FL_TechMiss:"+def_FL_TechMiss);
	
	if( techframe_man == 0 ) // 先行投げ抜けすらしてない
	{
		if( Def_Dbg_TechHitLog && _log ) _dpn("先行投げ抜けすらしてない");
		ret.frameType = 0;
	}
	else if( techframe_man<def_FL_TechSenkou )	// 投げ抜け猶予が残ってる
	{
		if( Def_Dbg_TechHitLog && _log ) _dpn("投げ抜け猶予が残ってる");
		ret.isDone = true;
		ret.isTechOK = true;
		ret.frameType = 1;
	}
	else if( techframe_man<def_FL_TechMiss ) // 投げ抜け失敗フレーム中である
	{
		if( Def_Dbg_TechHitLog && _log ) _dpn("投げ抜け失敗フレーム中である:"+techframe_man);
		ret.isDone = true;
		ret.isTechOK = false;
		ret.frameType = 2;
	}
	else if( techframe_man > 0 ) // UNIclrまでと異なる
	{
		// なにか値がある
		ret.isDone = true;
		ret.isTechOK = false;
		ret.frameType = 2;
	}
	
	return ret;
}

//投げ抜け不能フレームまで進めつつ投げ抜け管理オブジェクトを生成する
//生成済みの場合はフレームをすすめるだけ（PPに値が入るだけ）
//投げ抜け失敗フレーム（リジェクトミス）を超えると失敗状態はクリアされるので注意
Battle_Std.CreateTechObject_TechMissStart <- function()
{
	Battle_Std.CreateTechObject( (def_FL_Tech+1), 1 );
}


//キャラ番号
//敵のキャラクターナンバーを取得
Battle_Std.GetEnemyCharaNo <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報
	if( enemy.push() )
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		enemy.pop();
		return mvs.CharaNo;
	}
	return -1; //取得できなかったら
}

//自分と相手のキャラクターナンバーを取得
Battle_Std.GetEachCharaNo <- function()
{
	local ret = { player=0, enemy=0 };
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		ret.player = BMvTbl.GetMvStatus().CharaNo;
		player.pop();
	}
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret.enemy = BMvTbl.GetMvStatus().CharaNo;
		enemy.pop();
	}
	return ret;
}

//操作親と敵のキャラナンバーが同じか(true/false)
Battle_Std.IsDoukyara <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報

	if( player.IsDone && enemy.IsDone )
	{
		BMvCore.PushCharaData( player ); //
			local p_s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //			

		BMvCore.PushCharaData( enemy ); //
			local e_s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //	
		
		return (p_s.CharaNo==e_s.CharaNo)
	}
	return false; //取得できなかったら違う扱い
}

//プレイヤーがＫＯ状態で寝ているか(true/false)
Battle_Std.PlayerisKO <- function()
{
	if( BMvTbl.GetMvRoundStatus().isMyKo )
	{
		return true;
	}
	return false;
	/*
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.IsDone )
	{
		BMvCore.PushCharaData( player ); //
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		BMvCore.PopCharaData(); //			
		
		if (rs.isMyKo)
		{
			//print("\n自分死んでるわ");
			return true;
		}
	}
	return false; //取得できなかったら生きてることにするｗ
	*/
}

//敵がＫＯ状態で寝ているか(true/false)
Battle_Std.EnemyisKO <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // プレイヤーの情報を得る
	if( enemy.push() )
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		enemy.pop();
		
		if( rs.isMyKo )
		{
			return true;
		}
	}
	return false;
}

//操作親と敵のどっちかKO済みか(true/false)
Battle_Std.CharaisKO <- function()
{
	// if(Battle_Std.PlayerisKO() || Battle_Std.EnemyisKO() ) // 重い
	if( BMvEff.IsKoFinishType() )
	{
		return true;
	}
	return false;	
}


// ＫＯ済みorタイムアップとかで決着がついて操作不能になった
Battle_Std.RoundisEnd <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.push() )
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得
		
		player.pop();
		
		if( rs.isKo ) return true;
	}
	return false;
}




//操作親がつかまれてるか(true/false)
Battle_Std.PlayerisCapture <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.IsDone )
	{
		BMvCore.PushCharaData( player ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //				
		
		return( bs.isCapture!=0 );
	}
	return false;
}

//攻撃が触れたときの共通関数
Battle_Std.AttackImpact_StdFunc <- function(info)
{
	// _dpn("[AttackImpact_StdFunc]");
	// info は BMvTbl::MvHitImpactInfo クラス
	//print( format( "\nAttackImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );

	//リベレート中だったらGRDが増加する
	if( Def_Sys_VeilOff_GRDPlus )
	{
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local ls = BMvEff.Liberate_Get();
			
			player.pop();

			//ダメージ時のみGRDをもりもり増やす
			if( info.type&_HitType_Damage  )
			{
				switch( ls )
				{
				case _SpGaugeMode_Liberate:
					Battle_Std.GRD_AddValue({ val=def_GRD_Liberate_AttackImpactInit, pressure=0, boundplus=1 });		
					break;
				case _SpGaugeMode_OverLiberate:
					Battle_Std.GRD_AddValue({ val=def_GRD_OverLiberate_AttackImpactInit, pressure=0, boundplus=1 });		
					break;
				}
			}
		}
	}
	
	Battle_Std.EnemyDamageFlag_Del( def_DF_MarkingBound );//触れるたびに相手の印を消す
	
	// この辺の処理と同じものがエンキドゥにもあるので注意
	local Guard = ((info.flags&_ImpactFlag_IsGuard)!=0);
	local OldYarare = (((info.flags&_ImpactFlag_IsBound_Old)!=0)&&!Guard); // 打撃初段はfalseだけど投げ初段はtrue
	local Yarare = (((info.flags&_ImpactFlag_IsBound)!=0)&&!Guard);
	local Capture = (((info.flags&_ImpactFlag_IsCapture)!=0 ) && !Guard ); // 捕まれ状態でここに入ってきたかどうか(捕まれ中の食らい)
	
	local Zenbu_Syodan = (!Yarare && !Capture);//Damageと異なり投げも含まれる
	local Nage = (info.atk_throw!=0); //投げ判定かどうか
	local Dage_Syodan = (Zenbu_Syodan && !Nage);//打撃の初段
	local Nage_Syodan = (Zenbu_Syodan && Nage);//投げの初段

	local GRDBreak = ( ( Zenbu_Syodan || Nage ) && info.grd_break!=0 && BMvEff.GRD_IsBreakImpact(1)==0 ); //攻撃を受けるか食らうかしてブレークになった	
	//local GRDBreak = (info.grd_break!=0); //攻撃を与えてブレイクさせた
	
	local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
	
	local isVorpal = ( BMvEff.GRD_GetJudgeResult() > 0 );
	
	local DagekiNage = (Nage && info.atk_throw&(1<<6)); // 打撃投げかどうか（判定の打撃のチェック）
	// _dpn("DagekiNage:"+DagekiNage+" Nage:"+Nage+" OldYarare:"+OldYarare+" Yarare:"+Yarare);
	// ScriptDlgProc.cpp 参照
	// _dpn("info.flags:"+info.flags);
	// _dpn("info.atk_throw:"+info.atk_throw);
	// _dpn("info._ThrowType_TypeBlow:"+_ThrowType_TypeBlow); // (1<<6)
	// コマ投げ:384
	// 214EXとか:256
	
	// _ImpactFlag_IsGuard:2
	// _ImpactFlag_IsBound_Old:256
	// _ImpactFlag_IsBound:1
	// _ImpactFlag_IsCapture:16
	// _ImpactFlag_IsSuperArmor:512
	
	// info.atk_throw:64 // 打撃投げのチェックっぽい
	// 128はカウンター
	
	// _dp("\n Syodan:"+Syodan+" Nage:"+Nage+" info.dmg:"+(info.type & _HitType_Damage) )
	
	
	// EX技を当てたときの保証補正用のフラグ立て
	// 普段はStartでフラグをたてているが、EXの設置技などでフラグがたたないのでここでも立てる
	if( info.type & _HitType_Damage )
	{
		local mva = BMvTbl.GetMvAction();
		local isExSkill = ( mva == def_MVA_EXSkill);
		local isSpSkill = ( mva == def_MVA_SPSkill);
		if( isExSkill && !isSpSkill && !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_NoSetUseExSkillFlag ) )
		{
			// _dpn("EX技をあてた");
			Battle_Std.EnemyDamageFlag_DelayAdd( def_DF_UseExSkill ); // EX技を使ったのを相手に記憶
		}
		if( isSpSkill )
		{
			// _dpn("IWをあてた");
			Battle_Std.EnemyDamageFlag_DelayAdd( def_DF_UseSpSkill ); // SP技を使ったのを相手に記憶
		}
	}

	//投げも入るよ
	if( Zenbu_Syodan )
	{
		//ガード時も入ってくるので注意
		BMvTbl.SetPP(def_PP_ComboConcentrationCounter,0); // コンボ中のコンセ時間をリセット
		
		if( isVorpal && info.type & _HitType_Damage )
		{
			_dpn("★★VPでコンボ始動★★")
			Battle_Std.EnemyDamageFlag_DelayAdd( def_DF_Vorpaled );
		}
		// アサルト攻撃はヒット時の補正を色々つける
		// 処理を相手側に移動（何が殴ったかの取得がいい加減だったから、でもこっちでもいいんじゃ…）
		/*
		if( (airatk_st&def_PP_AAS_inAssault) ) // アサルトから出したジャンプ攻撃…を経由した何かなら通る
		{
			if( GRDBreak ) // ブレイクさせた攻撃
			{
				// 無補正
			}
			else if( info.counterhit ) // カウンターヒットした攻撃
			{
				// 無補正
			}
			else // それ以外
			{
				// _dp("\n アサルトによる補正");
				Battle_Std.ComboPoint_Multi( def_CPH_AssaultHit ); // コンボポイントを乗算
				BMvEff.ComboView_Set( { val=def_HOSEI_AssaultHit, type=1 } ); // 補正を乗算
			}
		}
		*/
		// カウンターヒットしたら
		if( info.counterhit )
		{
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CounterHit ); // カウンターヒット記録
			
			local lowbreak = Battle_Std.MoveCode.CheckFlag( def_MC_GRDLowBreak );
			if( lowbreak )
			{
				_dpn("ローカウンター");
				// Battle_Std.ComboPoint_Multi( def_CPH_LowCounterHit ); // コンボポイントを乗算
			}
			else
			{
				Battle_Std.ComboPoint_Multi( def_CPH_CounterHit ); // コンボポイントを乗算
			}
			
			// _dp("\n カウンターヒット回数加算");
			// tDDC.Jem_AddCount( _JemCheckType_Ex + 4 ); // カウンターヒット回数加算
		}
		
		// 投げ判定ではない打撃判定が、つかみ中の相手にヒットした場合は始動ではない
		// つかみ中の相手＝すでにつかみで始動になっているはずなので…

		// 投げヒット後の打撃判定かどうか
		local nageHitDageki = ( !Nage && Battle_Std.CheckEnemyisCapture() );
		if( info.type & _HitType_Damage && !nageHitDageki )
		{
			_dp("\n 始動でヒットした");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
			
			//始動時に入ってくる処理
			//無敵技始動は保証がキツくなる
			//０ヒットの判定だと処理されない問題があるので、フラグだけ立てておいてMVを抜けるときに設定するようにする
			local mycore = BMvCore.GetMyCharaData();
			local is_set_muteki_hosei = 0;
			if( Def_Sys_MutekiHosyouHosei && Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki ) )
			{
				// _dpn("無敵技の始動っぽい");
				if( Def_Sys_ChangeMutekiHosyoTiming && Battle_Std.MoveCodeEx.CheckFlag( 0, def_MC_Skill ) && mycore.isPlayer() )
				{
					// 必殺技なら自動生成されているので、MVのLastUpdateに処理を回す
					_dpn("保証補正の処理をLastUpdateに回す");
					Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_DelayMutekiSidouHosei );
				}
				else
				{
					Battle_Std.SetSpHosyoHosei( { type="Muteki", checkPPFlag=1 } );
					Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_MutekiSidou );
					is_set_muteki_hosei = 1;
				}
			}			
			
			local enemy_is_in_active = Battle_Std.EnemyGS_CheckFlag( def_PP_GS_KeepInActive );
			if( enemy_is_in_active )
			{
				// _dpn("相手、硬直中");
				Battle_Std.SetSpecialEXSLimit_Enemy( def_SP_CSCheat_EXSLimitVal );
			}
			
			// 孫まで見る（無限は怖いので、かつ軽くしたいので適当でいいよ）
			local oya = BMvCore.GetParentCharaData();
			if( oya.isdone() )
			{
				_dp("\n 親がいるので飛び道具とかのヒット");
				
				if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player  } ) != 0 )
				{
					local player = BMvCore.GetPlayerCharaData();
					if( player.push() )
					{
						_dp("\n プレイヤーが自分自身発生させた行動中");
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
						if( is_set_muteki_hosei )
						{
							Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_MutekiSidou );
						}						
						
						player.pop();
					}
				}
				else if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
				{
					if( oya.push() )
					{
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
						if( is_set_muteki_hosei )
						{
							Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_MutekiSidou );
						}						
						
						if( !oya.isPlayer() )
						{
							local sofubo = BMvCore.GetParentCharaData();
							if( sofubo.isdone() )
							{
								_dp("\n さらに親がいるので飛び道具とかのヒット");
								
								if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
								{
									if( sofubo.push() )
									{
										Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
										if( is_set_muteki_hosei )
										{
											Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_MutekiSidou );
										}
										
										sofubo.pop();
									}
								}
							}
						}
						oya.pop();
					}
				}
			}
		}
	}
	
	if( GRDBreak )
	{
		Battle_Std.GRDBreak_Attack( { Nage=Nage } );
	}	
	
	
	// デバッグ用処理
	if( Def_Dbg_LocalDebugScriptPath )
	{
		Battle_Std.DebugFunc.CallAttackImpactScript( info );
	}
	
	if( _DevWindows )
	{
		local isMyStopTime = BMvEff.IsMyStopTime();
		if( isMyStopTime )
		{
			local mess = "★★★時間停止中に攻撃がヒットしています！★★★";
			debugfontL.draw_message( mess );
			_dpn(mess);
		}
	}
}

//攻撃に触れられたときの共通関数
Battle_Std.DamageImpact_StdFunc <- function(info)
{
	// _dpn("[DamageImpact_StdFunc]");
	/*
	(1<<0) 1 立ちガード可能 
	(1<<1) 2 空中ガード可能　※しゃがみガード可能になってたけど逆だったｗ
	(1<<2) 4 しゃがみガード可能
	(1<<8) 256 立ちに空振り
	(1<<9) 512 空中に空振り
	(1<<10) 1024 しゃがみに空振り
	(1<<11) 2048 のけぞりに空振り
	(1<<12) 4096 ガードのけぞりに空振り

	*/
	
	//当たった攻撃のガード属性
	local StdGuard = ((info.atk_guard&(1<<0))!=0);
	local AirGuard = ((info.atk_guard&(1<<1))!=0);
	local CroGuard = ((info.atk_guard&(1<<2))!=0);

	local Zyodan = (StdGuard&&CroGuard);
	local Tyudan = (StdGuard&&!CroGuard);
	local Gedan = (!StdGuard&&CroGuard);
	local KugaFunou = (!AirGuard);
	local GroundGuardFunou = (!StdGuard && !CroGuard); // 地上ガード不能
	
	//やられ側状態
	local PosisCro = (info.d_state==2);
	local PosisAir = (info.d_state==1);
	local PosisStd = (!PosisCro&&!PosisAir);
	
	local StdGuardInput = (info.def_guard==1);
	local CroGuardInput = (info.def_guard==2);
	local AirGuardInput = (info.def_guard==3);
	local GroGuardInput = ( StdGuardInput || CroGuardInput );
	
	local Nage = (info.atk_throw!=0); //投げ判定かどうか
	
	local Guard = ((info.flags&_ImpactFlag_IsGuard)!=0);
	local Yarare = (((info.flags&_ImpactFlag_IsBound_Old)!=0)&&!Guard); // XXX:古い処理なので直すこと　打撃初段はfalseだけど投げ初段はtrue
	local NewYarare = (((info.flags&_ImpactFlag_IsBound)!=0)&&!Guard); // やられ状態か。投げ初段はfalse、つかみ中のヒットもfalseなのが違い。
	local Capture = (((info.flags&_ImpactFlag_IsCapture)!=0 ) && !Guard ); // 捕まれ状態でここに入ってきたかどうか(捕まれ中の食らい)

	local DagekiNage = (Nage && !Yarare); // 打撃投げかどううか
	local DagekiNageNew = (Nage && info.atk_throw&(1<<6)); // 打撃投げかどうか（判定の打撃のチェック）

	// info.flags&_ImpactFlag_IsSuperArmor : アーマー状態で殴られると入る。（ArmorBreakの投げ技を食らった時だけ消滅している）
	// info.armor_break : アーマーブレイク属性のある技。投げはアーマーを掴むけど、アーマーブレイク属性がないものもある。
	// local Armor = (((info.flags&_ImpactFlag_IsSuperArmor)!=0 ) && ( info.armor_break != 0 )&& !Guard && (!Nage || DagekiNage) && !Yarare );//アーマーで耐えている（投げも食らってないしガードもしてない。打撃投げは投げじゃない判定で除外。）
	local Armor = (((info.flags&_ImpactFlag_IsSuperArmor)!=0 ) && !info.armor_break && !Guard && (!Nage || DagekiNage) && !Yarare );//アーマーで耐えている（投げも食らってないしガードもしてない。打撃投げは投げじゃない判定で除外。）
	local ArmorBreak = ((info.armor_break) || ( info.flags&_ImpactFlag_IsSuperArmor)!=0 && Nage && !DagekiNage ); // アーマーブレイクorアーマー状態を投げで掴んだ。打撃投げは掴まないので除外する。
	
	// アーマー系はシチュエーションが多い
	// アーマー状態を殴ったら info.flags&_ImpactFlag_IsSuperArmor 
	// 攻撃側：打撃、打撃投げ、投げ

	//Syodan系はヒットorガード
	local Dage_Syodan = (!Capture && !Yarare); // 打撃の初段。　
	local Nage_Syodan = (!Capture && Nage && !NewYarare); // 投げ初段 ※NewYarareで打撃の初段のあと、コンボ中に投げた場合を除外
	
	local Zenbu_Syodan = (Dage_Syodan || Nage_Syodan); // 打撃でも投げでも　
	
	local SyodanGuard = (!Guard);

	local GRDBreak = ( ( Dage_Syodan || Nage ) && info.grd_break!=0 && BMvEff.GRD_IsBreakImpact(0)==0 ); //攻撃を受けるか食らうかしてブレークになった
	
	// _dpn("flag:"+(info.flags&_ImpactFlag_IsSuperArmor)+" Guard:"+Guard+" Nage:"+Nage+" NewYarare:"+NewYarare+" Yarare:"+Yarare+" Capture:"+Capture+" Armor:"+Armor+" DagekiNage:"+DagekiNage+" BMvTbl.GetSuperArmorFlag():"+BMvTbl.GetSuperArmorFlag()+" ArmorBreak:"+ArmorBreak );

	//_dp("\n info.flags:"+info.flags+" _ImpactFlag_IsCapture:"+_ImpactFlag_IsCapture+" _ImpactFlag_IsBound_Old:"+_ImpactFlag_IsBound_Old );
	// _dp("\n Syodan:"+Syodan+" Nage_Syodan:"+Nage_Syodan+" Zenbu_Syodan:"+Zenbu_Syodan+" Capture:"+Capture+" Nage:"+Nage );
	
	// _dpn("Zenbu_Syodan:"+Zenbu_Syodan+" Dage_Syodan:"+Dage_Syodan+" Nage_Syodan:"+Nage_Syodan+" Capture:"+Capture);

	local pos;
	local vec;
	
	local movable = BCMDTbl.CheckCancel( _SkillType_None );

	local enemyAtk_is_FastRocketeer = false; //早い発生のジャンプ攻撃によるロケッティアであるかどうか
	
	local overhead_frame = 0; // 中段のときのフレーム（GRD増加量に影響）

	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報
	if( enemy.push() )
	{
		local emvs = BMvTbl.GetMvStatus(); //MvCount取得用
		pos = BMvTbl.GetPosition(); // 位置取得
		vec = BMvTbl.GetVector(); //ベクトル取得
		local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
		//アサルトからは除外
		enemyAtk_is_FastRocketeer = ( ( ( airatk_st&def_PP_AAS_Rocketeer )!=0 ) && ( (airatk_st&def_PP_AAS_inAssault) ==0 ) && emvs.MvCount<21 );
		//print("\n enemyAtk_is_rocketeer:"+enemyAtk_is_rocketeer);
		
		//中段Fを測定しておいてGRD増加量を調整
		if( Tyudan )
		{
			local mess = "中段F:";
			local display_overhead_frame = emvs.MvCount; // 計算用の値
			if( Battle_Std.MoveCode.CheckFlag( def_MC_EnableAirAtkStatus ) )
			{
				local emvsbf = BMvTbl.GetMvStatusBF();
				display_overhead_frame = (emvs.MvCount + emvsbf.MvCount)-1;
				if( airatk_st&def_PP_AAS_inAssault )
				{
					mess = "アサルト中段F:";
					overhead_frame = display_overhead_frame;
				}
				else if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_Jump ) )
				{
					mess = "ジャンプ攻撃中段F:";
					overhead_frame = display_overhead_frame;
				}
				else
				{
					mess = "特殊中段F:";
					// この中段は測定しない
				}
			}
			else
			{
				
			}
			_dpn(mess+display_overhead_frame); // 以降F含まない アサルトのときはアサルト中段のF
		}
		
		enemy.pop();
	}
	else
	{
		pos = BMvTbl.CCharaPosition();
		vec = BMvTbl.CCharaVector();
	}
	
	// 金投げのコマ投げはここに来る前に分岐がある
	local TechAbleNageMv = 0; //投げ抜けが可能な投げ技かどうか
	if( Nage )
	{
		local atk_enemy_oya = BMvCore.GetLastDamageCharaData( 1 ); // そのままを取得（1だと一番上の親）
		if( atk_enemy_oya.push() )
		{
			TechAbleNageMv = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_TechCheck );//投げ抜けされる技(地上投げ、空中投げ)を食らった

			atk_enemy_oya.pop();
		}
	}
	// _dpn("TechAbleNageMv:"+TechAbleNageMv);
	
	// リジェクトミスフレーム中 or 投げ抜け不能に強制的にされている状態
	local TechHit_NoTechFrame = ( Battle_Std.GetTechStatus(0).frameType == 2 );

	//ガードができる状況か
	//行動可能orガード中？
	local GuardInputAble = (Guard || BCMDTbl.CheckCancel(_SkillType_None) );
	
	//地上状態で　相手が初段での中段攻撃で空中にいて上昇中or発生早いロケッティアなら(Ver.1.03予定だったもの)
	//local NoboriTyudan = ( Dage_Syodan&& BCMDTbl.CheckPosState( _PosState_Ground ) && Tyudan && pos.y<0 && ( vec.y<0 || enemyAtk_is_FastRocketeer ) );
	
	//地上状態で　相手が初段での中段攻撃で空中にいて上昇中なら(Ver.1.01、1.02)
	local NoboriTyudan = ( Dage_Syodan&& BCMDTbl.CheckPosState( _PosState_Ground ) && Tyudan && pos.y<0 && vec.y<0 );

	//のぼり中段初段をしゃがみガードしていた（食らった）
	local NoboriTyudanHit = ( CroGuardInput && NoboriTyudan );
	
	//切り替え中段（Ｆ式）ガードモーション中しゃがみガード入力中に上り中段がきたら
	//local Fsiki = ( NoboriTyudan && Guard && BCMDTbl.CheckPosState(_PosState_Crouch) ); //
		
	//_dm("Flags:"+info.flags+" "+_ImpactFlag_IsBound+" "+_ImpactFlag_IsGuard+" Yarare:"+Yarare+" Guard:"+Guard );

	if( info.type&_HitType_Guard )
	{	
		local add_breaktime = def_CBT_Guard;
		
		if( Tyudan && PosisStd ) //中段をガードした
		{
			//_dm("中段ガードおめでとう");
			Battle_Std.TypeSE_Play({ type="中段ガード成功" });
			Battle_Std.CharaBattleActivity_Increment(60,"中段ガード");
			
			local grd_addval = 0;

			if( NoboriTyudan )
			{
				//相手に色々メリットを与えてもいい気がする
				//初段チェックはしない（切り替え中段だと初段にならないので）
				// Battle_Std.DrawDebugAttackInfo("! NoboriTyudan Guard");
				grd_addval = def_GRD_NiceGuard_NoboriTyudan;
				add_breaktime = def_CBT_NoboriTyudanGuard;				
			}
			else
			{
				// Battle_Std.DrawDebugAttackInfo("! Tyudan Guard");
				if( SyodanGuard )
				{
					grd_addval = def_GRD_NiceGuard_TyudanSyodan;
					add_breaktime = def_CBT_TyudanGuardSyodan;
				}
				else
				{
					grd_addval = def_GRD_NiceGuard_Tyudan;
					add_breaktime = def_CBT_TyudanGuard;
				}
			}
			
			// 中段なら一律でGRDが増加していたが、発生の遅いアサルト中段で触れるメリットが低いため増加量を調整する
			// 22F〜34Fぐらいで、34Fのときはほぼ増加しない
			if( Def_Sys_ChangeGRDAddValue_OverheadFrame && overhead_frame )
			{
				local use_frame = overhead_frame;
				local min = 23;//23
				local max = 33;//33

				if( use_frame < min ) use_frame = min;
				if( use_frame > max ) use_frame = max;
				local par = 100 - (use_frame - min)*100/(max-min);
				if( par <   0 ) par =   0;
				if( par > 100 ) par = 100;
				
				local calc_grd_addval = grd_addval * par / 100;
				_dpn("GRD増加量をフレームで調整:"+use_frame+"("+par+"%) : "+grd_addval+" -> "+calc_grd_addval);
				grd_addval = calc_grd_addval;
			}
			
			//GRD増加処理
			if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
			{
				Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });
			}
		}
		if( Gedan && PosisCro ) //下段をガードした
		{
			//_dm("下段ガードおめでとう");
			local grd_addval = 0;
			Battle_Std.CharaBattleActivity_Increment(55,"下段ガード");
			if( SyodanGuard ) //初段のとき
			{
				//print("\n初段")
				grd_addval = def_GRD_NiceGuard_GedanSyodan;
				add_breaktime = def_CBT_GedanGuardSyodan;
			}
			else
			{
				grd_addval = def_GRD_NiceGuard_Gedan;
				add_breaktime = def_CBT_GedanGuard;
			}
			
			if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
			{
				Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });			
			}
		}
		if( !KugaFunou && PosisAir )
		{
			Battle_Std.CharaBattleActivity_Increment(65,"空中ガード");
		}
		
		
		if( Def_Sys_GRDIncreaseAnyCancelSkill )
		{
			//キャンセル色々できる必殺技をガードしたらさらにボーナスがある
			local atk_enemy = BMvCore.GetLastDamageCharaData( 0 ); // そのままを取得（1だと一番上の親）
			// 1を使えるようにするためには、攻撃系のオブジェクトに関しては親の引き継ぎを一切しないようにする必要がある？
			//（1で取得後、isPlayerなら親、そうじゃなけりゃ親あらずになる…？）
			
			if( atk_enemy.push() )
			{
				local mva = BMvTbl.GetMvAction();
				local isSkill = (mva == def_MVA_Skill);// EX・SPはゲージ使ってるし除外 || mva == def_MVA_EXSkill || mva == def_MVA_SPSkill );
				local isCanselToAnyMove = 0;//なんかにキャンセルできる行動か（EXキャンセル除く）
				local isAlreadyChanged = 0; // 既に別の行動に移っているオブジェクトの攻撃
				
				local targetCoreIsPlayer = 0;
				if( atk_enemy.isPlayer() || BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
				{
					targetCoreIsPlayer = 1;
				}
				else
				{
					if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )//孫処理
					{
						local oya = BMvCore.GetParentCharaData();
						if( oya.push() )
						{
							if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )//孫
							{
								local oya2 = BMvCore.GetParentCharaData();
								if( oya2.push() )
								{
									if( oya2.isPlayer() ) targetCoreIsPlayer = 1;
									
									oya2.pop();
								}
							}
							oya.pop();
						}
					}
					if( !targetCoreIsPlayer )
					{
						//プレイヤーじゃなくてオブジェクト側につくのでちょっと処理が違う
						if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_AnyCancelGRD ) )
						{
							//まだGRD増加処理をやっていないっぽい
							Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AnyCancelGRD );//増加済みフラグをたてる
							
							isAlreadyChanged = 1; //既に違う行動っぽい
							isCanselToAnyMove = 100; // 適当に
						}
					}
				}
				
				// _dpn("要チェック:"+atk_enemy.isPlayer()+" targetCoreIsPlayer:"+targetCoreIsPlayer );
				if( targetCoreIsPlayer )
				{
					// 親が自分自身発生させた行動中。
					local player = BMvCore.GetPlayerCharaData();
					if( player.push() )
					{
						if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_AnyCancelGRD ) )
						{
							//まだGRD増加処理をやっていないっぽい
							Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AnyCancelGRD );//増加済みフラグをたてる
							
							if( Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoSkill|def_MC_EnableCansel_SkilltoAtk ) )
							{
								isCanselToAnyMove = 150;
							}
							else if( Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_EnableCansel_JumpMoveable ) )
							{
								isCanselToAnyMove = 150;
							}
							else if( Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_EnableCansel_AddCommand ) )
							{
								isCanselToAnyMove = 100;
							}
							//Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
						}
						player.pop();
					}
				}
				
				atk_enemy.pop();
				
				if( isSkill && isCanselToAnyMove )
				{
					local grd_addval = 0;
					if( SyodanGuard ) //初段のとき
					{
						//print("\n初段")
						grd_addval = def_GRD_NiceGuard_AnyCancelSyodan * isCanselToAnyMove/100;
						add_breaktime = def_CBT_AnyCancelSyodan * isCanselToAnyMove/100;
					}
					else if ( isAlreadyChanged )
					{
						//行動が変わっている系のやつだと何度も処理をしてしまうので初段以外は処理をしない
						//ヒルダ214など
					}
					else
					{
						grd_addval = def_GRD_NiceGuard_AnyCancel * isCanselToAnyMove/100;
						add_breaktime = def_CBT_AnyCancel * isCanselToAnyMove/100;
					}
					
					// _dpn("isSkill:"+isSkill+" isCanselToAnyMove:"+isCanselToAnyMove );
					if( grd_addval )
					{
						_dpn("★★★  isCanselToAnyMove:"+isCanselToAnyMove+" isAlreadyChanged:"+isAlreadyChanged );
					}
					
					if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
					{
						Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });			
					}
				}
			}
		}
			
		if( BMvEff.GRD_GetBreak( 0 )!=0 ) //ブレイク時
		{
			BMvEff.GRD_CorrectBreakTime( 0, add_breaktime ); //割合減少
		}
		
		//Battle_Std.TypeSE_Play({ type="ガード" });		
	}
	else if( info.type&_HitType_Damage )
	{
		// アーマー時も入ってくるので注意
		//■被弾時
	
		//つかまれ時は入ってこない　→　入ってくる！
		//投げ成立の時点でやられ状態になるのでSyodanにはならない
		//Nage_Shodanで検知できるが、通常投げの投げ抜け待機時も入るのであえて処理はしないでおく
		
		//ダメージを受けたらブレイク時間を割合で減算(廃止)
		
		if( Zenbu_Syodan && !Armor )
		{
			//Syodan系は初段時のみだが、飛び道具などが同時にあたると、複数のオブジェクトでSyodanになる
			// _dp("\n 初段");
			Battle_Std.PlayerSE_StopLastPlaySound( 0 ); //直前に再生した音声を停止
			
			// XXX:CLRと同じ動作にするための暫定処理
			// 投げ抜け可能な投げを食らってもGRDが減ってしまうのでこうした
			// 投げ成立後に再度GRDを増やす処理を入れないといけないので、色々重たいため、投げ判定の場合は一律で減らさないように
			// _dpn("DagekiNageNew:"+DagekiNageNew);
			// 打撃投げはGRDを減らすように修正。コマンド投げは減らない。
			if( Dage_Syodan || DagekiNageNew )
			{
				//やられ初段によるＧＲＤ減少
				Battle_Std.GRD_AddValue({ val=def_GRD_DamageSyodan, pressure=0, boundplus=1 });
			}
			
			//カウンター発生とパニッシュのアナウンスや演出
			if( info.counterhit!=0 )
			{
				local counter = 1;
				
				//カウンター状態を攻撃したけど、例外的にカウンターにしないケース
				if( TechAbleNageMv && Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnableTech ) )
				{
					counter = 0;
				}
				
				if( counter )
				{
					Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光
					
					// 攻撃のスカりにあてたらしたらしばらく投げ抜けできなくなったりしておかしい
					// Battle_Std.CreateTechObject_TechMissStart(); //投げ抜け失敗状態から投げ抜け管理オブジェクトを生成
					
					//打撃の相打ちとかで投げ抜け不能になるのはおかしいので、投げ抜け可能な投げ技食らった時だけ投げ抜け不可を入れる
					if( TechAbleNageMv )
					{
						local atk_enemy = BMvCore.GetLastDamageCharaData( 1 ); // そのままを取得（1だと一番上の親）
						if( atk_enemy.push() )
						{
							Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnemyTechImpossible );//相手は投げ抜け不可だ
							
							atk_enemy.pop();
						}
					}
					
					Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_Counter);

					Battle_Std.EnemyCharaBattleActivity_Increment(50,"カウンターヒット");
					Battle_Std.CharaBattleActivity_Increment(51,"被カウンターヒット");
				}
			}
			else if( BMvTbl.GetMvName() == "Mv_Throw_F" && Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnableTech ) )
			{
				// 投げのでかかりで被弾したとき、投げ抜け可能なことがある
				// 投げのでかかりに被カウンターを付けると、投げ抜けしてもカウンター表示が出ることがある
				// などを対策するため、投げのでかかりには被カウンターがないが、カウンターっぽい表示を予約する処理だけをする
				// カウンターではないがパニッシュでもない、という状態
			
				if( TechAbleNageMv ) // 攻撃側も通常投げだった場合は実質投げ抜けになるので何もしない
				{
					//↑の条件にTechAbleNageMvを入れると、投げのでかかりを打撃で潰すとpunishに入ってしまう
				}
				else if( Dage_Syodan )
				{
					_dpn("ここの被弾がパニッシュではおかしいのでカウンターにする");
					Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_NoCounterCounter); // パニッシュは出さないで小さいカウンター表記のみ出す
					
					// 以下は疑似カウンター処理だが、カウンター時のヒットストップ加算がないので混乱する
					/*
					local atk_enemy = BMvCore.GetLastDamageCharaData( 1 );
					if( atk_enemy.push() )
					{
						BMvEff.SetCounterAnnounce(); // 攻撃側から呼ぶこと
						
						Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CounterHit ); // カウンターヒット記録
						Battle_Std.ComboPoint_Multi( def_CPH_CounterHit ); // コンボポイントを乗算
				
						atk_enemy.pop();
					}
					Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光
					
					Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_Counter);

					Battle_Std.EnemyCharaBattleActivity_Increment(50,"カウンターヒット");
					Battle_Std.CharaBattleActivity_Increment(51,"被カウンターヒット");
					
					// 見た目をそれっぽくする処理なので厳密にはおかしいが、ほとんど気にならないはず
					local eff = BMvEff.CreateObject( { datatype=1, start_pat="Eff_Hit_Counter", x=0, y=-150*128 } ); // 座標決め打ち
					if( eff.push() )
					{
						BMvTbl.SetMuki( _Direction_Reverse ); // 本当は相手から呼ぶものなので反転
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
						eff.pop();
					}
					*/
				}
			}
			else if( info.counterhittmp ) // カウンターおよび「カウンターヒットしない」でのカウンター
			{
				Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_NoCounterCounter);
			}
			else if( !GuardInputAble )
			{
				local punish = 1;//確定かどうか（アナウンスを出すかどうかは別）
				
				//確定なんだけど、投げで投げ抜け可能な行動中の場合は非確定
				if( TechAbleNageMv && Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnableTech ) )
				{
					punish = 0;
				}
				
				//硬直中を攻撃した
				//カウンター時は入らないので注意
				if( punish )
				{
					// 攻撃のスカりにあてたらしたらしばらく投げ抜けできなくなったりしておかしい
					// Battle_Std.CreateTechObject_TechMissStart(); //投げ抜け失敗状態から投げ抜け管理オブジェクトを生成
					
					//打撃の相打ちとかで投げ抜け不能になるのはおかしいので、投げ抜け可能な投げ技食らった時だけ投げ抜け不可を入れる
					if( TechAbleNageMv )
					{
						local atk_enemy = BMvCore.GetLastDamageCharaData( 1 ); // そのままを取得（1だと一番上の親）
						if( atk_enemy.push() )
						{
							Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnemyTechImpossible );//相手は投げ抜け不可だ
							
							atk_enemy.pop();
						}
					}
					
					//パニッシュを出して良いMvなのかをチェック
					if(	Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_EnablePanishAnnounce ) ) //パニッシュが出る行動
					{
						Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_Punish );
						
						//飛び道具とかのときちょっと変だけど
						local atk_enemy = BMvCore.GetLastDamageCharaData( 1 );
						if( atk_enemy.push() )
						{
							Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_PunishHit );
							atk_enemy.pop();
						}
					}
				}
			}
			
			if( Tyudan && CroGuardInput && GuardInputAble ) //中段を食らった
			{
				//屈状態だったら警告(ガードを入れてるかの方がいいかも)
				//初段かどうか取得？しないとコンボ中がギャグ
				//_dm("それ屈ガードできませんから");
				// Battle_Std.DrawDebugAttackInfo("! Tyudan");
				
				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.CharaBattleActivity_Increment(61,"中段ガードミス");
				Battle_Std.CharaBattleActivity_Calc( {
					title="中段ガードミス確率", 
					molecule=Battle_Std.CharaBattleActivity_Count("中段ガードミス"), denominator=(Battle_Std.CharaBattleActivity_Count("中段ガード")+Battle_Std.CharaBattleActivity_Count("中段ガードミス"))
				} );
				
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
			}
			else if( Gedan && StdGuardInput && GuardInputAble ) //下段を食らった
			{
				//立状態だったら警告
				//_dm("それ立ちガードできませんから");
				// Battle_Std.DrawDebugAttackInfo("! Gedan");

				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.CharaBattleActivity_Increment(56,"下段ガードミス");
				Battle_Std.CharaBattleActivity_Calc( {
					title="下段ガードミス確率", 
					molecule=Battle_Std.CharaBattleActivity_Count("下段ガードミス"), denominator=(Battle_Std.CharaBattleActivity_Count("下段ガード")+Battle_Std.CharaBattleActivity_Count("下段ガードミス"))
				} );
				
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
			}
			else if( KugaFunou && AirGuardInput && GuardInputAble ) //空ガ不能を食らった
			{
				//空中で空中ガード不能技を食らった
				//_dm("それ空中ガードできませんから");
				//Battle_Std.DrawDebugAttackInfo("! KugaFunou");

				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.CharaBattleActivity_Increment(66,"空中ガードミス");
				Battle_Std.CharaBattleActivity_Calc( {
					title="空中ガードミス確率", 
					molecule=Battle_Std.CharaBattleActivity_Count("空中ガードミス"), denominator=(Battle_Std.CharaBattleActivity_Count("空中ガード")+Battle_Std.CharaBattleActivity_Count("空中ガードミス"))
				} );				
				
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
			}
			
			//リジェクトミスは↓で設定
			//この処理があるのでUNIclrまでと異なっていて、リジェクトミスが起きやすい
			if( Nage_Syodan && TechAbleNageMv )
			{
				//投げヒット時の処理
				//投げでカウンターをとった　＝　スローカウンター
				//投げでリジェミスを掴んだ　＝　スローカウンター
				//投げで硬直を掴んだ　　　　＝　普通のヒット
				
				// _dpn("投げ抜け可能な技");
				
				//リジェクトミスか投げ抜け不能状態で投げを食らったとき
				//リジェクトミスかどうかの検知は、現状だとかなり難しいのでやらないこと
				if( TechHit_NoTechFrame )
				{
					Battle_Std.TypeSE_Play({ type="ガード失敗" });
					Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
					
					Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光(カウンターではないけど)
					Battle_Std.CreateTechObject_TechMissStart(); //投げ抜け失敗状態から投げ抜け管理オブジェクトを生成
					
					//打撃の相打ちとかで投げ抜け不能になるのはおかしいので、投げ抜け可能な投げ技食らった時だけ投げ抜け不可を入れる
					if( TechAbleNageMv )
					{
						local atk_enemy = BMvCore.GetLastDamageCharaData( 1 ); // そのままを取得（1だと一番上のの親）
						if( atk_enemy.push() )
						{
							Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnemyTechImpossible );//相手は投げ抜け不可だ
							
							atk_enemy.pop();
						}
					}
				}
			}
			
			if( Def_Sys_AnnounceAtemiFailed )
			{
				if( BMvTbl.IsExistAtkCatchRect() && BMvTbl.GetAtkCatchIsDone() && !Nage )
				{
					// Nageを含めると、3Dでかかりの投げのときだけ表示されてしまうので注意
					_dpn("当身中の被弾!（投げ以外）");
					Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_BarrierBreached );
				}
			}
		}
		//高速中段用補正
		//・しゃがみガード入力中だった
		//・中段を食らった
		//・相手は空中状態だ
		//・相手に↑ベクトルがかかってる or ロケッティアフラグがある
		//×相手の座標が一定以下（これはいらない）
		//・初段だ
		
		// 殴ってきた相手の技を見て色々補正をかける
		// Dage_Syodanは投げの初段は入ってこないよ
		if( Dage_Syodan )
		{
			local atk_enemy = BMvCore.GetLastDamageCharaData( 0 ); // そのままを取得（1だと一番上の親）
			if( atk_enemy.push() )
			{
				// 通常攻撃かどうか取得
				local normal_atk = Battle_Std.MoveCode.CheckFlag( def_MC_Atk );
				local exdmg_hosei =  Battle_Std.MoveCode.CheckFlag( def_MC_ExDamageHosei );
				local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
				local enable_airatkst = Battle_Std.MoveCode.CheckFlag( def_MC_EnableAirAtkStatus ); // def_PP_AirAtkStatusが有効なMvかチェック
				local fromAssault = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_FromAssault );
				
				//カウンターヒット時は無補正
				//exdmg_hoseiの処理が変わるので共通でOK
				if( exdmg_hosei )
				{
					// 特殊な補正がかかるMvによる攻撃でした
					_dp("\n 多段中段補正適用:"+def_HOSEI_ExDamageHosei);
					BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_ExDamageHosei,0,0,0,0, 0,0,0,0,0, 0,0 ]} );
				}
				else if( normal_atk && enable_airatkst && (airatk_st&def_PP_AAS_inAssault) ) // airatk_stはアサルトから出したジャンプ攻撃で。フラグはジャンプ攻撃（！）の着地で消える。
				{
					_dp("\n アサルト補正適用");
					if( GRDBreak ) // ブレイクさせた攻撃
					{
						// 無補正
					}
					else if( info.counterhit ) // カウンターヒットした攻撃
					{
						// 無補正
					}
					else // それ以外
					{
						// _dp("\n アサルト補正適用");
						Battle_Std.ComboPoint_Multi( def_CPH_AssaultHit ); // コンボポイントを乗算
						BMvEff.ComboView_Set( { val=def_HOSEI_AssaultHit, type=1 } ); // 補正を乗算
					}
				}
				
				atk_enemy.pop();
			}
		}
		
		if( Zenbu_Syodan )
		{
			// こっちはNage_Shodanも含めて補正をかけるが、ボーナスとか入れちゃダメなので注意
			local atk_enemy = BMvCore.GetLastDamageCharaData( 1 ); // そのままを取得（1だと一番上のの親）
			if( atk_enemy.push() )
			{
				
				// 距離補正テスト
				// ある程度距離が遠い状態ではコンボレートに乗算補正がかかる
				if( 1 )
				{
					if( GRDBreak )
					{
					}
					else if( info.counterhit ) // カウンターヒットした攻撃
					{
					}
					else if( movable == 0 ) // 行動不能をつっついた攻撃
					{
						// 通常技の隙や必殺技の隙だけどカウンターではない時
						// バクステの硬直とか
						// アサルトの移動中とか
						// バティスタ関係
					}
					else
					{
						local kyori = Battle_Std.GetEnemyDistance() / 128;
						
						local xmin = 350;
						local xmax = 600; // 800
						local hmin = 100;
						local hmax = 92; // 85
						
						// _dp("\n 距離チェック:"+kyori )
						if( kyori >= xmin )
						{
							local sa = kyori - xmin; // 
							local val = hmin - ( sa * (hmin - hmax) / (xmax - xmin) );
							if( val < hmax ) val = hmax;
							
							// _dp("\n\n ★距離補正:"+val+"% ★\n" );
							// BMvEff.ComboView_Set( { val=val, type=1 } ); // 乗算で補正がかかる
							BMvTbl.SetComboRateValue( val ); // コンボレートに補正をかける
						}
					}
				}			
			
				atk_enemy.pop();
			}
		}
		
	}

	//アーマーによる発光
	if( Armor )
	{
		Battle_Std.SetCharaFlash_Armor();
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_ArmorFlashTiming );//アーマーで耐えた瞬間（不具合修正専用フラグ）
	}
	
	if( ArmorBreak )
	{
		Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_ArmorBreak );
		
		local atk_enemy = BMvCore.GetLastDamageCharaData( 0 ); // そのままを取得（1だと一番上の親）
		local atk_enemy_oya = BMvCore.GetLastDamageCharaData( 1 ); // そのままを取得（1だと一番上の親）
		if( atk_enemy.push() )
		{
			//_dpn("アーマーブレイクを記憶");
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_ArmorBreak );
			
			if( !atk_enemy.isPlayer() && BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				if( atk_enemy_oya.push() )
				{
					//_dpn("親にもアーマーブレイクを記憶");
					Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_ArmorBreak );
					
					atk_enemy_oya.pop();
				}
			}
			atk_enemy.pop();
		}
	}
	
	if( GRDBreak ) //１Ｆ内同時ヒットすると何度も入ってくる
	{
		Battle_Std.GRDBreak_Damage( { Nage=Nage } ); // GRDブレイクを受けたキャラの処理
	}
	
	//カウンター発生
	//Lightにはない処理だがこれを入れないと投げでカウンターが取れない（差分を要チェック）
	if( info.counterhit!=0 )
	{
		_dpn("カウンターヒット？");
		
		//print("\n投げ？:"+Nage)
		Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光
		if( Battle_Std.GetPSFlag( def_PP_PS_isThrowMv ) )
		{
			//投げモーション中のカウンターでは投げ抜け可能のままにする
			// _dm("投げモーション中のカウンターでした");
			
		}
		else if( Nage )
		{
			//それ以外ならカウンターしたら投げ抜け不可にする
			Battle_Std.CreateTechObject_TechMissStart(); //投げ抜け失敗状態にする
			// Battle_Std.DrawDebugAttackInfo("! Counter NageNuke Miss");				
		}
	}

	Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_Damaged );//やられベクトルが入る前にチェックしたいとき用
	
	//空中からのやられでは振り向く・捕まれ中だったら空中でも振り向かない
	//local bs = BtlMvStd.GetBoundStatus();
	//local isFirstBoundTbl = (bs.isBound && bs.VecCount==0); //ベクトルテーブルの最初かどうか

	//if( isFirstBoundTbl && !bs.isCapture ) //ベクトルテーブルの最初かつつかまれ中以外なら
	//{
	//	Battle_Std.SetMuki_ReverseEnemy(); //殴られた相手と反対の向きを向く
	//}
	//BoundInitに一任
	
	//print( format( "\nDamageImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );
	//print("\n中段："+Tyudan+" 下段："+Gedan+" 上段："+Zyodan+" 立："+StdGuard+"　屈："+CroGuard+" 空："+AirGuard+"  "+mask)
	
	if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
	{
		if( Zenbu_Syodan )
		{
			Battle_Std.DebugFunc.CallBountInitScript();
		}
	}
}


Battle_Std.GRDBreak_Attack <- function( param={} )
{
	_dpn("★GRDBreak_Attack");
	
	local Nage = ( "Nage" in param && param.Nage )? param.Nage : 0;
	local NoHosei = ( "NoHosei" in param && param.NoHosei )? param.NoHosei : 0;
	
	// GRDブレイク始動はフェイタル
	Battle_Std.ComboPoint_Multi( def_CPH_BreakHit ); // コンボポイントを乗算
	Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_GRDBreakAttack ); // GRDブレイクを発生させた攻撃
	
	if( Nage )
	{
		if( Battle_Std.MoveCode.CheckFlag( def_MC_GRDBreak_FatalDmgHosei ) )
		{
			// 3Dを強引に掴んだときこの処理で不自然に火力がアップするバグがあるので、投げでの火力アップは入れない
			// でもGRDブレイクしてるので火力は10%アップする
			if( !NoHosei )
			{
				_dpn("　->補正を入れる:"+def_HOSEI_BreakFatalThrow );
				BMvEff.ComboView_Set( { val=def_HOSEI_BreakFatalThrow, type=1 } ); // 乗算
			}
		}
		
		// 投げだとしたら相手は投げ抜け不能にする
		// これがないと、投げ抜け失敗Fが終わると投げ抜けを受け付けてしまう
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnemyTechImpossible );//投げ抜け不可にする
	}
	
	// ブレイク時に補整をキツくする予約のあったMV
	if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_GRDBreak_WeakDmgHosei ) )
	{
		local hosei = BMvTbl.GetPP(def_PP_WeakBreakDamageHosei); // 予約のあったダメージ補整値
		if( hosei )
		{
			BMvEff.ComboView_Set( { val=hosei, type=1 } ); // 乗算
			_dpn(" ->ブレイク時の補整をキツくする:"+hosei );
		}
		BMvTbl.SetPP(def_PP_WeakBreakDamageHosei,0); // 使ったので初期化
	}
	
	// 割れるエフェクトの表示位置
	// 攻撃側からの呼び出し
	// 打撃のときは、ヒットエフェクトの座標でOK
	// 投げのときは相手の位置のそれっぽい位置に適当に出す
	// 何も検知できていないときは例外なのでそもそも表示しないor保険処理を書くべきだが、一旦動いてるのでOKに
	
	//Battle_Std.TypeSE_Play({ type="ＧＲＤブレイク成功" });
	
	//ブレイクしたのでガラスを飛び散らせる
	local eff_pos_ok = 0;
	local pos = BMvEff.GetAttackHitPos(); //敵のヒットエフェクト座標を取得
	
	//投げの時は座標が足元になっているかもしれないので重なり判定の真ん中あたりに変える
	//取得できなかったら適当にそれっぽい座標に出す
	if( Nage )
	{
		// _dpn("Nage");
		local cap_player = BMvCore.GetCaptureCharaData();
		if( cap_player.push() )
		{
			// _dpn("敵検知した");
			eff_pos_ok = 1;
			local cappos = BMvTbl.GetPosition();
			
			pos.x = cappos.x;
			pos.y = cappos.y - 200*128;

			cap_player.pop();
		}
	}
	else
	{
		eff_pos_ok = 1; // 打撃のときはOKのはず
	}

	 // _dpn("座標:x"+pos.x+" y:"+pos.y);
	//シールドエフェクトの残りかす
	
	// 被弾してるキャラからの生成
	// つかまれているときはつかみキャラの座標になってしまうので問題がある
	
	local eff = BMvEff.CreateObject( { x=0, y=-200*128, mvname="", datatype=1, start_pat=327, flags=0 } );
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		
		if( eff_pos_ok ) // 有効っぽい
		{
			BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
		}
		
		//散らせる
		local pow = 1.5;
		for(local i=0; i<10; i++)
		{
			local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=326, flags=0 } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
				BMvEff.SetExist( { level = _Exist_NoHantei } );
				
				local e_grp_FrameID = 10+BMvEff.Random_Limit(3)*10; // 10 20 30...
				local e_pos = BMvEff.Random_PointRad( { radx=128, rady=128 } );
				BMvTbl.SetPosition( { x=e_pos.x, y=e_pos.y, flags=_Position_Add } );
				//BMvTbl.SetMuki( _Direction_Reverse );
				
				local frame = 14+BMvEff.Random_Limit(10);
				local e_ang = 0.125+(BMvEff.Random_F()*0.7);
				local e_spd = (2000+BMvEff.Random_Limit(700))*pow;//-sa*6000;
				local v = BMvEff.GetVector_FromAngle( { angle = e_ang, speed = e_spd } );
				BMvTbl.SetAngle( {angle_float=e_ang} );
				BMvTbl.SetVector( { x=v.x, y=v.y, addx=-v.x/frame, addy=-v.y/frame, flags=_Vector_Div } );
				BMvTbl.JumpFrameID(e_grp_FrameID);
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				
				eff.pop();
			}
		}

		eff.pop();
	}

	
}

//GRDブレイクを受けたがわの処理
//なぜか3D中を被弾すると入ってこない
Battle_Std.GRDBreak_Damage <- function( param={} )
{
	_dpn("★GRDBreak_Damage");

	local Nage = ( "Nage" in param && param.Nage )? param.Nage : 0;
	
	Battle_Std.TypeSE_Play({ type="ＧＲＤブレイク" });
	
	//GRDブレイクしたら投げ抜けはできない
	Battle_Std.CreateTechObject_TechMissStart(); //投げ抜け失敗状態にする
	Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光

	// 食らった行動で分岐
	local breaktime = def_GRDBF_NormalAtkDmg; // ブレイク時間 デフォは60*10フレーム
	local enemy_LastDmg = BMvCore.GetLastDamageCharaData( 0 );
	if( enemy_LastDmg.push() )
	{
		_dpn("相手取得できた");
		local lowbreak = Battle_Std.MoveCode.CheckFlag( def_MC_GRDLowBreak );
		enemy_LastDmg.pop();

		// 攻撃の種類をチェック
		if( Nage )
		{
			// 投げ
			breaktime = def_GRDBF_ThrowAtkDmg; // 15秒
		}
		else if( lowbreak )
		{
			// ブレイク時間の短いMv
			breaktime = def_GRDBF_LowAtkDmg; // 7秒
		}
		// _dp("\n breaktime:"+breaktime);
	}
	
	// ここでブレイク＆アナウンスを表示
	BMvEff.GRD_SetBreak( 0, breaktime, breaktime ); // 0:自分 1:相手, ブレイク時間, 再ブレイク時間
	// BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
}

//殴られた相手と反対の向きを向く
//ベクトルと絵の向きは相手の向き依存であるはず
//MEMO:バグなんだけど直せない。サポートキャラに殴られたとき、サポートの透明親はサポートと向きが異なる場合がある
Battle_Std.SetMuki_ReverseEnemy <- function( playertarget=0 /* 殴られた相手の一番親を取得するか */ )
{
	local lastDmObj = BMvCore.GetLastDamageCharaData(0); // 最後にダメージを与えたオブジェクト
	local noFurimuki = 0; // 振り向かないチェック
	if( lastDmObj.push() )
	{
		noFurimuki = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_DamageNoFurimuki );
		lastDmObj.pop();
	}
	if( noFurimuki==1 ) return 0; // 振り向かない時は終わり
	
	//相手の向きを取得
	//※飛び道具に対してやられた時とかもあるのでこうする
	//val	0 そのままの相手を取得 1 殴られた相手の一番親を取得
	local enemy = BMvCore.GetLastDamageCharaData( playertarget ); //自分が最後に「殴られた相手」情報

	//local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //
			local enemy_is_migimuki = (BMvTbl.GetMuki()==1);
		BMvCore.PopCharaData(); //	

		if( enemy_is_migimuki )
		{
			//print("\n相手が→なので←を向く");
			BMvTbl.SetMuki( _Direction_Left );//相手が→なので←を向く
		}
		else
		{
			//print("\n反対");
			BMvTbl.SetMuki( _Direction_Right );
		}
	}
}

//入ってるやられベクトルの向きにあわせて向きを変更する
//※壁バウンドは壁からのやられ扱いなのでこれを入れると逆になる
//多分それ以外は大丈夫だがやや怖め
Battle_Std.SetMuki_BoundVectorMuki <- function()
{
	local bs = BtlMvStd.GetBoundStatus();
	if( bs.isBound )
	{
		if( bs.VecMuki==_Direction_Left  )
		{
			//print("\n _Direction_Left ");
			BMvTbl.SetMuki( _Direction_Right );
		}
		else
		{
			//print("\n _Direction_Right ");		
			BMvTbl.SetMuki( _Direction_Left );
		}
	}
}

//受身のキャラクターフラッシュ
//地上受身・空中受身・壁受身とか
Battle_Std.SetCharaFlash_Ukemi <- function()
{
	BMvEff.SetCharaFlash( { color = 0x00AA00, type = 0, time = 10 } ); //受身で光る
}

//コンバート中
Battle_Std.SetCharaFlash_ConvertCharge <- function()
{
	BMvEff.SetCharaFlash( { color = 0x000022, type = 1, time = 4 } ); 
}

//カウンターヒットのキャラクターフラッシュ
Battle_Std.SetCharaFlash_Counter <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 15 } ); //カウンターでちょっと赤く光る
}

//アーマーで耐えているときのキャラクターフラッシュ
Battle_Std.SetCharaFlash_Armor <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 10 } );
}

//投げ抜け不能つかまれのキャラクターフラッシュ
Battle_Std.SetCharaFlash_TechMiss <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 30 } ); //抜けれないので赤く光るとか
}

//投げ抜け発生時のキャラクターフラッシュ
Battle_Std.SetCharaFlash_TechSuccessInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 20 } ); //抜け側が光る
}

//失敗ガードでバリア入力中だった
Battle_Std.SetCharaFlash_FaultGuardSPInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 20 } ); //ブレイクするので光る
}

//シールドアタック
Battle_Std.SetCharaFlash_ShieldAtkInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFDDDD, type = 0, time = 10 } );
}

//ガードシールド入力
Battle_Std.SetCharaFlash_GuardSPCommand <- function( time=10 )
{
	// BMvEff.SetCharaFlash( { color = 0xAAAAFF, type = 0, time = time } ); //ガードシールド入力で光る
	BMvEff.SetCharaFlash( { color = 0x55AA55, type = 0, time = time } ); //ガードシールド入力で光る
}

//ガードキャンセル発動
Battle_Std.SetCharaFlash_GuardCansel <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 10 } ); //ＧＣ入力で光る
}


//ジャッジ勝利orドロー（GRDが光るとき）
Battle_Std.SetCharaFlash_GRDJudgeFlash <- function()
{
	BMvEff.SetCharaFlash( { color = 0xEEDDFF, type = 0, time = 20 } ); //
}

//リベレート発動時
Battle_Std.SetCharaFlash_LiberateInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 15 } );
}

//ポテンシャル発動時
Battle_Std.SetCharaFlash_PotentialFlash <- function()
{
	BMvEff.SetCharaFlash( { color = 0xEEDDFF, type = 0, time = 20 } ); //
}


//残像
//ダッシュ攻撃
Battle_Std.PcAfterImage_DashAtkInit <- function()
{
	BMvEff.PcAfterImage_Set( {  type=0, range=12, delay=4, color=0x8FAAAAFF, blendmode=0 } );
}

//EX必殺技
Battle_Std.PcAfterImage_EXSkillInit <- function()
{
}

//回避
Battle_Std.PcAfterImage_DoudgeInit <- function()
{
	BMvEff.PcAfterImage_Set( {  type=0, range=12, delay=4, color=0xFFAAAAFF, blendmode=1 } );	
}

//オーラ
//リベレート中
Battle_Std.PcAuraEffect_LiberateInit <- function( isCelestial = false )
{
	if( isCelestial )
	{
		BMvEff.PcAuraEffect_Set( { type=1, time=0, power=2.0, color=0xAFDD0000, colorB=0x3FDD0000, color_chara=0x001F0505, blendmode=0, delay=60 } );
	}
	else
	{
		BMvEff.PcAuraEffect_Set( { type=1, time=0, power=1.4, color=0xAFDD0000, colorB=0x3FDD0000, color_chara=0x001F0505, blendmode=0, delay=90 } );
	}
}

//ワースカットイン中
Battle_Std.PcAuraEffect_CutinInit <- function()
{
	Battle_Std.PcAuraEffect_CommonAuraSet( { type=0, time=60, power=1.0, color=0x55FF00AA, colorB=0x00FF0000, blendmode=0 } );
}

//コンバート中
Battle_Std.PcAuraEffect_ConvertCharge <- function()
{
}


//GRDジャッジで最初に勝利した瞬間、またははりなおしのタイミングで呼ばれる
//連続勝利した時は入ってこない
Battle_Std.GRDJudgeWinEffect_Init <- function( isCelestial = false )
{
	if( isCelestial )
	{
		BMvEff.PcAuraEffect_Set( { type=0, time=0, power=1.6, color=0xAA00AAFF, colorB=0x0000AAFF, color_chara=0x00001A2A, delay=45, blendmode=0 } );
	}
	else
	{
		BMvEff.PcAuraEffect_Set( { type=0, time=0, power=1.0, color=0xAA00AAFF, colorB=0x0000AAFF, color_chara=0x00001A2A, delay=60, blendmode=0 } );
	}
}


//一時的に出すオーラ呼び出しのかませ関数
Battle_Std.PcAuraEffect_CommonAuraSet <- function(flag)
{
	BMvEff.PcAuraEffect_Set( flag );
	local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CharaAura", } );
	if( eff.push() )
	{
		BMvTbl.SetLP(0,flag.time);
		
		eff.pop();
	}
}

//他のオーラ持続フラグを消す
//消されるとオーラ管理さんがでばってきてオーラを再度はってくれる
Battle_Std.PcAuraEffect_CommonAuraEnd <- function()
{
	Battle_Std.PcAuraEffect_Clear();
	Battle_Std.ClearAuraFlag();
}

//なんか全部消す
Battle_Std.PcAuraEffect_AllAuraEnd <- function()
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)|def_PP_PS_AuraKanriEnd) );
	
	//print("ぜんぶけす");
	Battle_Std.PcAuraEffect_Clear();
	Battle_Std.ClearAuraFlag();
}


//オーラ管理からてきとうなフレーム毎に呼ばれる
Battle_Std.PcAuraEffect_AuraCheck <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.push() )
	{
		local judgeresult = BMvEff.GRD_GetJudgeResult();
		local ls = BMvEff.Liberate_Get();
		local isCelestial = (BMvTbl.GetCelestialVorpalMode() > 0);
		
		local isVO = ( Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) || Battle_Std.GetPSFlag(def_PP_PS_isLiberate) );
	
		p.pop();
		
		if( judgeresult > 0 ) // 勝ち
		{
			if( isCelestial && !Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_WinCeles) ) //勝利でかつフラグが無い
			{
				Battle_Std.SetPSFlag(def_PP_PS_isGRDJ_WinCeles); //もう出したからオーラはり続けないフラグ
				Battle_Std.DelPSFlag(def_PP_PS_isGRDJ_Win);
				
				if( !isVO ) // VPとVOならVOのオーラ優先
				{
					Battle_Std.GRDJudgeWinEffect_Init( isCelestial ); //演出開始
				}
			}
		
			if( !isCelestial && !Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) ) //勝利でかつフラグが無い
			{	
				Battle_Std.SetPSFlag(def_PP_PS_isGRDJ_Win); //もう出したからオーラはり続けないフラグ
				Battle_Std.DelPSFlag(def_PP_PS_isGRDJ_WinCeles);
				
				if( !isVO ) // VPとVOならVOのオーラ優先
				{
					Battle_Std.GRDJudgeWinEffect_Init( isCelestial ); //演出開始
				}
			}
		}
		
		if( judgeresult <= 0 ) // 負け
		{
			if( Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_WinCeles) || Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) ) //勝利じゃないのに勝利フラグが残ってる
			{
				Battle_Std.PcAuraEffect_Clear(); //オーラを消す
				Battle_Std.ClearAuraFlag();	
			}
		}
		
		if( ls==_SpGaugeMode_OverLiberate || ls==_SpGaugeMode_Liberate ) // VO中
		{
			if( isCelestial && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate_Celes) )
			{
				Battle_Std.SetPSFlag(def_PP_PS_isLiberate_Celes);
				Battle_Std.DelPSFlag(def_PP_PS_isLiberate);

				Battle_Std.PcAuraEffect_LiberateInit( isCelestial );
			}
			if( !isCelestial && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate) )
			{
				Battle_Std.SetPSFlag(def_PP_PS_isLiberate);
				Battle_Std.DelPSFlag(def_PP_PS_isLiberate_Celes);

				Battle_Std.PcAuraEffect_LiberateInit( isCelestial );
			}
		}

		if( ls==_SpGaugeMode_Normal ) // 通常
		{
			if( Battle_Std.GetPSFlag(def_PP_PS_isLiberate) || Battle_Std.GetPSFlag(def_PP_PS_isLiberate_Celes) )
			{
				Battle_Std.PcAuraEffect_Clear(); //オーラを消す
				Battle_Std.ClearAuraFlag();
			}
		}
	}	
}

Battle_Std.GetPSFlag <- function(flag)
{
	local ret = ((BMvTbl.GetPP(def_PP_PlayerStatus)&flag)!=0);
	return ret;	
}

Battle_Std.SetPSFlag <- function(flag)
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)|flag) );
}

//リベレートなしオーラフラグたてる（フラグを消す）
Battle_Std.DelPSFlag <- function(flag)
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~flag) );	
}


//オーラを消すときのかませ関数
//かならずここを通すこと
Battle_Std.PcAuraEffect_Clear <- function()
{
	BMvEff.PcAuraEffect_Clear();
}

//持続系オーラフラグを全部おる（フラグを消す）
Battle_Std.ClearAuraFlag <- function()
{
	// 軽量化のためにBMvTblを減らした
	local plst = BMvTbl.GetPP(def_PP_PlayerStatus);

	plst = Battle_Std.Val_DelFlag( plst, def_PP_PS_isGRDJ_Win );
	plst = Battle_Std.Val_DelFlag( plst, def_PP_PS_isGRDJ_Draw );
	plst = Battle_Std.Val_DelFlag( plst, def_PP_PS_isLiberate );
	plst = Battle_Std.Val_DelFlag( plst, def_PP_PS_isOverLiberate );
	plst = Battle_Std.Val_DelFlag( plst, def_PP_PS_isGRDJ_WinCeles );
	plst = Battle_Std.Val_DelFlag( plst, def_PP_PS_isLiberate_Celes );
	
	BMvTbl.SetPP(def_PP_PlayerStatus,plst );
}

//超技開始処理
//インフィニットワースイグジストヒット時
Battle_Std.InitIWExistSkill <- function()
{
	BMvEff.AddSkillCount( _SkillCount_SpIFWX ); // 履歴カウンタを加算
	
	BMvTbl.SetMvAction( def_MVA_LASkill );

	if( BMvTbl.GetPP( def_PP_IWEXS_ChgVO_Hit ) )
	{
		// 即死するＩＷＸの時だけ消す
		BMvEff.Cockpit_SetView( { mode=0 } ); //ゲージ類の表示設定　mode 0:非表示 1:表示
	}
	
	if( Battle_Std.GS_CheckFlag( def_PP_GS_VorpalDyingIWEAtk ) ) // VP中のIWEかどうか
	{
		if( Def_Sys_BoostDamageVorpalIWE )
		{
			_dpn("VP中のIWEなので火力を上げる");
			Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_SpRecoverVPIWE );
		}
	}
	
	BMvTbl.SetGrdLimit( 1 ); // 行動中自分と相手のＧＲＤの増減を止める
	
	//ＢＧＭを処刑ＢＧＭに変更
	//BMvEff.BGM_Set( { num=def_BGM_IWExist } );
	
	//BMvEff.FadeProc_Set({type=0, time=[0,3,10] color=0x000000}); //黒くしてから開始
	BMvEff.FadeProc_Set({type=0, time=[0,5,10] color=0xFFFFFF}); //白くしてから開始
	
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.SetPlayerTimer( {
				muteki_nage=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dage=def_FL_SPCutinStopTime,
				muteki_nageX=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dageX=def_FL_SPCutinStopTime } );
			BMvEff.SetStopTime( { time=def_FL_SPCutinStopTime } ); //時間停止

			//カットインが入るIW技の場合ゲージ増加制限をかける
			BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_IWSkill } ); //ゲージ増加制限
			// BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWSkill } ); //一定時間ゲージ増加に制限をかける
			
			BMvTbl.SetMuki( _Direction_Auto ); //相手方向を向く
			
			Battle_Std.RecoverDoubleExHohoHosei(); // EX>EXの保証補正低下を少し戻す
			
			// 240415 EX>IWEで繋いだらVOスカ相当の最低保障補整をかける
			local comboUsedExSkill = Battle_Std.EnemyDamageFlag_Check( def_DF_UseExSkill );
			if( comboUsedExSkill )
			{
				_dpn("EXの保証補正");
				Battle_Std.SetSpHosyoHosei( { type="VO" } );// EX>IWで繋いだらVOスカ相当の補正をかける
			}
			
			// 240415 IW>IWEで繋いだらIW>IW相当の最低保障補整をかける
			local comboUsedSpSkill = Battle_Std.EnemyDamageFlag_Check( def_DF_UseSpSkill );
			if( comboUsedSpSkill )
			{
				_dpn("SPの保証補正");
				Battle_Std.SetSpHosyoHosei( { type="SP" } );//２回目の補正をかける
			}
		}
		BMvCore.PopCharaData(); //	
	}

//	Battle_Std.SetSkillStopTime(def_FL_SPCutinStopTime); //時間停止

	BMvEff.ThrowChara_SetJoint( 0 );
	
	local pos;
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_Offset | _GetPos_NoMuki } );
			Battle_Std.InitVector(); //ベクトル初期化			
		BMvCore.PopCharaData(); //	
	}
	
	local escpos;
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			escpos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_Offset | _GetPos_NoMuki } );
			BMvTbl.SetMuki( _Direction_Auto ); //相手方向を向く
			Battle_Std.InitVector(); //ベクトル初期化			
		BMvCore.PopCharaData();
	}
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			//画面中央にかならず飛んでくる
			local opos = BMvTbl.GetPosition(0);
			
			BMvEff.ResetCamera(); //カメラ初期化
			BMvEff.ResetViewCamera();
			
			BMvTbl.SetPosition( { x=-pos.x, y=0, flags= _Position_ChangeMuki } );
			
			local npos = BMvTbl.GetPosition(0);
			
			BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費			
			//BMvEff.CutInProc_Set({ time=[3,2000,10], cutin_mv="",erasetype=1 }); //カットイングラフィックとか呼び
			//Mv_IWXCutin
			BMvEff.CreateObject( { mvname="Mv_IWXCutin" } ); //カットインＭｖ呼び出し

			BMvEff.CutInProc_Set({ time=[3,2000,10], cutin_mv="",erasetype=1 }); //カットイングラフィックとか呼び
			
			BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } ); //カメラ集中テスト

			Battle_Std.SetPSFlag(def_PP_PS_NoAura); //オーラは張らない			
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
		BMvCore.PopCharaData(); //	
	}
	
	BMvEff.SetObjectRender( { type=1 } ); //設置物がワープしてしまうので演出中は消す
	
	

	//相手
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			local epos = BMvTbl.GetPosition(0);
			BMvTbl.SetPosition( { x=-escpos.x, y=0, flags= _Position_ChangeMuki } );
			
			Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoice ); // やられ音声を再生しない
			
			Battle_Std.SetPSFlag(def_PP_PS_NoAura); //オーラは張らない			
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			//BMvEff.PcAuraEffect_Clear(); //オーラを消す
		BMvCore.PopCharaData();
	}
	
	BMvEff.ThrowChara_SetJoint( 1 );
	
}

//超技終了処理
//基本的にLastUpdateで呼ばれる
Battle_Std.FinalizeIWExistSkill <- function()
{
	// これは念のため表示を上書きする
	BMvEff.Cockpit_SetView( { mode=1 } ); //ゲージ類の表示設定　mode 0:非表示 1:表示
	BMvEff.CutInProc_SetResourceView( { mode=1 } ); // 謎空間の非表示を念の為戻す
	
	if( BMvTbl.GetPP( def_PP_IWEXS_ChgVO_Hit ) )
	{
		// 即死するＩＷＸの時だけコンボ表示を消す
		BMvEff.ComboView_Clear(); // コンボを切る（コンボ終了状態にする）
	}	

	BMvEff.CutInProc_Erase(); //カットインを消去する
	BMvEff.SetObjectRender( { type=0 } ); //演出中消していたものを復活

	Battle_Std.DelPSFlag(def_PP_PS_NoAura); //オーラは張らない
	Battle_Std.PcAuraEffect_CommonAuraEnd(); //オーラ復活

	//他に何かある？	
	
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			Battle_Std.SoundStatus_DelFlag( def_PP_SS_NoBoundVoice ); // やられ音声を再生しないを消す

			Battle_Std.DelPSFlag(def_PP_PS_NoAura); //オーラは張らない
			Battle_Std.PcAuraEffect_CommonAuraEnd(); //オーラ復活
		BMvCore.PopCharaData();
	}
	
	BSound.BGM_SetFade( { val=100, time=60 } );//BGM戻し
}

Battle_Std.IWExistSkill_FinishEffect <- function()
{
	//KOと同じようなゆれとかを呼ぶ
	BMvEff.Slowmotion_Set( { time=120, power=6666 } );
	BMvEff.SetCamera_Quake( { type=2, time=40, } );
}


//超技終了処理
//正しく超技が終了した時
Battle_Std.FinalizeWorthSkill <- function()
{
	BMvEff.CutInProc_Erase(); //カットインを消去する
	//他に何かある？	
}

// 暗転の見た目だけ処理
Battle_Std.SetEXCutinCameraFocus <- function( stopframe )
{
	// そもそも特殊判定の有無を見る必要ある？
	// local rc0 = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	// if( rc0.sx != _Hantei_Error ) // 存在するか
	{	
		Battle_Std.SetInstantCameraFocus( stopframe );
	}
}

//ちょっとカメラ集中
Battle_Std.SetInstantCameraFocus <- function( _frame )
{
	//集中先は気持ちプレイヤーに寄せるぐらいの位置にする
	local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
	local posst = BMvEff.GetPointStatus( { position=center_pos } ); // 位置情報取得
	local pos = BMvTbl.GetPosition( 0 ); //呼び出し親の座標
	local target_pos = BMvTbl.CCharaPosition(); //位置情報型の生成
	target_pos.x = pos.x + (posst.pos_x*75/100);
	target_pos.y = pos.y + (posst.pos_y*75/100);
	
	BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,_frame-10,15], type_in=3, type_out=1
	x=target_pos.x, y=target_pos.y } ); //カメラ集中
	// ※カットイン中にカットインでより拡大される
}

//flags : (1<<0) : カットイン画像を表示しないでEX技扱いにもしない
Battle_Std.SetEXCutinGrp <- function( param={} )
{
	local effPos = { enable=0, x=0, y=0 };
	if( "x" in param && "y" in param )
	{
		effPos.enable = 1;
		effPos.x = param.x;
		effPos.y = param.y;
	}
	else
	{
		local rc0 = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc0.sx != _Hantei_Error ) // 存在するか
		{
			effPos.enable = 1;
			effPos.x = rc0.sx;
			effPos.y = rc0.sy;
		}
	}
	local frame = ( "frame" in param )? param.frame : def_FL_EXCutinBGChangeTime;
	local flags = ( "flags" in param )? param.flags : 0;
	local noCutin = (flags&(1<<0));
	
	// if( !noCutin ) BMvEff.AttackInfoString_Set({ word=def_AISW_EXSkill,} );
	if( effPos.enable )
	{
		if( !noCutin )
		{
			BMvEff.CutInProc_Set({ time=[3,frame-3,5], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び　BGは黒塗りだとしょぼいので変えるようにした
		}
		
		local eff = BMvEff.CreateObject( { x=effPos.x, y=effPos.y, datatype=1, start_pat=270, flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			
			eff.pop();
		}
	}		
}
/*
Battle_Std.SetEXCutinGrp <- function()
{
	local rc0 = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	
	//BMvEff.AttackInfoString_Set({ word=def_AISW_EXSkill,} );
	if( rc0.sx != _Hantei_Error ) // 存在するか
	{	
		BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び		
		
		local eff = BMvEff.CreateObject( { x=rc0.sx, y=rc0.sy, datatype=1, start_pat=270, flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			
			eff.pop();
		}
	}		
}
*/

Battle_Std.CallAntenStopObject <- function()
{
	//暗転される生成されて、自分が暗転後動けるようになると消えるオブジェクト
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_AntenStopObject" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
			eff.pop();
		}
		enemy.pop();
	}
}

//EX技を出した（暗転まで進んだor途中でつぶされた）ら絶対にやらないといけないもの
//_Blocked = 1:途中で潰された時で入ってきた
Battle_Std.StartExSkill <- function( _Blocked = 0 )
{
	Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_PaySkillCost );

	BMvEff.AddSkillCount( _SkillCount_SpEx ); // 履歴カウンタを加算
	
	if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_NoSetUseExSkillFlag ) )
	{
		// コンボ中にEX技を組み込んだかどうか取得
		local comboUsedExSkill = Battle_Std.EnemyDamageFlag_Check( def_DF_UseExSkill );
		if( comboUsedExSkill )
		{
			_dpn("EXの保証補正");
			Battle_Std.SetSpHosyoHosei( { type="EX" } );//２回目の補正をかける
		}
		
		Battle_Std.EnemyDamageFlag_Add( def_DF_UseExSkill ); // コンボ中EX技を使ったのを相手に記憶
	}
	
	//デメリット
	BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
	if( Def_Sys_FixUseExSkillSpCost_KoTiming && _Blocked && Battle_Std.CharaisKO() )
	{
		// KOされるとバッファーは消えてしまうが、このタイミングだとギリギリまだ残っている
		// 正直固定値をマイナスするだけでもいい気はするが…
		local spUseBuffer = BCMDTbl.GetSpUseBufferTmp();
		// _dpn("ゲージ消費予約を取得:"+spUseBuffer);

		// どんな値が入ってるかよくわからないかもなので丸め込む
		if( spUseBuffer < 0 ) spUseBuffer = 0;
		if( spUseBuffer > 20000 ) spUseBuffer = 20000; // EXしかないのでもっとシビアにしてもいいかもだが…
		BMvEff.SetSpGauge( { value=-spUseBuffer } ); // バッファーはプラスの値なので引く
	}
	else
	{
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
	}
}


// ABCDでイグジスト攻撃を出すときの暗転
Battle_Std.Init_ExistAtkSkill <- function(type=0,stopframe=def_FL_EXCutinStopTime)
{
	//BMvEff.AddSkillCount( _SkillCount_SpEx ); // 履歴カウンタを加算…しない　ただの必殺技なので
	
	//特殊判定１だったら通常暗転
	//特殊判定２だったら時間停止中に進む暗転
	
	//_dm("Battle_Std.InitWorthSkill()");

	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		//集中先は気持ちプレイヤーに寄せるぐらいの位置にする
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local posst = BMvEff.GetPointStatus( { position=center_pos } ); // 位置情報取得
		local pos = BMvTbl.GetPosition( 0 ); //呼び出し親の座標
		local target_pos = BMvTbl.CCharaPosition(); //位置情報型の生成
		target_pos.x = pos.x + (posst.pos_x*75/100); //整数化:0.75
		target_pos.y = pos.y + (posst.pos_y*75/100); //整数化:0.75
		
		BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,stopframe-10,15], type_in=3, type_out=1
		x=target_pos.x, y=target_pos.y } ); //カメラ集中
		// ※カットイン中にカットインでより拡大される

		//カットインが入るEX技の場合ゲージ増加制限をかける
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_EXSkill } ); //一定時間ゲージ増加に制限をかける
		
		player.pop();
	}

	//時間停止中に進む暗転
	Battle_Std.SetSkillStopTime(stopframe,0); //時間停止,1F後に暗転中無敵は付与しない

	if( player.push() )
	{
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		BMvEff.CutInProc_Set({ time=[3,120,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び		
		//BMvEff.AttackInfoString_Set({ word=def_AISW_EXSkill,} );
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );		
		if( rc.sx != _Hantei_Error ) // 存在するか
		{	
			local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=271, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				
				eff.pop();
			}
		}
		
		player.pop();
	}
	
}

//必殺技用の時間停止
//暗転中に進むタイプ
Battle_Std.SetSkillStopTime <- function(stopframe=def_FL_EXCutinStopTime, set_nextf_muteki=0 )
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
		Battle_Std.CallAntenStopObject();	
	
		local muteki_time = stopframe+Def_Sys_EXCutinNageMuteki; // 投げ無敵時間をプラス
		BMvEff.SetPlayerTimer( { muteki_nage=muteki_time, muteki_nageX=muteki_time } ); //投げ無敵だけ設定
		//BMvEff.SetPlayerTimer( { muteki_nage=muteki_time, muteki_dage=muteki_time, muteki_time=stopframe, muteki_nageX=muteki_time } ); //暗転バグ回避
		BMvEff.SetStopTime( { time=stopframe, bounderase=1 } ); //時間停止
		
		// 暗転2F〜暗転終了までプレイヤーに打撃無敵を設定するオブジェクトを呼び出す
		if( set_nextf_muteki )
		{
			local eff = BMvEff.CreateObject( { mvname="Mv_Null_SetNextMutekiObject" } );
			if( eff.push() )
			{
				//MEMO:どんなパターンや行動か不明なのでPatやMv変更での消滅はさせていない
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_MoveTimeStopAll } );
				BMvEff.SetExist( { level = _Exist_NoHantei } );
			
				BMvTbl.SetLP(0,stopframe);//暗転時間をオブジェクト側にわたす
				
				eff.pop();
			}
		}
		
		player.pop();
	}
}

// 切り札エフェクトを呼ぶ＋５フレーム後に切り札効果を発動＋消費する
Battle_Std.Init_Kirifuda <- function()
{
}

Battle_Std.Call_KirifudaEffect <- function()
{
}


// 特定フレームで切り札カウントを消費する…タイミング
Battle_Std.UseKirifuda_DelayUpdateTiming <- function()
{
}

local grp_ap = [
	120, //1
	100, //2
	80, //3
	60, //4
	40, //5
	50, //6
	40, //7
	30, //8
	20, //9
	20, //10
	20, //11
	20, //12	
];
	
//GRDの増加値を返す（GRDが多いほど増えにくい感じを出すため）
Battle_Std.GetGRD_AddValue <- function(addgrdval=0) : (grp_ap)
{
	local cost = BMvEff.GRD_CheckStock( { val=-1 } );
	if( cost>11 ) cost = 11; //最大

	local ret = grp_ap[cost]*addgrdval/100; //整数化
	return ret;
}

//GRD増加のかませ関数
//ブレイク中は増やさないとかそういうのを判断
Battle_Std.GRD_AddValue <- function(tbl)
{
	/*
	( return == 0 ) ブレイクしていない
	( return != 0 ) なんらかのブレイク中
	( return == 1 ) ブレイク中
	( return == 255 ) オーバーブレイク中
	*/
	if( !( "val" in tbl ) ) tbl.val <- 0;
	if( !( "target" in tbl ) ) tbl.target <- 0; //自分にする
	/*
	target	0 自分 1 敵
	*/

	local p = ( tbl.target==0 )?  BMvCore.GetPlayerCharaData() : BMvCore.GetNearEnemyCharaData();
	if( p.push() )
	{
		if( BMvEff.GRD_GetBreak(0) == 0 ) // ブレイクしてない
		{
			BMvEff.GRD_AddValue( tbl );
		}
		else // 何らかのブレイク中
		{
			if( tbl.val<0 ) BMvEff.GRD_AddValue( tbl ); //減るのは普通に減る		
		}
		p.pop();
	}
}


Battle_Std.SetSpGauge_BarrierFU <- function(tbl)
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local r = BMvEff.GRD_GetBreak(0);
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		
		if( s.MvCount<def_FL_Shield_SPCostStartFrame ) return; //まだ減る時ではない
		
		if( !( "value" in tbl) ) tbl.value <- 0;
		
		switch( r )
		{
		case 0: //ブレイクしてない
			break;
		case 1: //ブレイク
			tbl.value = tbl.value * def_SP_Barrier_Frame_BreakVal/100;
			break;
		case 255: //オーバーブレイク
		default: //なんらかのブレイク中
			tbl.value = tbl.value * def_SP_Barrier_Frame_OverBreakVal/100;
			break;
		}
			BMvEff.SetSpGauge( {value=tbl.value,} );

		//BMvEff.SetSpGauge( {value=def_SP_BarrierA_Frame,} ); //バリアによるSPゲージ消費	
	}
}

Battle_Std.SetSpGauge_ConvertChargeFU <- function(tbl)
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local r = BMvEff.GRD_GetBreak(0);
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		
		if( s.MvCount<def_FL_Shield_SPCostStartFrame ) return; //まだ減る時ではない
		
		if( !( "value" in tbl) ) tbl.value <- 0;
		
		switch( r )
		{
		case 0: //ブレイクしてない
			break;
		case 1: //ブレイク
			tbl.value = tbl.value * def_SP_Barrier_Frame_BreakVal/100;
			break;
		case 255: //オーバーブレイク
		default: //なんらかのブレイク中
			tbl.value = tbl.value * def_SP_Barrier_Frame_OverBreakVal/100;
			break;
		}
			BMvEff.SetSpGauge( {value=tbl.value,} );

		//BMvEff.SetSpGauge( {value=def_SP_BarrierA_Frame,} ); //バリアによるSPゲージ消費	
	}
}

// プレイヤーがやられかチェック
// _TechisDamage = 1 : 投げ抜け成功時もやられ扱いにして、trueを返すようにする
Battle_Std.CheckPlayerisDamage <- function( _TechisDamage = 1 )
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		player.pop();

		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている

		//のけぞりorつかまれ
		if( !_TechisDamage && bs.GetBoundFlag() & (1<<8) ) return false; // 特殊やられ（DamageEx）状態なので弾く
		if( bs.isBound == 1 || bs.isCapture != 0 )  return true;
	}
	return false;	
}

//プレイヤーがガード状態かチェック
Battle_Std.CheckPlayerisGuard <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //
		
		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている		
		if( bs.isBound == 2 || (bs.isBound && bs.Name.find("ガード")!=null ) ) return true;
		//isBound == 2 で基本はOKだが、HitInterruptで投げ技をチェックする場合、HitInterruptの時点で掴んでいてisBound==1になっている
	}
	return false;	
}

Battle_Std.CheckEnemyisGuard <- function()
{
	local enemy = BMvCore.GetEnemyCharaData(); // 操作親の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている		
		if( bs.isBound == 2 || (bs.isBound && bs.Name.find("ガード")!=null ) ) return true;
		//isBound == 2 で基本はOKだが、HitInterruptで投げ技をチェックする場合、HitInterruptの時点で掴んでいてisBound==1になっている
	}
	return false;	
}

//プレイヤーが受け身状態かチェック
Battle_Std.CheckPlayerisUkemi <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		local is_ukemi = false;
		if( BMvCore.PushCharaData( p ) )
		{
			is_ukemi = ( Battle_Std.MoveCode.CheckFlag( def_MC_Recovery ) == 1 );
		}
		BMvCore.PopCharaData();
		
		return is_ukemi;
	}
	return 0;
}

//相手が受け身状態かチェック
Battle_Std.CheckEnemyisUkemi <- function()
{
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		local is_ukemi = false;
		if( BMvCore.PushCharaData( e ) )
		{
			is_ukemi = ( Battle_Std.MoveCode.CheckFlag( def_MC_Recovery ) == 1 );
		}
		BMvCore.PopCharaData();
		
		return is_ukemi;
	}
	return 0;
}


//相手がやられかチェック
// _TechisDamage = 1 : 投げ抜け成功時もやられ扱いにして、trueを返すようにする
// _CheckUkemiTime = 1 : 1Pと2Pでの処理順の差を考慮する(空中やられのみ)
// ※純粋に1Pの本体から呼ばないと効果がなさそうなので注意
Battle_Std.CheckEnemyisDamage <- function( _TechisDamage = 1, _CheckUkemiTime = 0 )
{
	local pSideNo = (_CheckUkemiTime)? BMvTbl.GetPlayerNo() : 0;
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local eSideNo = (_CheckUkemiTime)? BMvTbl.GetPlayerNo() : 0;
		local eStop = (_CheckUkemiTime)? BMvTbl.GetHitStop() : 0;
		local eRecoverTiming = BMvTbl.CheckRecoverCommandTiming(); // 受け身コマンドをいれているタイミングかどうか
		
		enemy.pop();
		
		if( !_TechisDamage && bs.GetBoundFlag() & (1<<8) ) return false; // 特殊やられ（DamageEx）状態なので弾く
		if( bs.isBound == 1 || bs.isCapture != 0 )
		{
			if( _CheckUkemiTime )
			{
				if( pSideNo < eSideNo ) // ※1P・2P固定ではなく後ろのプレイヤーならに変更
				{
					local bsUkemiNow = bs.GetAirUkemiTimeNow();
					local bsUkemiMax = bs.GetAirUkemiTimeMax();
					local bsAirUkemi = bs.AirUkemi;
					
					// _dpn("受け身:"+bsUkemiNow+"/"+bsUkemiMax+" STOP:"+eStop+" bsAirUkemi:"+bsAirUkemi+" eRecoverTiming:"+eRecoverTiming);
					
					// bsUkemiNow > bsUkemiMax : だとインバリコンボ
					// bsUkemiMax == 0 : 受け身不能
					if( eStop <= 0 && bsUkemiNow == bsUkemiMax && bsUkemiMax > 0 && bsAirUkemi && eRecoverTiming )
					{
						_dpn("同フレームで受け身確定なのでやられ扱いにしない");
						// 1Pから見ると、同フレームで受け身予定の2PもisBoundになってしまう
						// なので、2P側のときは受け身不能が終わってそうなら非やられにする
						return false; // 次のフレームで受け身確定です
					}
				}
			}
			return true;
		}
	}
	return false;
}

Battle_Std.CheckEnemyisAirDamage <- function( _TechisDamage = 1 )
{
	if( Battle_Std.CheckEnemyisDamage(_TechisDamage) )
	{
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
		if( enemy.push() )
		{
			local isAir = BCMDTbl.CheckPosState(_PosState_Air);
			
			enemy.pop();
			
			if( isAir ) return true;
		}
	}
	return false;
}

Battle_Std.CheckEnemyisDamage_ExceptDown <- function()
{
	return false;
}

//プレイヤーがやられorガード(Bound)かチェック
Battle_Std.CheckPlayerisBound <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //

		if( bs.isDone !=0 ) return true;
	}
	return false;
}

//相手がやられorガード(Bound)かチェック
Battle_Std.CheckEnemyisBound <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //

		if( bs.isDone !=0 ) return true;
	}
	return false;
}

Battle_Std.CheckPlayerisCapture <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		player.pop();
		
		if( bs.isCapture != 0 )  return true;
	}
	return false;
}

Battle_Std.CheckEnemyisCapture <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		if( bs.isCapture != 0 )  return true;	
	}
	return false;
}


Battle_Std.CheckPlayerisMovable <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // 敵の情報を得る
	if( player.push() )
	{
		local movable = BCMDTbl.CheckCancel( _SkillType_None );
		
		player.pop();
		
		if( movable ) return true;
	}
	return false;
}

//敵が行動可能かどうか（攻撃があるキャラから見ること）
Battle_Std.CheckEnemyisMovable <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local movable = BCMDTbl.CheckCancel( _SkillType_None );
		
		enemy.pop();
		
		if( movable ) return true;
		
		local mvhs = BMvTbl.MvHitStatus();
		if( mvhs.isMoveable ) return true;
	}
	return false;
}

Battle_Std.CheckEnemyPosState <- function( _pos )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local pos_state = BCMDTbl.CheckPosState( _pos );
		
		enemy.pop();

		return pos_state;
	}
	return 0;
}




//複数の抜け先を一括指定
//デフォルトやること＋配列
Battle_Std.SwitchNextMoveTable <- function( def, ... )
{
	//array[0].code = 123
	//array[0].mv = "MvTest"
	//	Battle_Std.SwitchNextMoveTable(
	//"Mv_Modori_Okiagari",[def_FC_RoundLose,"Mv_RoundLose"]

	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < vargc; i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		//_dm("てすと"+typeof vargv[i]) // vargv
		if( typeof vargv[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			BMvTbl.SetNextMoveTable(vargv[i]);
			usedef = false;
		}
		if( typeof vargv[i]=="array")
		{
			if( fc == vargv[i][0] )
			{
				//local end_zanzou = (vargv[i].len()<=2);
				//if( end_zanzou ) BMvEff.PcAfterImage_Clear(); //残像の消去
				if( typeof vargv[i] =="function" )
				{
					vargv[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(vargv[i][1]);
					usedef = false;
					
					/*
					// 影響を考えて今回は無し　一応ちゃんと動作はする
					if( vargv[i].len() > 2 )
					{
						local fin_flag = vargv[i][2]; // ファイナライズ時にフラグを指定定義可能にした
						if( fin_flag&Def_SNMT_Hit )
						{
							_dpn("ヒット分岐でのファイナライズ");
							Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize ); // ヒット分岐フラグを立てる
						}
					}
					*/
				}
			}
		}
	}
	if( usedef )
	{
		if( typeof def =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable(def); //デフォルト抜け先
		}
		if( typeof def =="function" ) 
		{
			def();
		}		
	}
	BMvTbl.SetFinalizeCode(0); //終了コードの初期化
}

// ファイナライズコードを初期化しないバージョン
// それ以外はまったく同じ
Battle_Std.SwitchNextMoveTable_NoClearFinCode <- function( def, ... )
{
	//array[0].code = 123
	//array[0].mv = "MvTest"
	//	Battle_Std.SwitchNextMoveTable(
	//"Mv_Modori_Okiagari",[def_FC_RoundLose,"Mv_RoundLose"]

	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < vargc; i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		//_dm("てすと"+typeof vargv[i]) // vargv
		if( typeof vargv[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			BMvTbl.SetNextMoveTable(vargv[i]);
			usedef = false;
		}
		if( typeof vargv[i]=="array")
		{
			if( fc == vargv[i][0] )
			{
				//local end_zanzou = (vargv[i].len()<=2);
				//if( end_zanzou ) BMvEff.PcAfterImage_Clear(); //残像の消去
				if( typeof vargv[i] =="function" )
				{
					vargv[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(vargv[i][1]);
					usedef = false;
				}
			}
		}
	}
	if( usedef )
	{
		if( typeof def =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable(def); //デフォルト抜け先
		}
		if( typeof def =="function" ) 
		{
			def();
		}		
	}
}

//配列のみで渡すバージョン
//[ [defcode,defmv], [code,mv], [code,mv], ... ]
//[ [defmv], [code,mv], [code,mv], ... ]
Battle_Std.SwitchNextMoveTable_Array <- function( ar )
{
	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	
	for(local i = 1; i < ar.len(); i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		if( typeof ar[i]=="string")
		{			
			BMvTbl.SetNextMoveTable(ar[i]);
			usedef = false;
		}
		if( typeof ar[i]=="array")
		{
			if( fc == ar[i][0] )
			{
				if( typeof ar[i] =="function" )
				{
					ar[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(ar[i][1]);
					usedef = false;
				}
			}
		}
	}

	if( usedef )
	{
		if( typeof ar[0] =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable( ar[0] ); //デフォルト抜け先
		}
		if( typeof ar[0]=="array")
		{
			BMvTbl.SetNextMoveTable(ar[0][1]);
		}
		if( typeof ar[0] =="function" ) 
		{
			ar[0]();
		}		
	}

	BMvTbl.SetFinalizeCode(0); //使ったら初期化
}

Battle_Std.GetNextMoveTable_Array <- function( ar )
{
	local ret_nextmv = "";
	
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < ar.len(); i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		if( typeof ar[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			ret_nextmv = ar[i];
		}
		else if( typeof ar[i]=="array")
		{
			if( fc == ar[i][0] )
			{
				if( typeof ar[i] =="function" )
				{
					ar[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					ret_nextmv = ar[i][1];
				}
			}
		}
	}

	BMvTbl.SetFinalizeCode(0); //使ったら初期化
	
	return ret_nextmv;
}

//攻撃判定が存在するかチェック
//BMvEff.IsAttackRect()を使おう
Battle_Std.CheckHanteiAttackExist <- function(code=0)
{
	local rc = BMvEff.IsAttackRect();
	if( rc ) return 1; // あったら1
	return 0; //無かった
}


//メルブラっぽいヒット分岐　投げがヒットしたら

//FrameUpdateでやるとGetCaptureCharaDataがつかんだ扱いにならないので
//UpdateかHitInterruptでやること
//Updateだとつかみ中もヒット扱いになるのでGetMvHitStatusでチェックしている
//code:投げ抜けできない投げ終了
//gouin_code:！投げで投げ抜けはできる
//combo_code:コンボ中なので投げ抜けできない投げ
//miss_code:投げ抜けできない投げ(これが!= -1だとcodeは投げ抜け可能な投げになり、履歴の投げられ回数が加算される)
//通常投げはここにくる前に強引かどうか分岐してるので注意
//掴みFinalizeをしたら1を返す　掴まなかったりエラー時は0を返す
//techmiss_code:投げ抜け失敗フレーム中投げ -1ならcodeを使う（ちょっと怪しい）→使ってないので未使用になった。代わりにmiss_codeを使う。

// 一般的なコマ投げ。普段は投げ抜け不能だが、ガード中などを掴むと金投げになり、投げ抜け可能になる。
// Battle_Std.SetThrowHitFinalize(256,512,256); // 投げ＆リジェクト(投げぬけ不可),　強引投げ, コンボ投げ

// 常に金投げのコマ投げ。普段は投げ抜け可能だが、相手が投げ抜け不能状態のときはそのまま掴む
// Battle_Std.SetThrowHitFinalize(512,700,256,256); // 投げ,　金投げ, コンボ投げ, リジェクト投げ＆投げが投げぬけ可に変化

// 普通のヒット分岐。ロック技やガード不能技など。
// Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ

//Def_Dbg_SkillThrowLog
Battle_Std.SetThrowHitFinalize <- function(code=0, gouin_code=-1, combo_code=-1, miss_code=-1, techmiss_code=-1 )
{
	//別に攻撃判定が出てなくてもいい気がするね。
	//大事なのはつかんでるかどうかのチェック
	//つかみ中にきたらそりゃ通るけど別にいいだろう
	
	//Finalizeするだけの関数なので何度呼ばれてもいいが、投げ抜け回数を記憶している処理だけは1回のみにする
	//MEMO:将来的には、この処理も一回だけ呼べばいい気はする。というか1回しか通らない思っていた
	local isDamageTiming = Battle_Std.CheckDamageTiming();//つかみの一回目のみ1
	
	local enemy = BMvCore.GetCaptureCharaData();
	if( enemy.isdone() )
	{
		enemy.push();
			local bs = BtlMvStd.GetBoundStatus();
			Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
			local enemyIsMoveable = BCMDTbl.CheckCancel( _SkillType_None );//行動可能状態かどうか
			local enemyCharaNo = BMvTbl.GetMvStatus().CharaNo;
			local enemyIsAtkMv = Battle_Std.MoveCode.CheckFlag( def_MC_Atk|def_MC_Skill );
		enemy.pop();
		
		local flag = (1<<1); // | (1<<2)
		local isGouinNage = (((bs.isCapture&flag)!=0) && gouin_code!=-1); //ガードややられ中を掴んだときはこれ（通常投げでは入らない）
		local isComboNage = ( (bs.isBound) && ( bs.Name.find("ガード")==null ) && combo_code!=-1); //コンボ投げ
		// local isComboNage = ( (bs.isBound) && ( bs.isBound != 2 ) && combo_code!=-1); //コンボ投げ ※こうするとハメ…
		//print("\n isComboNage"+isComboNage+" bs.isBound"+bs.isBound );
		//ガード中掴んだときもisBound==1になっているので注意（つかまれ中だからだった気がする）
		// _dpn("bs.Name:"+bs.Name+" bs.isBound:"+bs.isBound );
	
		local hs = BMvTbl.GetMvHitStatus();
		if( hs.Type & _HitType_Damage)
		{
			if( Def_Dbg_SkillThrowLog ) _dpn("投げがヒット");
			if( isGouinNage )
			{
				// ガード中とか投げ無敵を掴んだ金投げ
				
				//投げ抜け失敗フレーム中だったら失敗演出も入れて通常ファイナライズ
				if( Battle_Std.ThrowTech.CheckTechMissFrame() )
				{
					if( miss_code == -1 )
					{
						BMvTbl.SetFinalize( code );
						if( Def_Dbg_SkillThrowLog ) _dpn("SetThrowHitFinalizeで強引に投げ抜け不能を掴んだ:"+code);
					}
					else
					{
						BMvTbl.SetFinalize( miss_code );					
						if( Def_Dbg_SkillThrowLog ) _dpn("SetThrowHitFinalizeで強引に投げ抜け不能を掴んだ(x):"+techmiss_code);
					}
					Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize );
					return 1; // 掴み成功
				}
				else
				{
					/*
					//敵が通常技や必殺技のモーション中で、かつ行動不能なら確定
					if( enemyIsAtkMv && enemyCharaNo==Def_ChrNo_Vat && Battle_Std.ThrowTech.CheckTechImpossible() )
					{
						//確定投げで、投げ抜け不能なやつで、技の隙にあてるとここ（ワレンのAコマ投げとか）
						// _dpn("通常技 or 必殺技1");
						if( miss_code == -1 )
						{
							BMvTbl.SetFinalize( code );
						}
						else
						{
							BMvTbl.SetFinalize( miss_code );
						}
						return 1;
					}
					*/
	
					if( isComboNage )
					{
						BMvTbl.SetFinalize( combo_code );						
						if( Def_Dbg_SkillThrowLog ) _dpn("SetThrowHitFinalizeでコンボ投げ:"+combo_code);
						Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize );
						return 1; // 掴み成功
					}
					else
					{
						BMvTbl.SetFinalize( gouin_code );
						if( Def_Dbg_SkillThrowLog ) _dpn("SetThrowHitFinalizeで強引に掴んだ:"+gouin_code);
						
						//強引投げなので補正をかける
						//乗算85%ぐらい？
						//BMvEff.StdCall( { type=6, no=112, param=[ 85,1,0,0,0, 0,0,0,0,0, 0,0 ]} );
						
						//掴んだ相手側に投げられ回数を加算
						if( isDamageTiming )
						{
							if( enemy.push() )
							{
								BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
								if( Def_Sys_NoPunishSkillGouinNage )
								{
									Battle_Std.PP_DelFlag(def_PP_ImpactAnnounce,def_PP_IA_Punish ); // パニッシュ予約があったら消す
								}
								
								enemy.pop();
							}
						}
						Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize );
						return 1; // 掴み成功
					}
				}
			}
			else if( miss_code!= -1 ) // 投げぬけができるコマ投げの時（-1だと投げぬけできないコマ投げ）
			{
				//いきなり掴んだとき
				//投げ抜け失敗フレーム中だったら失敗演出も入れて通常ファイナライズ
				if( Battle_Std.ThrowTech.CheckTechMissFrame() )
				{
					BMvTbl.SetFinalize( miss_code );	
					if( Def_Dbg_SkillThrowLog ) _dpn("SetThrowHitFinalizeで投げ抜け不能を掴んだ(2):"+miss_code);
					Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize );
					return 1; // 掴み成功
				}
				else
				{
					/*
					//バティスタは被カウンターがついていないため、硬直中にあてても投げ抜けされてしまう
					//敵が通常技や必殺技のモーション中で、かつ行動不能なら確定
					if( enemyIsAtkMv && enemyCharaNo==Def_ChrNo_Vat && Battle_Std.ThrowTech.CheckTechImpossible() )
					{
						if( Def_Dbg_SkillThrowLog ) _dpn("通常技 or 必殺技のようだ");
						BMvTbl.SetFinalize( miss_code );
						return 1;
					}
					*/
					
					BMvTbl.SetFinalize( code );	
					if( Def_Dbg_SkillThrowLog ) _dpn("SetThrowHitFinalizeで失敗じゃない時を掴んだ:"+code);

					//掴んだ相手側に投げられ回数を加算
					if( isDamageTiming )
					{
						local enemy = BMvCore.GetCaptureCharaData();
						if( enemy.push() )
						{
							BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
							if( Def_Sys_NoPunishSkillGouinNage )
							{
								Battle_Std.PP_DelFlag(def_PP_ImpactAnnounce,def_PP_IA_Punish ); // パニッシュ予約があったら消す
							}
							enemy.pop();
						}
					}
					Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize );
					return 1; // 掴み成功
				}			
			}
			else //投げぬけができないコマ投げ
			{
				BMvTbl.SetFinalize( code );	
				if( Def_Dbg_SkillThrowLog ) _dpn("SetThrowHitFinalizeで掴んだ:"+code);
				Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize );
				return 1; // 掴み成功
			}
		}
		else
		{
			if( Def_Dbg_SkillThrowLog ) _dpn("【連絡】掴んではいるけどダメージ状態じゃなかった");
			return 0;
		}
	}
	else //つかんでいないとダメ
	{
		//打撃投げをガードされたりしてもここにくる
		//_dm("投げがヒット…したはずだが掴めなかった");
		//print("【連絡】つかみ失敗");
		return 0;
	}
	return 0;
}



//つかみ中の相手が地面に埋まってたら補正をかけるだけ（なんか別のと一緒にしよう）
Battle_Std.CaptureChara_Positioning <- function()
{
	//演出中地面に埋まってるようだったら微調整
	local cp = BMvCore.GetCaptureCharaData();
	//有効だったら＝つかまれ中だったら
	if( cp.IsDone )
	{
		BMvCore.PushCharaData( cp ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			if( pos.y>0 )
			{
				BMvTbl.SetPosition({ y=0, }); //座標を変更
			}
		BMvCore.PopCharaData(); //				
	}
}

//攻撃判定が触れていてかつダメージ状態かチェック
//これもう使うべきではない
Battle_Std.CheckHanteiDamage <- function()
{
	local s = BMvTbl.GetMvHitStatus();
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc  } );
	if (s.Type & _HitType_Damage && enemy.IsDone )
	{
		return 1;
	}
	return 0;
}

//ヒットステータスが入ったPPを取得するだけ
Battle_Std.GetPP_HitStatus <- function( slot = 0 )
{
	//ヒットしたら親の変数を操作する
	local ret = BMvTbl.GetPP(slot);
	//_dm("GetPP_HitStatus:スロット:"+slot+" 値:"+ret);
	return ret;
}

//ヒットステータスをPPに入れるだけ
Battle_Std.SetPP_HitStatus <- function( slot = 0 )
{
	//ヒットしたら親の変数を操作する
	local hs = BMvTbl.GetMvHitStatus();
	
	BMvTbl.SetPP(slot, hs.Type);
}

//PPに入れたヒットステータスを初期化する（単にPPを0で上書きするだけ）
Battle_Std.SetPP_ClearHitStatus <- function( slot = -1 )
{
	//ヒットしたら親の変数を操作する
	BMvTbl.SetPP(slot, 0);
	//_dm("SetPP_ClearHitStatus:初期化");
}


//きりもみやられ共通回転処理
local func_kirimomi_kaiten = function( mvs )
{
	if( mvs.MvCount > 0 && mvs.FrameID==100 )
	{
		BMvTbl.Frame_Proc( (mvs.DataFrame+1), _ValSet );
		local s = BMvTbl.GetMvStatus();
		if( s.FrameID!=100 )
		{
			BMvTbl.JumpFrameID(100); //100のループの最初に戻る
			local s = BMvTbl.GetMvStatus();
			BMvTbl.Frame_Proc( (s.DataFrame+1), _ValSet ); //ズレるので１つ進める
		}
	}	
}

// BoundInit()とMv_Bound_CaptureのInitで呼ばれる
Battle_Std.DrawPunishAnnounce <- function( anno_flags )
{
	//_dpn("DrawPunishAnnounce()");
	//やられアナウンス処理
	//だったけど、色々ごちゃごちゃになってきている
	local enemy = BMvCore.GetEnemyCharaData();

	local counter_anno_word = 0; // 0:アナウンスなし　1:カウンター（PG処理に移して廃止）　2:パニッシュ
	if( anno_flags&def_PP_IA_Punish )
	{
		// _dpn("パニッシュアナウンス");
		counter_anno_word = 2;
		BMvTbl.DamageFlag_Func( def_DF_SidouPunish, _ValAdd );
	}
	
	if( anno_flags&def_PP_IA_Counter )
	{
		// _dpn("カウンターっぽい");
		counter_anno_word = 0; // 消す
		BMvTbl.DamageFlag_Func( def_DF_SidouCounter, _ValAdd );
	}
	
	if( anno_flags&def_PP_IA_NoCounterCounter )
	{
		_dpn("カウンターしない技でのカウンターっぽい");
		counter_anno_word = def_AISW_Counter; // 通常アナウンスレベルでカウンターを呼ぶ
	}

	if( counter_anno_word )
	{
		//相手（攻撃）側にアナウンス表示
		if( enemy.push() )
		{
			if( counter_anno_word == 2 )
			{
				BMvEff.SetPunishAnnounce();
			}
			else
			{
				BMvEff.AttackInfoString_Set( { word = counter_anno_word } );
			}
			enemy.pop();
		}
	}
	
	// その他アナウンス
	if( anno_flags&def_PP_IA_BarrierBreached )
	{
		BMvEff.AttackInfoString_Set({ word=def_AISW_BarrierBreached,} );
	}	
	
}

//やられのInitでやる処理
//ベクトル移行でなっちゃうからバウンドの時とかも入ってくるから注意
Battle_Std.BoundInit <- function() : (func_kirimomi_kaiten)
{
	//_dpn("[BoundInit]");
	local anno_flags = BMvTbl.GetPP(def_PP_ImpactAnnounce);
	BMvTbl.SetPP(def_PP_ImpactAnnounce,0);//すぐ初期化
	
	Battle_Std.DrawPunishAnnounce( anno_flags ); //やられアナウンス処理
	
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( player.isdone() )
	{
		local flag_isGroundFatal = false;
		local flag_isGroundBound = false;
		local flag_isKirimomi = false;
		local flag_isKirimomiSui = false;
		local mvs = BMvTbl.MvStatus();

		if( player.push() )
		{
			flag_isGroundFatal = (BMvTbl.CheckPattern([303,304,305,306,307,308])==1); //地上強やられからきた？
			flag_isGroundBound = (BMvTbl.CheckPattern([300,301,302,303,304,305,306,307,308])==1); //地上やられからきた？
			flag_isKirimomi = (BMvTbl.CheckPattern([333])==1); //きりもみからきた？
			flag_isKirimomiSui = (BMvTbl.CheckPattern([334])==1); //垂直きりもみからきた？
			mvs = BMvTbl.GetMvStatus();
			
			player.pop();
		}
		
		local now_cp = 0;
		local is_sp_damage = 0; // 敵の行動が超技かどうか。超技中はやられボイスなし
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local skillmove = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) );
			local spmove = ( Battle_Std.MvAction.CheckFlag( def_MC_SPAction ) );
			now_cp = BMvTbl.ComboPoint_Calc( { num=0 } );//今のCP
			
			enemy.pop();
			
			if( skillmove && spmove )
			{
				is_sp_damage = 1;
			}
		}		
		
		

		//local test = BMvTbl.CheckPattern(304);
		//_dm("test:304"+test);

		//_dm("flag:"+flag_isGroundFatal+" 地上やられから？:"+flag_isGround);
		//local s = BMvTbl.GetMvStatus(); // ステータス取得
		//_dm("パターン番号:"+s.DataPattern);

		
		BMvEff.CutInProc_Erase(); //カットインがあったら消去する
		
		local last_bs = BtlMvStd.GetBoundStatus(); //食らう直前のバウンド情報取得
		
		//食らう前の状態がつかみだったらベクトル初期化をしない
		//つかまれ中じゃなかったらベクトル初期化をする
		if( !last_bs.isCapture )
		{
			//つかみ中はやられても動かないので初期化もしない
			Battle_Std.InitVector(); // ベクトル初期化
		}
		
		//---------------------------------------------------------------------
		// ここからベクトル設定
		//---------------------------------------------------------------------
		BtlMvStd.SetBoundStatus(); //ベクトル情報を入れる
		
		local bs = BtlMvStd.GetBoundStatus();
		local bs_isbound = bs.isBound;
		local isFirstBoundTbl = (bs_isbound && bs.VecCount==0); //ベクトルテーブルの最初かどうか
		local bs_power = (bs_isbound)? bs.Power : 0;

		// やられボイス再生処理
		if( isFirstBoundTbl ) //定義してるテーブルの最初のBoundでしか声を出さない
		{
			local sound_st = BMvTbl.GetPP(def_PP_SoundStatus);
			if( sound_st&def_PP_SS_NoBoundVoice )
			{
				//ボイス再生禁止フラグがたっています
				// dm("やられボイス禁止フラグあり");
			}
			else if( sound_st&def_PP_SS_NoBoundVoiceOnce )
			{
				BMvTbl.SetPP( def_PP_SoundStatus, sound_st&~def_PP_SS_NoBoundVoiceOnce ); // フラグ消去
				
				//_dp("\n def_PP_SS_NoBoundVoiceOnce:"+def_PP_SS_NoBoundVoiceOnce);
			}
			else if( !is_sp_damage ) // 超技中は鳴らさない
			{
				// _dm("pow:"+bs.Power+" def_BS_Pow_LV2"+def_BS_Pow_LV2);
				// bs_powerの定数、「def_BS_Pow_LV2 = 0」なのでフラグチェックでは使わないこと
				
				if( bs_power&def_BS_Pow_LV3 )
				{
					// 強
					Battle_Std.TypeSE_Play({ type="やられ強" });
				}
				else if( bs_power&def_BS_Pow_LV1 )
				{
					// 弱
					Battle_Std.TypeSE_Play({ type="やられ弱" });	
				}
				else if( bs_power&def_BS_Pow_LV0 )
				{
					// 声無し
				}
				else
				{
					// 中
					Battle_Std.TypeSE_Play({ type="やられ中" });	
				}
			}
		}

		//ベクトルテーブルの最初かつつかまれ中以外なら振り向き処理を行う
		if( isFirstBoundTbl && !bs.isCapture )
		{
			if( bs_power&def_BS_Pow_Furimuki )
			{
				Battle_Std.SetMuki_ReverseEnemy( 0 ); //相手と反対の向きを向く　0:殴られ相手 1:殴られ親
			}
			else
			{
				Battle_Std.SetMuki_ReverseEnemy( 1 ); //相手と反対の向きを向く　0:殴られ相手 1:殴られ親
			}
		}
		//print("\n isFirstBoundTbl:"+isFirstBoundTbl);

		if( BMvTbl.CheckPosState( _PosState_Ground )) //地上やられの時
		{
			//_dm("地上やられ？");
			//if( flag_isGroundBound ) BMvTbl.SetMuki( _Direction_Auto ); //地上やられからきた地上やられなら振り向く
			if( flag_isGroundFatal )
			{
				if( BMvTbl.CheckPattern( 300 ) ) BMvTbl.SetPattern(303);
				else if( BMvTbl.CheckPattern( 301 ) ) BMvTbl.SetPattern(304);
				else if( BMvTbl.CheckPattern( 302 ) ) BMvTbl.SetPattern(305);
			}
		}
		
		//きりもみのループ中はヒットのたびに回転するみたいな
		if( flag_isKirimomi ) // きりもみ吹き飛び
		{
			if( BMvTbl.CheckPattern( 333 ) ) func_kirimomi_kaiten( mvs );
		}
		else if( flag_isKirimomiSui ) //垂直きりもみ
		{
			if( BMvTbl.CheckPattern( 334 ) ) func_kirimomi_kaiten( mvs );
		}
		
		//始動技のやられかどうか見る
		//処理が余りので、isFirstBoundTblのとき以外はちゃんと機能しない
		//（叩きつけではねている時、相手の状況は不明のため）
		local isSidou = 0;
		if( isFirstBoundTbl )
		{
			local enemy = BMvCore.GetLastDamageCharaData( 0 );//最後に殴られたキャラ
			if( enemy.push() )
			{
				BMvTbl.SetPP(def_PP_WeakBreakDamageHosei,0); // 保険で初期化
				isSidou = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技
				if( Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_FromSidouAddSkill ) )
				{
					isSidou = 1;
				}
				
				if( !isSidou && !enemy.isPlayer() ) // 始動じゃないっぽいとき＆オブジェクトのようだ
				{
					// さらに生み出し親まで見に行く
					if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
					{
						local oya_main = BMvCore.GetPlayerCharaData();
						if( oya_main.push() )
						{
							local is_player_sidou_skill = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技
							if( Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_FromSidouAddSkill ) )
							{
								is_player_sidou_skill = 1;
							}
							oya_main.pop();
							
							// _dpn("is_player_sidou_skill:"+is_player_sidou_skill);
							if( is_player_sidou_skill )
							{
								isSidou = 1; // 始動扱いにする
							}
						}
					}
				}
				enemy.pop();
			}
		}
		
		// 特殊な浮きに対してCPに応じたボーナスを乗せる
		// 今までより変わったコンボが作れるようにするための仕組み
		if( isFirstBoundTbl )
		{
			BMvTbl.SetPP(def_PP_BoundInitStatus,0); // 初期化
		}
		if( isSidou )
		{
			Battle_Std.PP_AddFlag(def_PP_BoundInitStatus,def_PP_BIS_SidouStart); // 始動技扱い
		}
		
		local isSidouVector = Battle_Std.PP_CheckFlag(def_PP_BoundInitStatus,def_PP_BIS_SidouStart); // このやられベクトルは始動技から始まったものかどうか
		
		// _dpn("isSidou:"+isSidou+" isSidouVector:"+isSidouVector+" isFirstBoundTbl:"+isFirstBoundTbl);
		
		if( Def_Sys_BoundTableUkemiCPBonus && !isSidouVector ) // 始動を含めるととんでもバウンドから拾ってくる
		{
			local enable = 0;
			if( isFirstBoundTbl )
			{
				// １つ目のベクトルの受け身不能時間がCPで大きく変わる
				// 再帰浮き系と固定落下（ロンドレキア）
				if( bs_power&def_BS_Pow_ReflexCPHosei )
				{
					// _dpn("1つ目ベクトルボーナス");
					enable = 1;
				}
				
			}
			else
			{
				// バウンドボーナスは１つのベクトル中に１回だけ
				if( !Battle_Std.PP_CheckFlag(def_PP_BoundInitStatus,def_PP_BIS_BoundCPHoseiSeted) )
				{
					// ２つ目のベクトルの受け身不能時間がCPで大きく変わる
					// 叩きつけるバウンド系と呪縛浮きやウェブ浮き
					if( bs_power&def_BS_Pow_BoundCPHosei )
					{
						// _dpn("２つ目ベクトルボーナス");
						Battle_Std.PP_AddFlag(def_PP_BoundInitStatus,def_PP_BIS_BoundCPHoseiSeted)

						enable = 1;
					}
				}
			}
			
			if( enable )
			{
				local CP_UkemiBonus =[
				{ num=50, add=  6 }, // 100〜
				{ num=40, add=  4 }, //
				{ num=30, add=  2 }, //
				{ num=15, add=  0 }, // 
				]				
				
				// _dpn("now_cp:"+now_cp);
				
				local add_ukemitime = 0;
				
				// 加算する受け身不能時間を計算
				local tbl_lv = 0;
				if( now_cp >= CP_UkemiBonus[CP_UkemiBonus.len()-1].num )
				{
					for( local i=0; i<CP_UkemiBonus.len(); i++ )
					{
						if( now_cp >= CP_UkemiBonus[i].num )
						{
							add_ukemitime = CP_UkemiBonus[i].add;
							tbl_lv = i;
							break
						}
					}
				}
				
				_dpn("★V CPHosei CP:"+now_cp+"["+tbl_lv+"] 受け身:"+add_ukemitime);
				
				BMvEff.SetUkemiTime( { addtime = add_ukemitime } );
			}
		}
		
		if( Def_Sys_CVO_AddUkemiTime )
		{
			// CVOの効果中は受身不能時間が長い
			// CVO中に殴られたベクトルかどうか、で本当は取らないとダメかも

			// 以下のDamageFlag取得だけだと、CVO出してIWやったあとも効果が続くし、CVO始動のコンボだけ影響がある
			// 流石にゲージが無くなったら終わるようにチェックを厳密に（∞コンボになってしまう）
			// local ret = BMvTbl.DamageFlag_Func( def_DF_SpHosyoHoseiSeted_CVO, _ValCheck ); // 0 or 1
			
			{
				// 処理を軽くするためにまずは↑でチェック
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					//CVO状態かどうかを取得する
					local is_cvo = ( BMvEff.Liberate_GetType() == _LiberateType_Combo )? 1 : 0;
					local now_cp = BMvTbl.ComboPoint_Calc( { num=0 } );//今のCP
				
					enemy.pop();
					
					if( is_cvo )
					{
						local CP_UkemiBonus =[
						{ num=64, add=  6 }, // 100〜64
						{ num=50, add=  5 }, //
						{ num=38, add=  4 }, //
						{ num=24, add=  3 }, //
						{ num=12, add=  2 }, //
						]
						
						local add_ukemitime = 0;
						
						// 受け身不能時間を増やす処理
						if( now_cp >= CP_UkemiBonus[CP_UkemiBonus.len()-1].num )
						{
							for( local i=0; i<CP_UkemiBonus.len(); i++ )
							{
								if( now_cp >= CP_UkemiBonus[i].num )
								{
									add_ukemitime = CP_UkemiBonus[i].add;
									break
								}
							}
						}
						_dpn("CVOボーナス CP"+now_cp+" 受身不能:"+add_ukemitime);
						if( add_ukemitime > 0 )
						{
							BMvEff.SetUkemiTime( { addtime = add_ukemitime } );
						}
					}
				}
			}
		}
	}
}

Battle_Std.BoundUpdate <- function()
{
	local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
	BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep } ); // 几帳面に記憶しておく
	
	//地上状態では符号が反転しないようにする
	if( BMvTbl.CheckPosState( _PosState_Ground  ) )
	{
		//今プラスのベクトルで、次のフレームがマイナスベクトルか？
		//print(format("\n x:%d addx:%d",vec.x, vec.addx));
		if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
		{
			BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
		}
	}
}


//飛び道具同士の相殺を実現するためのもの色々

//飛び道具の初期設定
//弾制限があればつける
Battle_Std.InitFireBallStatus <- function( _flags = 0 )
{
	BMvTbl.SetLPEx(1,def_LP1_MvType, def_MvType_Ball);	//俺が飛び道具だ
	BMvTbl.SetLPEx(1,def_LP1_BallFlags, _flags ); // フラグ関係初期化（指定があったらそれになるけど）
	
	local ball = BMvTbl.GetLPEx(1,def_LP1_BallSlot); //LPの値の飛び道具制限数を操作する
	if(ball != -1)
	{
		BMvTbl.TobiParam_Func( { slot=ball, val=1, type=_ValAdd } );
	}
	BMvEff.ClearAttackHitNum(); //いちおう	
	Battle_Std.ClearBallFlags(def_BallFlags_Finalize); //次回ファイナライズフラグはなくす(?)
	// ヒットを親に伝える
	if( Def_Rule_ToParentFireBallHitStatus ) BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
}

//飛び道具属性を解除して弾制限があればそれも消す
Battle_Std.ClearFireBallStatus <- function()
{
	if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_FB_StatusCleared ) )
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_FB_StatusCleared );
		BMvTbl.SetLPEx(1,def_LP1_MvType, def_MvType_Normal); //飛び道具属性だったのを無属性にする
		local ball = BMvTbl.GetLPEx(1,def_LP1_BallSlot); //LPの値の飛び道具制限数を操作する
		if(ball != -1)
		{
			BMvTbl.TobiParam_Func( { slot=ball, val=-1, type=_ValAdd } );		
		}
		Battle_Std.ClearBallFlags(def_BallFlags_Finalize); //次回ファイナライズフラグはなくす
	}
}

// 飛び道具の属性を消すときに呼ばれる
// ヒットやガードの後、ヒット数0になったあと、着地した後、被弾したあと
Battle_Std.VanishFireBallStatus <- function()
{
	Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
	Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_FB_Vanish );
}


//飛び道具ステータスを取得
Battle_Std.GetFireBallStatus <- function()
{
	local isSousaiYarareObject = Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_CheckSousaiYarareObject ); // 飛び道具と相殺する壊せるオブジェクト
	local tbl = {};
	local mvtype = BMvTbl.GetLPEx(1,def_LP1_MvType);
	tbl.isFireBall <- (mvtype == def_MvType_Ball); //自分が飛び道具かどうか
	tbl.isYarareObject <- isSousaiYarareObject;
	tbl.HitCount <- BMvTbl.CalcHitValue(0); //残りのヒット回数を取得する
	tbl.isSousaiSubHited <- Battle_Std.GetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺したよフラグがたっているかどうか
	tbl.MvCode <- BMvTbl.GetMoveCode();
	tbl.isBeforeFireBallInit <- !Battle_Std.MoveCode.CheckFlag( def_MC_FireBall ); // 行動コード(飛び道具) // Init通過後かどうか

	tbl.isGamenGai <- Battle_Std.CheckGamenGai( 100*128 ); // 画面外にある　少しマージンあり
	
	// 未指定でも１発は相殺する
	if( tbl.HitCount == 0 && tbl.isYarareObject ) tbl.HitCount = 1;
	
	return tbl;
}

Battle_Std.GetFireBallFlags <- function( flag )
{
	local ret = ((BMvTbl.GetLPEx(1,def_LP1_BallFlags)&flag)!=0);
	return ret;
}

Battle_Std.CheckFireBallFlags <- function( flag )
{ 
	return ( BMvTbl.GetLPEx(1,def_LP1_BallFlags)&flag )? 1 : 0;
}

Battle_Std.AddFireBallFlags <- function( flag )
{
	BMvTbl.SetLPEx(1,def_LP1_BallFlags,( BMvTbl.GetLPEx(1,def_LP1_BallFlags)|flag) );
}

Battle_Std.SetFireBallFlags <- function( flag )
{
	Battle_Std.AddFireBallFlags( flag );
}

Battle_Std.ClearBallFlags <- function( flag )
{
	BMvTbl.SetLPEx(1,def_LP1_BallFlags,( BMvTbl.GetLPEx(1,def_LP1_BallFlags)&~flag) );
}


// これで呼ぶと、相殺時などにLPが勝手に操作されたりするので注意
// 必ずMv_FireBall_*** なMvを呼び出すこと（tmpl自動生成とワンセット）
function Battle_Std::CreateFireBall( t )
{
	/*
	tableメモ
	x 発射Xツール座標
	y 発射Xツール座標
	mv だすMvの名前（指定が無いと親のMv+"_FireBall"）
	varslot Mvに伝える変数LPスロット
	varvalue スロットに入れる値
	angle 初期回転角（見た目・内部）
	pat 表示するパターン
	vec{ x, y, addx, addy} ベクトル
	ball eff6-100 101用
	
	initfunc : 最初にやっておきたい関数
	
	LP = { slot=0, val=0, }
	
	flags:FireBallStatusに最初に入れる値
	create_flags : 生成時の何か 
	
	*/
	
	local px = ("x" in t)? t.x : 0;
	local py = ("y" in t)? t.y : 0;

	local mv = ("mv" in t)? t.mv : (BMvTbl.GetMvName() + "_FireBall");	
	local id = ("id" in t)? t.id : 0; // 生成時のfind用id
	
	local ang = ("angle" in t)? t.angle : 0;
	
	local oyamuki_isRight = ( BMvTbl.GetMuki() == 1 )? true : false ;
	
	local fbs_flags = ("flags" in t)? t.flags : 0; // FireBallStatusの初期フラグ設定

	local eff = BMvEff.CreateObject( { x=px, y=py, mvname=mv, flags=_Position_ToolShift, id=id } );
	if( eff.push() )
	{
		if ("LP" in t ) BMvTbl.SetLP(t.LP.slot, t.LP.val);
		if ("varslot" in t && "varvalue" in t) BMvTbl.SetLP(t.varslot, t.varvalue);

		BMvTbl.SetAngle( {angle=ang} );
		if ("pat" in t) BMvTbl.SetPattern(t.pat);
		if ("vec" in t) BMvTbl.SetVector(t.vec);
		if ("vec_maxx" in t) BMvTbl.SetVector_MaxX( t.vec_maxx );
		("ball" in t)? BMvTbl.SetLPEx(1,def_LP1_BallSlot, t.ball) : BMvTbl.SetLPEx(1,def_LP1_BallSlot, -1);
		Battle_Std.InitFireBallStatus( fbs_flags ); //飛び道具扱いのMvへの初期設定
		( oyamuki_isRight )? BMvTbl.SetMuki( _Direction_Right ) : BMvTbl.SetMuki( _Direction_Left ) ; //意味ある？無い？
		if( "initfunc" in t ) t.initfunc();
		
		eff.pop();
	}
	
	return eff; //作成したオブジェクトを返す
}



//角度とスピードとフレームを指定してベクトルテーブルを返す
function Battle_Std::GetVector_FromAngle( t )
{
	//angle_vec = { angle=2500, power=8000, time=10, flags=_Vector_Div }
	/*
	t.angle : 角度0-10000
	t.speed : 速度
	t.endspeed : frame経過時のspeed（ 0なら収束するし、でかけりゃ加速する）
	t.frame : フレーム
	
	t.flags
	
	0.0〜2.0
	
	0〜200/100
	
	*/
	local ret = 0;
	local a = ( (("angle" in t)? t.angle : 0) /10000.0)*2.0;
	local endspeed = ("endspeed" in t)? t.endspeed : 0;
	
	local vec = BMvEff.GetVector_FromAngle( { angle = a, speed = t.speed } );
	if( "frame" in t )
	{
		local spd = (endspeed-t.speed)/t.frame;
		local add = BMvEff.GetVector_FromAngle( { angle = a, speed = spd } );
		ret = { x=vec.x, y=vec.y, addx=add.x, addy=add.y, flags=("flags" in t)? t.flags: 0 };	
	}
	else
	{
		ret = { x=vec.x, y=vec.y, flags=("flags" in t)? t.flags: 0 };		
	}
	return ret;	
}


// 相殺新仕様（相殺したい、されたいオブジェクトからは全部これが呼ばれる）
// 自分と相手同じ処理になっていないとダメ（１Ｐ、２Ｐどっちが先でもおかしくならないように）
// 相殺に対して何かする場合は、　def_MC_Sousai_EnemySubSuccess　をチェックする
// 壊せる設置物の場合は　def_MC2_YarareObject_AnySousai　を見て処理をしている（ヒット数減算しないタイプでも消滅処理をするため）
// なのでこの関数は何も返さない（戻り値を見て処理する＝処理が対等でない）
// 時々相殺に失敗する（ベクトルが巨大なオブジェクトだったりするとそうなる）
// 攻撃判定同士でしか相殺できないが、試しに特殊判定３（飛び道具判定）とも相殺するようにした

// 相殺関係の仕様まとめ（CheckSousaiが呼ばれるもの）
// 飛び道具（FireBall）　攻撃判定のみ
// 本体飛び道具（トナム236X）　攻撃判定のみ
// 飛び道具相殺技（ワレンのJC/エンキ4C）　飛び道具判定と攻撃判定　発生前とかに飛び道具判定がついている
// 壊せる設置物（シデウス/蜘蛛罠）　やられ判定＋飛び道具判定　飛び道具との相殺のためだけに飛び道具判定がついている

// エンキ4C＋壊せる設置物
// 攻撃判定/飛び道具判定　＋　飛び道具判定/やられ判定
// 攻撃判定がやられに触れると、設置物は壊れる
// 飛び道具判定が、飛び道具判定に触れると…何もおきてほしくないので除外する

Battle_Std.CheckSousai <- function()
{
	// _dpn("CheckSousai():"+BMvTbl.GetPlayerSide() );
	// A x A
	// A x E
	// E x A
	// E x E = NG
	// 相殺判定のみでは何もしない
	
	// 相手の何らかのオブジェクトの攻撃判定と触れているか
	local enemy = BMvEff.CheckHantei2( { src=[ [ _Hantei_Attack , 0, -1 ], [ _Hantei_Etc , 3, 1 ] ], dst=[ [ _Hantei_Attack , 0, -1 ], [ _Hantei_Etc , 3, 1 ] ], flags=_HC_EnemyPc|_HC_EnemyObj } );
	
	if( enemy.push() )
	{
		// _dpn("何かしら触れた");
		
		local ets = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得

		enemy.pop();

		local pts = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得
		
		// _dpn("CheckSousai():"+BMvTbl.GetPlayerSide() );
		
		local play_se = 0; // 相殺でＳＥを再生するかどうか
		
		// お互い相殺されるだけの存在は処理をしない
		if( pts.isYarareObject && ets.isYarareObject )
		{
			return;
		}
		
		// どちらかが相殺されるだけの存在
		if( pts.isYarareObject || ets.isYarareObject )
		{
			if( pts.isGamenGai || ets.isGamenGai )
			{
				_dpn(" 相殺されるオブジェクトが絡むときは画面外で処理をしない")
				return;
			}
		}
		
		// 飛び道具判定同士では何も起こさない
		// 今までよくこれなくて大丈夫だったな…というかダメだった
		local sousai_type0 = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Attack , 0, -1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );
		local sousai_type1 = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Etc , 3, 1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );
		local sousai_type2 = BMvEff.CheckHantei( { src=[ _Hantei_Etc , 3, 1 ], dst=[ _Hantei_Attack , 0, -1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );
		if( !sousai_type0.isdone() && !sousai_type1.isdone() && !sousai_type2.isdone() )
		{
			_dpn(" 飛び道具判定同士なので処理をしない");
			return;
		}
		
		
		// def_MC_Sousai　同士で触れていて、かつヒット数が残っていたら相殺する
		
		// _dpn( format("pts:"+pts.isFireBall+" "+(pts.MvCode&def_MC_Sousai)+" "+pts.isYarareObject+" "+pts.HitCount+" B:"+pts.isBeforeFireBallInit ) );
		// _dpn( format("ets:"+ets.isFireBall+" "+(ets.MvCode&def_MC_Sousai)+" "+ets.isYarareObject+" "+ets.HitCount+" B:"+ets.isBeforeFireBallInit ) );
		
		if (
		( (ets.MvCode&def_MC_Sousai || ets.isYarareObject ) && pts.HitCount>0 ) &&
		( (pts.MvCode&def_MC_Sousai || pts.isYarareObject ) && ets.HitCount>0 ) ) //相殺するオブジェクト同士で触れた
		{
			// _dpn(" 自分側の処理");
			if( (pts.MvCode&def_MC_Sousai_NoSubHitCount)==0 ) // 相殺時に自分のヒット数を減算しない、ではない
			{
				local init_hitcount = BMvTbl.CalcHitValue(0); // 相殺前の残りヒット数
				local left_hitcount = BMvTbl.CalcHitValue(-ets.HitCount); //相手の飛び道具ヒット数分、ヒット数を減らす
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Sousai_MySubSuccess ); // 相殺で自分のヒット数減算に成功した
				
				if( init_hitcount != left_hitcount ) play_se = 1; // 相殺で残りヒット数が変化した=何か相殺した
				
				if( pts.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
				{
					Battle_Std.SetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺でヒット数が減ったことを記憶
					if( left_hitcount <=0 )
					{
						// _dpn("次回ファイナライズ予約");
						Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
					}
				}

				// 相手側
				if( enemy.push() )
				{
					// _dpn("  相殺でヒット数減算に成功");
					Battle_Std.MoveCode.AddFlag( def_MC_Sousai_EnemySubSuccess ); // 相殺で相手のヒット数減算に成功した
					if( ets.isYarareObject )
					{
						Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_YarareObject_AnySousai ); // 雑に相殺してる
					}
					
					enemy.pop();
				}
			}
			else if( ets.isYarareObject )
			{
				// 相手がやられオブジェクトの場合は、def_MC_Sousai_NoSubHitCountがあっても、設置が消えて欲しいので処理を追加
				if( enemy.push() )
				{
					// _dpn("  雑には相殺してそう");
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_YarareObject_AnySousai ); // 雑に相殺してる
					
					enemy.pop();
				}
			}
			
			// _dpn(" 相手側の処理");
			if( (ets.MvCode&def_MC_Sousai_NoSubHitCount)==0 ) // 相殺時に自分のヒット数を減算しない、ではない
			{
				if( enemy.push() )
				{
					local init_hitcount = BMvTbl.CalcHitValue(0); // 相殺前の残りヒット数
					local left_hitcount = BMvTbl.CalcHitValue(-pts.HitCount); //自分のヒット数分、ヒット数を減らす
					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Sousai_MySubSuccess ); // 相殺で自分のヒット数減算に成功した
					
					if( init_hitcount != left_hitcount ) play_se = 1; // 相殺で残りヒット数が変化した=何か相殺した
					
					if( ets.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
					{
						Battle_Std.SetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺でヒット数が減ったことを記憶
						if( left_hitcount <=0 )
						{
							//_dpn("次回ファイナライズ予約");
							Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
						}
					}
					enemy.pop();
				}

				// 自分側
				{
					// _dpn("  相殺でヒット数減算に成功");
					Battle_Std.MoveCode.AddFlag( def_MC_Sousai_EnemySubSuccess ); // 相殺成功フラグをたてる
					if( pts.isYarareObject )
					{
						Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_YarareObject_AnySousai ); // 雑に相殺してる
					}
				}
			}
			else if( pts.isYarareObject )
			{
				// 相手がやられオブジェクトの場合は、def_MC_Sousai_NoSubHitCountがあっても、設置が消えて欲しいので処理を追加
				{
					// _dpn("  雑には相殺してそう");
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_YarareObject_AnySousai ); // 雑に相殺してる
				}
			}			
			// 二重に再生されるけど気にしない　※二重にならなくなったかも？
			if( play_se )
			{
				BSound.SE_Play( { type=_SeType_Normal, num=195 } );
			}
		}
		// _dpn("CheckSousai End");
	}
}

//Mvでよく使う関数登録


//全てのベクトルを消す　保存ベクトルも消える　X MAXも初期化する 
function Battle_Std::InitVector()
{
	BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_Keep|_Vector_DivKeep } );	
	BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
	BMvTbl.ClearTriVector( { x=0, y=0 } ); //Triを初期化
}

//慣性を残したベクトル初期化（地上の通常技や必殺技のでかかりとか）
//判定ツールのInitとほぼ同じ？
function Battle_Std::InitCharaVector()
{
	BMvTbl.SetVector_CCharaVector( BMvTbl.CCharaVector(), 0 );
	BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化 _Vector_Normalしか影響しないので消さないと不味そう
	BMvTbl.ClearTriVector( { x=0, y=0 } ); //Triを初期化
}


//自分 相手の配置なら０，違ったら１を返す（１P側で0、2P側で1）
function Battle_Std::GetPositionSide()
{
	local pos1 = BMvTbl.GetPosition(0);
	local pos2 = Battle_Std.GetEnemyPosition();
	return (pos2.x>pos1.x)? 0 : 1;
}

//相手操作親に座標を与える
//相手に対してSetPositionする
function Battle_Std::SetEnemyPosition(tbl)
{
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	if(enemy.IsDone)
	{
		BMvCore.PushCharaData( enemy ); // 
			BMvTbl.SetPosition( tbl ); //
		BMvCore.PopCharaData(); // 
		return 1;
	}
	else
	{
		return 0; //敵取得失敗
	}
}

//相手操作親の座標テーブルを返す
//相手に対してGetPositionする
function Battle_Std::GetEnemyPosition()
{
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		local epos = BMvTbl.GetPosition(); // 位置取得
		
		enemy.pop();
		return epos;
	}
	else
	{
		// _dm("【警告】GetEnemyPositionで相手座標取得失敗")
		local pos = BMvTbl.CCharaPosition();
		return pos; //敵取得失敗したけど仮座標を返す
	}
}

function Battle_Std::GetPlayerPosition()
{
	local player = BMvCore.GetPlayerCharaData(); // 敵情報を得る
	if( player.push() )
	{
		local epos = BMvTbl.GetPosition(); // 位置取得
		
		player.pop();
		return epos;
	}
	else
	{
		// _dm("【警告】GetPlayerPositionで相手座標取得失敗")
		local pos = BMvTbl.CCharaPosition();
		return pos; //敵取得失敗したけど仮座標を返す
	}
}

Battle_Std.GetEnemyVector <- function( tbl )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local evec = BMvTbl.GetVector( tbl );
		
		enemy.pop();
		return evec;
	}
	return BMvTbl.CCharaVector();
}

//相手の座標のツール座標を返す
//相手との距離を見るのには使っちゃダメ
//相手の位置にエフェクトを出したり…距離がマイナスだとダメみたい
//使える
//_Position_ToolShift	--- x,y座標をHAN6上の設定値にする、HAN6値 = 実座標/128 となる。
//_Position_ChangeMuki	--- 向きによるX座標の符号反転を行う
// Battle_Std.GetNearEnemyDistance({flags=_Position_ToolShift})
// Battle_Std.GetNearEnemyDistance({flags=_Position_ToolShift|_Position_ChangeMuki})
Battle_Std.GetNearEnemyDistance <- function(tbl={})
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.IsDone ) // 有効かどうか一応チェック
	{
		local throw_param = {};
		if("capture_pos" in tbl)
		{
			switch( tbl.capture_pos )
			{
			case "頭":
				throw_param.hantei_rect <- [ _Hantei_Etc, 9 ];
				break;
			case "首":
				throw_param.hantei_rect <- [ _Hantei_Etc, 10 ];
				break;
			case "腹":
				throw_param.hantei_rect <- [ _Hantei_Etc, 11 ];
				break;
			case "足":
				throw_param.hantei_rect <- [ _Hantei_Etc, 12 ];
				break;
			}
		}


		//tbl.flags = {}
		local flag_Position_ToolShift = false;
		local flag_Position_ChangeMuki = false;
		if("flags" in tbl)
		{
			if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
			if( tbl.flags & _Position_ChangeMuki ) flag_Position_ChangeMuki=true;
		}
		
		//print("\n結果"+flag_Position_ToolShift+flag_Position_ChangeMuki);

		local ret_tbl = {};
		ret_tbl.IsDone <- false;
		
		local target_pos = BMvTbl.CCharaPosition(); // ターゲットにするもの


		local posst;		
		if( "hantei_rect" in throw_param )
		{
			//local pos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			BMvCore.PushCharaData( enemy ); // 
				local rc = BMvEff.GetHanteiRect( { check=throw_param.hantei_rect, flags=_HanteiFlag_NoMukiChange } );
			BMvCore.PopCharaData();
			if( rc.sx== _Hantei_Error)
			{
				// _dem("GetNearEnemyDistance:つかむ位置がみつからない");
			}
			else
			{
				// _dm(format("GetNearEnemyDistance掴み座標: x:%d y:%d",rc.sx, rc.sy) );
			}
			target_pos.x = rc.sx;  target_pos.y = rc.sy;
		}
		else
		{
			target_pos = Battle_Std.GetEnemyPosition();
		}
		
		//ターゲットまでの距離とかを
		posst = BMvEff.GetPointStatus( { position=target_pos } );
	
		ret_tbl.x <- flag_Position_ToolShift? (posst.distance_x/128).tointeger() : posst.distance_x;
		ret_tbl.y <- flag_Position_ToolShift? (posst.distance_y/128).tointeger() : posst.distance_y;
		ret_tbl.IsDone = true;

		//1P 2Pの位置関係の時、右向き
		//2P 1Pの位置関係のとき、左向き、ならプラスの値
		if( flag_Position_ChangeMuki )
		{
			local player_side = Battle_Std.GetPositionSide();
			if( player_side==0 ) //1P側
			{
				if(BMvTbl.GetMuki()==-1) ret_tbl.x *= -1;
			}
			else
			{
				if(BMvTbl.GetMuki()==1 ) ret_tbl.x *= -1;		
			}
		}
		//distanceなので、ターゲットより自分が下にいたらマイナスにする
		local pos1 = BMvTbl.GetPosition(0);
		if( target_pos.y<pos1.y ) ret_tbl.y *= -1;	
		
		return ret_tbl;
	}
	else
	{
		// _dm("【警告】GetNearEnemyDistanceで相手がいない");
		local pos = BMvTbl.CCharaPosition();
		return pos;
	}
}

//相手のツール座標を返す
//相手の位置にエフェクトを出したりする専用
Battle_Std.GetNearEnemyToolShiftPosition <- function(tbl={})
{
	local ret = Battle_Std.CloneCopy(tbl);
	if( "flags" in ret)
	{
		ret.flags = _Position_ToolShift|_Position_ChangeMuki;
	}
	else
	{
		ret.flags <- _Position_ToolShift|_Position_ChangeMuki;
	}
	local pos = Battle_Std.GetNearEnemyDistance(ret);
	return pos;
}

//相手との距離情報を返す .angle, .distance
Battle_Std.GetPointStatus_NearEnemy <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.IsDone ) // 有効かどうか一応チェック
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
		// local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
		// print( format( "角度：%f  距離：%d", angle_deg, posst.distance ) );
		return posst;
	}
	else
	{
		local posst = BMvEff.CPointStatus();
		return posst;
	}
}

//相手への角度を返す（右向きの0.0〜2.0で角度が入る）
Battle_Std.GetNearEnemyMigiAngle <- function()
{
	local ps = Battle_Std.GetPointStatus_NearEnemy();
	if( ps==-1 )
	{
		// _dem("【警告】GetNearEnemyToolShiftAngle 相手が見つからない")
		return 0; //みつから無かったけど適当な値を返す
	}
	//0.0〜2.0
	local ret_angle = ps.angle;

	//右向きならそのまま　左向きなら反転
	//相手の方を向いていればそのまま返す
	//反対を向いていたらなんかやって返す
	//local isAiteMuki = (BMvTbl.CheckFurimuki()==0);
	local isMigiMuki = (BMvTbl.GetMuki()==1);
	/*
	if( !isAiteMuki ) //相手と反対向き
	{
		print("\n相手と反対")
		ret_angle = 2.0-ret_angle;
	}
	*/
	
	//このチェックだけでよさそうだ
	if( !isMigiMuki ) //左向き
	{
		//print("\n左向きだわ")
		ret_angle = 2.0-ret_angle;
	}	
	return ret_angle;
}


//おやへの右向き角度を返す（右向きの0.0〜2.0で角度が入る）
Battle_Std.GetParentMigiAngle <- function()
{
	local oya = BMvCore.GetParentCharaData();
	local ps = BMvEff.GetPointStatus( { target=oya } ); // 位置情報取得
	if( ps==-1 )
	{
		// _dem("【警告】親がいねー")
		return 0; //みつから無かったよ
	}
	//0.0〜2.0
	local ret_angle = ps.angle;

	local isMigiMuki = (BMvTbl.GetMuki()==1);
	
	//このチェックだけでよさそうだ
	if( !isMigiMuki ) //左向き
	{
		ret_angle = 2.0-ret_angle;
	}		
	return ret_angle;	
}


// flag & (1<<0) : 対空技設定（相手が空中でやられじゃない時すり抜けないようにする）
// flag & (1<<1) : ↑の処理＋空中やられチェックを無効化
//地上同士の時すり抜けないような補正がかかるEff6-12
Battle_Std.AddToolShift_NoSurinuke <- function(plus_x=0, flag=0)
{	
	local pos = BMvTbl.GetPosition( 0 );
	if( pos.y != 0) 
	{
		//自分が空中なら気にせず
		BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
		return;
	}
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.push() )
	{
		local epos = BMvTbl.GetPosition(0);
		
		enemy.pop();
		if( epos.y != 0) // 相手が空中の時
		{
			local checkNearTaiku = 0;
			
			// 対空チェックフラグがある時
			if( flag & (1<<0) || flag & (1<<1) )
			{
				local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
				
				local xLen = posst.distance_x/128;
				local yLen = posst.distance_y/128;
				// _dp("\n 相手とのY距離 : "+yLen );
				
				// 300ドット以内
				if( (!Battle_Std.CheckEnemyisBound() || flag & (1<<1) ) && yLen < 300 )
				{
					checkNearTaiku = 1;
					
					// _dp("\n ■移動予定:"+plus_x );
					
					xLen = xLen - 25;  // 重なり半分
					if( xLen < 0 ) xLen = 0;
					
					// _dp("\n 　重なり考慮の相手までの距離:"+xLen );
					if( xLen < plus_x )
					{
						plus_x = xLen; //
					}
					// _dp("\n 　-> "+plus_x );
					
				}
			}
			
			if( checkNearTaiku )
			{
				// 対空時で相手が近いので処理調整
				BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });
			}
			else
			{
				// 相手が空中ならキにせず
				BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
			}
			return;
		}
		// 自分と相手が地上にいる時補正をかける
		local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
		local len = (posst.distance_x/128);
		if( plus_x+50 >= len ) plus_x = len-50; // 大体重なり判定は-50<>+50なので軸を超え過ぎないように補正
	}
	BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
}

//画面外チェック
//margin_x : 少し余計に見るX距離（画面の外と見るところからマイナスされる）
function Battle_Std::CheckGamenGai( margin_x=0 )
{
	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	if(tp.x > (pos.ex+def_POS_GamenGaiYuuyoX+margin_x) || tp.x < (pos.sx-def_POS_GamenGaiYuuyoX-margin_x) )
	{
		//_dm("CheckGamenGai:画面外");
		return 1;
	}
	return 0;
}

//画面外チェック(向いてる向きの方だけ)
function Battle_Std::CheckGamenGaiMuki()
{

	local dis = Battle_Std.GetGamenHajiDistance();
	//print("\n:"+dis);
	if( dis+def_POS_GamenGaiYuuyoX < 0 )
	{
		//_dm("CheckGamenGaiMuki:画面外");
		return 1;
	}

	return 0;
}

//画面端チェック　※古いので使うのやめよ
// Battle_Std.CheckFromtDispCornerDistance()　とか使って
function Battle_Std::CheckGamenHaji( offx )
{
	local x = offx * 128;
	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	if(tp.x+x > pos.ex || tp.x-x < pos.sx )
	{
		//_dm("CheckGamenHaji:画面外");
		return 1;
	}
	return 0;
}

//向いてる向きの画面端までの距離を返す
//フィールド内にいる限りプラスの値になるはず？
//古いので使わない
Battle_Std.GetGamenHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	//_dm("test:"+tp.x);
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local ret = ( BMvTbl.GetMuki() == 1 )? ( pos.ex - tp.x ) : -( pos.sx - tp.x); //右向きだったら
	//print("\n向き："+ BMvTbl.GetMuki() );
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//操作親の背面の画面端までの距離を返す
//古いので使わない
Battle_Std.GetHaimenGamenHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	//_dm("test:"+tp.x);
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset } );
	local ret = ( BMvTbl.GetMuki() == 1 )? -( pos.sx ) : ( pos.ex ); //右向きだったら

	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}



//近いステージ端までの距離を返す
//必ずプラスの値になる
//古いので使わない
Battle_Std.GetNearStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( tp.x > 0 )? ( def_POS_GamenHajiX - tp.x ) : ( def_POS_GamenHajiX + tp.x);
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}


//向いてる向きのステージ端までの距離を返す
//古いので使わない
Battle_Std.GetStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX - tp.x ) : ( def_POS_GamenHajiX + tp.x); //右向きだったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//背面のステージ端までの距離を返す
//古いので使わない
Battle_Std.GetHaimenStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX + tp.x ) : ( def_POS_GamenHajiX - tp.x); //右向きだったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//相手キャラが居ない方のステージ端までの距離を返す
//必ずプラスの値になる
//古いので使わない
Battle_Std.GetNoEnemyMukiStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}
	

	local player_is1Pside = (Battle_Std.GetPositionSide() == 0); //１P側で0、2P側で1

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( player_is1Pside )? ( def_POS_GamenHajiX + tp.x ) : ( def_POS_GamenHajiX - tp.x); //1P側だったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//操作親の方を向く
Battle_Std.SetMuki_PlayerPosition <- function()
{
	//親の座標-自分の座標が＋なら右向き−なら左向き
	local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local oya_pos = BMvTbl.GetPosition( 0 ); //親の現在座標
		BMvCore.PopCharaData(); //			
		local pos = BMvTbl.GetPosition( 0 ); //現在座標
		local muki_is_migi = ( (oya_pos.x - pos.x)>0 );
		if( muki_is_migi )
		{
			BMvTbl.SetMuki( _Direction_Right );
		}
		else
		{
			BMvTbl.SetMuki( _Direction_Left );			 
		}
	}
}

//指定座標の方を向く
Battle_Std.SetMuki_CCharaPosition <- function( tpos )
{
	local pos = BMvTbl.GetPosition( 0 ); //現在座標
	local muki = ( (tpos.x - pos.x)>0 )? _Direction_Right : _Direction_Left;
	BMvTbl.SetMuki( muki );
}

//親のMvStatusを取得
function Battle_Std::GetParentMvStatus()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local s = BMvTbl.GetMvStatus(); // ステータス取得
	BMvCore.PopCharaData(); //
	return s;
}

//操作親のMvNameを取得
function Battle_Std::GetPlayerMvName()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local m = BMvTbl.GetMvName();
//		_dm("Mv取得:"+m);
	BMvCore.PopCharaData(); //
	return m;
}

//親のMvNameを取得
function Battle_Std::GetParentMvName()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local m = BMvTbl.GetMvName();
			//_dm("Mv取得:"+m);
		BMvCore.PopCharaData(); //
		return m;
	}
	else
	{
		// _dem("【警告】親からGetParentMvNameしたとか？");
		return "";
	}
}

//親のフレームIDを取得
function Battle_Std::GetParentFrameID()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		return s.FrameID;
	}
	else
	{
		// _dem("【警告】親からGetParentFrameIDしたとか？");
		return 0;
	}
}

//操作親のMvStatusを取得
function Battle_Std::GetPlayerMvStatus()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local s = BMvTbl.GetMvStatus(); // ステータス取得
	BMvCore.PopCharaData(); //
	return s;
}

//操作親のフレームIDを取得
function Battle_Std::GetPlayerFrameID()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		return s.FrameID;
	}
	else
	{
		// _dem("【警告】GetPlayerFrameIDえらー");
		return 0;
	}
}

//操作親のフレームIDを変更
function Battle_Std::SetPlayerFrameID(frameid=0)
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		// _dm("SetPlayerFrameID 操作親FrameIDを"+frameid+"に変更");
		BMvCore.PushCharaData( p ); //
			BMvTbl.JumpFrameID(frameid);
		BMvCore.PopCharaData(); //
	}
	else
	{
		// _dem("SetPlayerFrameIDえらー");
	}
}


//操作親の飛び道具制限を得る
function Battle_Std::CheckPlayerFireballLimit(num=0)
{
	return( BMvTbl.TobiParam_Func( { slot=num, type=_ValGet } ) );
}




//指定したスロットの飛び道具制限を上書きする
function Battle_Std::SetPlayerFireballCount(_slot=0, _num=0)
{
	BMvTbl.TobiParam_Func( { slot=_slot, val=_num, type=_ValSet } );
}


//現在のベクトルもしくは与えたベクトルからツール角度を返す
function Battle_Std::CCharaVector_GetToolAngle(vec=null)
{
	if( vec==null )
	{
		vec = BMvTbl.GetVector(0);	
	}
	local rad = atan2(vec.y, vec.x);
	local tool_angle = ((rad * 180 / PI)+90)/360*10000;
	return tool_angle.tointeger();
}


//メルブラでよくやってたBE処理をまとめて
//ボタンホールドが無かったらフレームIDジャンプ
//Battle_Std.JumpFrameID_NotHoldButton(tbl)
//-1: 取得失敗 BMvTbl.JumpFrameIDの戻り値を返す(成功すると フレーム番号が返る（IDではない）、IDがないと -1)
// checkid を探す
// checkid まできたら def_MC2_CheckStartExtendAction フラグが立つ
// ボタンホールドしてなかったら jumpid に飛んで終わり
// ボタンホールドしてると飛ばないで耐える（耐えてる最中はhitCheckId==1）
// checkidを通過後、別のidなら（ !hitCheckId かつ def_MC2_CheckStartExtendAction ）、def_MC2_CheckEndExtendActionがたってないなら
// jumpidと比較して、違っていたらエクステンド、ということでフラグ立てる

function Battle_Std::JumpFrameID_NotHoldButton(tbl)// mask, checkid, jumpid )
{
	return Battle_Std.JumpFrameID_NoHoldButton_MaskCheck( tbl, 1 );
}

// どれかではなく全部押してないとだめバージョン
function Battle_Std::JumpFrameID_NotHoldAllButton(tbl)// mask, checkid, jumpid )
{
	return Battle_Std.JumpFrameID_NoHoldButton_MaskCheck( tbl, 100 );
}

// この関数は直接使わないこと
Battle_Std.JumpFrameID_NoHoldButton_MaskCheck <- function( tbl, buttonMaskCheck=1 )
{
	local flags = ("flags" in tbl)? tbl.flags : 0;
	local noCheckNgTiming = ( (flags&(1<<0)) != 0 )? 1 : 0;//1:NGチェックをしない　Def_JFIDNHB_NoCheckNgTiming
	local holdForever = ( (flags&Def_JFIDNHB_HoldForever) != 0 )? 1 : 0;
	local objectHoldCheck = ( (flags&Def_JFIDNHB_ObjectHoldCheck) != 0 )? 1 : 0; // holdForeverのチェックをplayerでやらない
	
	// 先にホールド状態を取得
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.push() )
	{
		local hold = ( BMvTbl.CheckButtonHold( tbl.mask ) >= buttonMaskCheck ); // 1:どれか押されている 100:全て押されている
		local isExtended = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckStartExtendAction );
		
		// リバーサル行動でのIC技の処理
		{
			local reversal_cmd_flags = BMvTbl.GetRecoverMvFlags();
			// _dpn("reversal_cmd_flags:"+reversal_cmd_flags);
			if( reversal_cmd_flags&Def_TCL_Extend )
			{
				hold = 100; // 強制的に
			}
		}
		
		local onceReleased = 0;

		if( !objectHoldCheck ) // 通常はプレイヤーに対して処理
		{
			if( !hold )
			{
				//離してしまったことを記憶しておく
				if( !isExtended )
				{
					//エクステンド確定後は設定しない
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NotHoldForever );
				}
			}
			onceReleased = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NotHoldForever ); // すでに一度離しているかどうか
		}
		
		player.pop();
		
		if( objectHoldCheck ) // 設置オブジェクトなどはこっちでやる
		{
			if( !hold )
			{
				//離してしまったことを記憶しておく
				if( !isExtended )
				{
					//エクステンド確定後は設定しない
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NotHoldForever );
				}
			}
			onceReleased = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NotHoldForever ); // すでに一度離しているかどうか
		}
		
		local use_hold = hold;
		if( holdForever && onceReleased ) use_hold = 0;
		
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local ng_timing = (s.isFrameUpdate==0 && s.DataDelayVal==0)? 1 : 0;
		if( ng_timing && !noCheckNgTiming ) return -1; // このタイミングでSetPatternとかJumpFrameIDすると飛び先のFraが2回処理されてしまう
	
		local frameid = s.FrameID;
		local hitCheckId = 0;
		if( typeof tbl.checkid=="array" )
		{
			foreach(i,checkid in tbl.checkid)
			{
				if(frameid==checkid)
				{
					hitCheckId = 1;
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckStartExtendAction );
					
					//ホールドのチェックは操作親で見る
					if( !use_hold ) // ボタンホールドしてなかったら
					{
						if( typeof tbl.jumpid=="array" )
						{
							Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
							return( BMvTbl.JumpFrameID( tbl.jumpid[i] ) );				
						}
						else
						{
							Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
							return( BMvTbl.JumpFrameID( tbl.jumpid ) );	
						}
					}
				}
			}
		}
		else //これはひどい
		{
			if(frameid==tbl.checkid)
			{
				hitCheckId = 1;
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckStartExtendAction );
				
				if( !use_hold ) // ボタンホールドしてなかったら
				{
					if( typeof tbl.jumpid=="array" )
					{
						Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
						return( BMvTbl.JumpFrameID( tbl.jumpid[i] ) );				
					}
					else
					{
						Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
						return( BMvTbl.JumpFrameID( tbl.jumpid ) );	
					}
				}		
			}
		}
		
		// _dp("\n def_MC2_CheckEndExtendAction:"+Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckEndExtendAction ) );
		if( !hitCheckId && Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckStartExtendAction ) && !Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckEndExtendAction ) )
		{
			local noExtendJumped = 0;
			if( typeof tbl.jumpid=="array" )
			{
				foreach( slot, val in tbl.jumpid )
				{
					if( val == frameid ) noExtendJumped = 1;
				}
			}
			else
			{
				if( tbl.jumpid == frameid ) noExtendJumped = 1;
			}
			
			
			if( noExtendJumped ) // エクステンドの飛び先には行ってない
			{
			
			}
			else // エクステンド
			{
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
				
				Battle_Std.ExtendTiming();
			}
			
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
		}
		
		if( "endid" in tbl && frameid == tbl.endid && s.isFrameUpdate )
		{
			// _dp("\n エクステンドアクション！");
			// tDDC.Jem_AddCount( _JemCheckType_Ex + 1 ); // エクステンドアクション加算
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存

			Battle_Std.ExtendTiming();
			
			if( "flags" in tbl )
			{
				if( def_JFN_SetExtendFlagPlayer&tbl.flags )
				{
					if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
					{
						if( player.push() )
						{
							Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
							
							Battle_Std.ExtendTiming();
							
							player.pop();
						}
					}
				}
			}
		}
	}
	return -1;
}



//メルブラでよくやってたBE処理をまとめて
//ボタンホールドが無かったらパターンジャンプ（パターン最初がキャッシュに乗るのでデータ構造から変えておく）
//戻り値 -1:なにもなし 1:ホールドしてなくてジャンプした
//プレイヤーに対してフラグを立てたりするので、設置オブジェクトから呼ぶと処理が危ないの使わないこと
Battle_Std.SetPattern_NotHoldButton <- function( tbl )// ButtonMask, CheckFrameID, SetPattern, JumpFrameID
{
	local flags = ("flags" in tbl)? tbl.flags : 0;
	local noCheckNgTiming = ( (flags&(1<<0)) != 0 )? 1 : 0;//1:NGチェックをしない(座標バグが起こるので基本使わないこと)
	local holdForever = ( Def_Sys_EnableExtendHoldForever || (flags&Def_JFIDNHB_HoldForever) != 0 )? 1 : 0;
	local checkHoldButtonType = (flags&Def_JFIDNHB_CheckAllButton)? 100 : 1;//CheckButtonHoldの比較対象
	
	local mvs = BMvTbl.GetMvStatus(); // ステータス取得
	local ng_timing = (mvs.isFrameUpdate==0 && mvs.DataDelayVal==0)? 1 : 0;
	if( ng_timing && !noCheckNgTiming ) return -1; // このタイミングでSetPatternとかJumpFrameIDすると飛び先のFraが2回処理されてしまう
	
	// 先にホールド状態を取得
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.push() )
	{
		local holdInput = ( BMvTbl.CheckButtonHold( tbl.ButtonMask ) >= checkHoldButtonType ); // 1:どれか押されている 100:全て押されている
		local comeToCheckID = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckStartExtendAction );//checkidまで進んだ
		
		// リバーサル行動でのIC技の処理
		{
			local reversal_cmd_flags = BMvTbl.GetRecoverMvFlags();
			// _dpn("reversal_cmd_flags:"+reversal_cmd_flags);
			if( reversal_cmd_flags&Def_TCL_Extend )
			{
				holdInput = true; // 強制的に
			}
		}
		
		if( !holdInput )
		{
			//離してしまったことを記憶しておく
			if( !comeToCheckID )//まだcheckidまできていないなら
			{
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NotHoldForever );//すでに一度離したのを記憶
			}
		}
		local onceReleased = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NotHoldForever ); // すでに一度離しているかどうか
		
		player.pop();
		
		// _dpn("holdInput:"+holdInput+" comeToCheckID:"+comeToCheckID+" onceReleased:"+onceReleased);
		
		local use_hold = holdInput;
		if( holdForever && onceReleased ) use_hold = 0;		
	
		local checkFrameIdArray = ( typeof tbl.CheckFrameID == "array" )? tbl.CheckFrameID : [tbl.CheckFrameID];
		local jumpFrameIdArray = ("JumpFrameID" in tbl)? (typeof tbl.JumpFrameID == "array")? tbl.JumpFrameID : [tbl.JumpFrameID] : 0;
		
		if( mvs.MvCount==0 )
		{
			local target_pat = BMvEff.GetPatternNum( { datatype=0, pat=tbl.SetPattern } ); // 飛び先のPATの番号取得
			
			// キャッシュ予約処理
			if( jumpFrameIdArray )
			{
				for( local i=0; i<jumpFrameIdArray.len(); i++ )
				{
					local fra = jumpFrameIdArray[i];
					local checkframe = BMvEff.GetFrameIDNum_Pat( target_pat, fra );
					
					_dpn("キャッシュ予約["+target_pat+"_"+checkframe+"] FrameID:"+fra );
					if( checkframe != -1 ) // FrameIDがあるかどうか
					{
						BMvCore.CallEntryBCCachePreTransfer( { pat=target_pat, frame=checkframe, rest=6 } );
					}
				}
			}
			BMvCore.CallEntryBCCachePreTransfer( { pat=target_pat, frame=0, rest=6 } ); // restは適当
			_dpn("キャッシュ予約:["+target_pat+"_0]");
		}
		
		local hitCheckId = 0;//checkidの最中は1
		foreach( slot, checkid in checkFrameIdArray )
		{
			if( mvs.FrameID == checkid )
			{
				hitCheckId = 1;
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckStartExtendAction );//checkidまで進んだ
				
				if( !use_hold ) // ボタンホールドしてなかったら
				{
					BMvTbl.SetPattern( tbl.SetPattern );
					
					// 変更先のPatでさらにFrameIDを変える場合
					if( jumpFrameIdArray )
					{
						if( jumpFrameIdArray.len() > slot )
						{
							local jump_id = jumpFrameIdArray[slot];
							// _dpn("jump_id:"+jump_id);
							BMvTbl.JumpFrameID(jump_id);
						}
						tbl.JumpFrameID[slot]
						
					}
					return 1;
				}
			}
		}
		
		if( !hitCheckId )
		{
			//_dp("\n mvs.DataPattern tbl.SetPattern:"+mvs.DataPattern+" "+tbl.SetPattern);
			local setPatNum = ( typeof tbl.SetPattern == "string" )? BMvEff.GetPatternNum( { datatype=0, pat=tbl.SetPattern } ) : tbl.SetPattern;
			if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckStartExtendAction ) && !Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckEndExtendAction ) )
			{
				if( mvs.DataPattern != setPatNum )
				{
					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
					
					Battle_Std.ExtendTiming();
				}
				
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了		
			}
			
			if( "EndFrameID" in tbl && mvs.FrameID == tbl.EndFrameID && mvs.isFrameUpdate )
			{
				// _dp("\n エクステンドアクションポテンシャル加算");
				// tDDC.Jem_AddCount( _JemCheckType_Ex + 1 ); // エクステンドアクション加算
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
				
				Battle_Std.ExtendTiming();
				
				// タメのときにガードフラグを変化させる
				if( "EndGuardFlag" in tbl )
				{
					BMvTbl.SetAtkGuardFlag( { guard=tbl.EndGuardFlag, time=64, flag=_ClearFlag_ChangeMv } );
				}
			}
		}
	}
	return -1;
}

//カメラフォーカスを呼び出しに寄せる
function Battle_Std::SetCamera_Focus_PlayerPosition(tbl)
{
	local pos = BMvTbl.GetPosition( 0 );
	
	("x" in tbl)? tbl.x = pos.x : tbl.x <- pos.x;
	("y" in tbl)? tbl.y = pos.y : tbl.y <- pos.y;
	
	BMvEff.SetCamera_Focus( tbl ); //カメラ固定？
}

function Battle_Std::SetCamera_Focus_EnemyPosition(tbl)
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if(enemy.IsDone)
	{
		BMvCore.PushCharaData( enemy ); // 
			Battle_Std.SetCamera_Focus_PlayerPosition(tbl);
		BMvCore.PopCharaData(); // 
	}
	else
	{
		return 0; //敵取得失敗
	}
}

Battle_Std.GetHanteiRectArray <- function( pos )
{
	switch( pos )
	{
	case "頭":
		return [ _Hantei_Etc, 9 ];
		break;
	case "首":
		return [ _Hantei_Etc, 10 ];
		break;
	case "腹":
		return [ _Hantei_Etc, 11 ];
		break;
	case "足":
		return [ _Hantei_Etc, 12 ];
		break;
	}
}

//メルブラであった投げ開放まとめ
function Battle_Std::ThrowRelease(tbl)
{
	local id = ("id" in tbl)? tbl.id : 0;

	local s = BMvTbl.GetMvStatus(); // ステータス取得
	local isFrameUpdate = ("nocheck_frameupdate" in tbl)? 1 : s.isFrameUpdate;

	local throw_param = {};
	local release_param = {};
	
	if("x" in tbl) throw_param.x <- tbl.x;
	if("y" in tbl) throw_param.y <- tbl.y;
	if("pat" in tbl) throw_param.pattern <- tbl.pat; //意味なさそう
	if("throw_frame" in tbl) throw_param.frame <- tbl.frame;
	if("throw_id" in tbl) throw_param.frameID <- tbl.id;
	if("pos" in tbl)
	{
		throw_param.hantei_rect <- Battle_Std.GetHanteiRectArray( tbl.pos );
	}
	else
	{
		if("rect" in tbl) throw_param.hantei_rect <- tbl.rect;	
	}

	if("type" in tbl) release_param.type <- tbl.type;
	if("airrecover" in tbl) release_param.airrecover <- tbl.airrecover;
	if("flags" in tbl) release_param.flags <- tbl.flags;
	
	if(( id!=0 && s.FrameID==id && isFrameUpdate ) || (id==0 && isFrameUpdate ) )
//	if(( id!=0 && s.FrameID==id && s.isFrameUpdate ) || (id==0 && s.isFrameUpdate ) )
	{
		BMvEff.ThrowParam( throw_param );
		BMvEff.ThrowRelease( release_param );
	}
}


//特殊判定の位置を合わせてつかむ
//フレームIDが14000〜14999までだと発生ｗ
function Battle_Std::ThrowParam_WithHanteiEtc(_pat=0,_frame=0)
{
	local s = BMvTbl.GetMvStatus(); // ステータス取得
	local pat = _pat;
	
	if( _pat==0 )
	{
		if( s.FrameID<14000 || s.FrameID>14999 || !(s.isFrameUpdate) ) return 0; //失敗
		pat = s.FrameID-14000; //相手のパターン番号
	}
	else
	{
	}


	//特殊判定１のsxとの角度をつかみ角度にするよ
	local rc1 = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	local setangle =( rc1.sx != _Hantei_Error )? true : false;
	
	for(local i=9;i<13;i++) //特殊判定を順番に見てあったのでつかむ
	{
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.ThrowParam( { pattern=pat, x=rc.sx, y=rc.sy, hantei_rect=[ _Hantei_Etc, i ], frame=_frame } );
			if( setangle )
			{
				//rc.sx,syと rc1.sx,syとの角度を
				local rad = atan2(rc.sy-rc1.sy, rc1.sx-rc.sx);
				local tool_angle = ((rad * 180 / PI)+90)/360*10000;

				//_dm(format("ThrowParam_WithHanteiEtc angle:%d x:%d y:%d , x:%d y:%d",tool_angle, rc.sx, rc.sy, rc1.sx, rc1.sy ));			

				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
				if( enemy.IsDone )
				{
					BMvCore.PushCharaData( enemy ); // 
						BMvTbl.SetAngle({ angle=tool_angle });
					BMvCore.PopCharaData(); // 
				}
				//BMvEff.StdCall( { type=14, no=pat, param=[ rc.sx,rc.sy,0,0,0, 0,0,0,0,0, 0,0 ]} );
			}
			break; //最初にみつけたので終わる
		}
	}	
}

//操作親の矩形の座標を取得
Battle_Std.GetHanteiRect_Player <- function( tbl )
{
	local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	BMvCore.PushCharaData( p ); //
		local rc = BMvEff.GetHanteiRect( tbl );
	BMvCore.PopCharaData(); //	

	return rc;
}

//攻撃判定がヒットしてたら特殊判定１の座標に強制移動する半ロック
//重なり判定が重なるとワープし続けるので要修正→相手の座標を調節する処理を追加したので多分OK
//移動の強さを指定できるように
//地上やられでは反応しない
//ダウン追い討ちっぽかったら（pat分岐）飛ばないチェック追加
//XXX:この処理Lightとの差分を要チェック
Battle_Std.SetPosition_DamageHanteiRect <- function( tbl={} )
{
	/* tblスロット
	power 0〜100　：　目標に対してどんだけ寄せるか
	CheckAttackRectFrame : 0,1 攻撃判定があるフレームしか見ない
	distance : 相手との距離がこれ以内だったら寄せる（0だと見ない）
	*/
	local power = ("power" in tbl)? tbl.power : 100;
	local flags = ("flags" in tbl)? tbl.flags : 0;

	//相手との距離チェック
	local pt = Battle_Std.GetPointStatus_NearEnemy();
	if( "distance" in tbl)
	{
		if( pt.distance > tbl.distance ) return 0;
	}
	
	//相手が地上の時は行わない
	//※地上やられで浮いちゃうからね
	local enemy = BMvCore.GetEnemyCharaData(); // 敵の情報を得る			
	
	if( enemy.push() )
	{
		local isGround = ( BMvTbl.CheckPosState( _PosState_Ground ) == 1) //地上？
		local isDownOiuti = (BMvTbl.CheckPattern([350,290,348])==1); //ダウンしてる絵への追撃だ？　ダウン追い討ち
		local bound_st = BtlMvStd.GetBoundStatus();
		enemy.pop();

		// 地上 & 地上でも引き寄せじゃない　なら失敗
		if( isGround && !(flags&(1<<2)) ) return 0;
		if( Def_Rule_SkipRock_DownOiuti && isDownOiuti ) return 0; // ダウン追い討ちっぽい

		if( bound_st.isCapture && !(flags&(1<<5)) ) return 0; // 投げられ中は失敗
	}
	else
	{
		return 0;
	}
	
	//ヒットしてたら相手の座標をワープさせる半ロックに
	Battle_Std.MoveEnemyEtcRect( power, flags );
	return 1;
}

// 相手キャラを特殊判定0の座標まで動かす
// flags (1<<0) : X座標無効
// flags (1<<1) : Y座標無効
// flags (1<<2) : 相手が地上でも引き寄せ処理を行う
// flags (1<<3) : 相手が地上で(1<<2)のときに、X座標無効
// flags (1<<4) : 相手が地上で(1<<2)のときに、Y座標無効
// flags (1<<5) : つかみ中でも処理
// flags (1<<6) : 重なりが合わさった時のズラし処理を新仕様にする（廃止。かならず有効）
Battle_Std.MoveEnemyEtcRect <- function( power, _flags=0 )
{
	// local rc = Battle_Std.GetHanteiRect_Player( { check=[ _Hantei_Etc, 0 ], flags=0 } );
	local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=0 } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		local pos = BMvTbl.CCharaPosition(); //目標
		//向きに応じてsxを使うかexを使うか決める
		pos.y = rc.sy;
		pos.x = ( BMvTbl.GetMuki()==1 )? rc.sx : rc.ex; //右向きならsx、左向きならex

		//posが目的座標
		local tpos = BMvTbl.CCharaPosition(); // ここが最終移動先
		
		local p_kasa = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );

		local p_pos_buf = BMvTbl.GetPositionBuffer(1); // 小さい方が左側（たいてい0:左側 1:右側）
		
		local ppos = BMvTbl.GetPosition();

		//enemyからposへの距離座標を出して、powerでかけたのを足した先が目的地になる
		local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			local e_pos_buf = BMvTbl.GetPositionBuffer(1); // 小さい方が左側（たいてい0:左側 1:右側）
			local epos = BMvTbl.GetPosition(); // 位置取得
			local isGround = ( BMvTbl.CheckPosState( _PosState_Ground ) == 1);
			
			enemy.pop();

			local pos2 = BMvTbl.CCharaVector(); // ベクトル情報型の生成
			pos2.x = epos.x;  pos2.y = epos.y; // 始点
			pos2.addx = pos.x;  pos2.addy = pos.y;  // 加算値だけども終点として扱う
			local posst = BMvEff.GetPointStatus( { points=pos2 } ); // 位置情報取得
			
			tpos.x = epos.x + (posst.pos_x*power/100);
			tpos.y = epos.y + (posst.pos_y*power/100);			

			//最後にエラー補正
			//画面外だったら補正
			if( tpos.x > def_POS_GamenHajiX ) tpos.x= def_POS_GamenHajiX;
			if( tpos.x < -def_POS_GamenHajiX ) tpos.x= -def_POS_GamenHajiX;
			
			// 移動先にpl_kasanariがあったら補正をかける
			
			//_dpn("----PX:"+ppos.x+", "+epos.x );
			
			if( enemy.push() )
			{
				local noX = (_flags&(1<<0));
				local noY = (_flags&(1<<1));
				local okGroundXY = (_flags&(1<<2)); // 地上でもこの処理に入ってくる
				local noGroundX = (_flags&(1<<3)); // (1<<2)と一緒に使う
				local noGroundY = (_flags&(1<<4)); // (1<<2)と一緒に使う
				
				local enable = { x=1, y=1 };
				if( noX ) enable.x = 0;//X無効あるならダメ
				if( noY ) enable.y = 0;//X無効あるならダメ
				if( isGround && !okGroundXY )
				{
					enable.x = 0;
					enable.y = 0;
				}
				if( isGround && okGroundXY && noGroundX ) enable.x = 0;
				if( isGround && okGroundXY && noGroundY ) enable.y = 0;
				
				if( enable.x ) // X座標有効
				{
					BMvTbl.SetPosition( { x=tpos.x } );
				}
				if( enable.y ) // Y座標有効
				{
					BMvTbl.SetPosition( { y=tpos.y } );
				}
				
				
				local newkasanariShift = 1; // (_flags&(1<<6));//重なりあったとき、特殊判定の方に動かすのを優先する
				
				//重なり判定があるけど、重なりチェックをしない吹き飛びのとき、不用に処理をしてしまうことがある
				//古い処理だと、画面端で重なりの長さに差がある相手のとき、向きが逆になることがある
				local e_kasa = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari , 0 ], flags=0 } );
				if( p_kasa.sx != _Hantei_Error && e_kasa.sx != _Hantei_Error )
				{
					// 重なっているかチェック
					// if( p_kasa.sx > e_kasa.sx && )
					// bool bCross = !(xmn1 > xmx2 || xmn1 > ymx2 || xmx1 < xmn2 || ymx1 < ymn2);
					if( !(p_kasa.sx > e_kasa.ex || p_kasa.sy > e_kasa.ey || p_kasa.ex < e_kasa.sx || p_kasa.ey < e_kasa.sy) )
					{
						// _dp("\n 重なってる");
						local pos_side = ( p_pos_buf < e_pos_buf )? 0 : 1; // 0:自分|相手 1:相手|自分
						local c_pos = BMvTbl.GetPosition(); // 位置取得
						local same_pos = (p_kasa.sx == e_kasa.sx)? 1 : 0;//同じ座標のときだけ、pos_side(1F前の位置関係)を参照する
						//_dpn("same_pos:"+same_pos+" pos_side:"+pos_side );
						//_dpn("p_kasa.sx:"+p_kasa.sx+" ex:"+p_kasa.ex+" e_kasa.sx:"+e_kasa.sx+" ex:"+e_kasa.ex+" cx:"+c_pos.x);
						//pposとeposで比較してどっちにズラすか決めると、フォノンのFF背面ヒットなんかで吸わなくなる
						
						//特殊判定の位置に動かそうとする。重なりぶつかった時はこの位置関係に向かって座標修正させる
						// 0:自分|相手 1:相手|自分
						//P 特　→　PE 0
						//特 P　→　EP 1
						local shift_type = 0;
						if( newkasanariShift )
						{
							if( ppos.x > pos.x || ( (ppos.x==pos.x) && pos_side == 1 ) )
							{
								shift_type = 1;//EP
							}
							else
							{
								shift_type = 0;//PE
							}
						}
						else
						{
							//※※※古い処理※※※
							//重なりのsxを比較して位置関係を決める
							//重なりの横幅に差があると差異が生まれるバグあり。重なりが小さい方が右側に行きやすくなってしまう
							//同座標の場合はpos_sideを比較してどちらに動かすか決めている
							
							//重なりがあるのに重なって位置調整がおきず、重なりの横幅に差のある組み合わせのときがおかしい
							//重なり判定をしない壁バウンド発生技で、かつ半ロックの処理があって、相手と重なりに差があるとき＝ミカの623系のみ
							
							if( p_kasa.sx > e_kasa.sx || (same_pos && pos_side == 1) )
							{
								shift_type = 1;//EP
							}
							else
							{
								shift_type = 0;//PE
							}
						}
						
						
						if( shift_type == 1 ) // E P
						{
							// _dp("\n EP:"+(e_kasa.ex - p_kasa.sx)/128 );
							c_pos.x -= e_kasa.ex - p_kasa.sx;
							BMvTbl.SetPosition( { x=c_pos.x } ); // 調整
						}
						else // P E
						{
							// _dp("\n PE:"+(e_kasa.sx - p_kasa.ex)/128 );
							c_pos.x -= e_kasa.sx - p_kasa.ex;
							BMvTbl.SetPosition( { x=c_pos.x } ); // 調整
						}
						// _dpn( "移動先 -> "+c_pos.x );
					}
					
				}
				
				enemy.pop();
			}
			// Battle_Std.SetEnemyPosition( tpos );
			
			//_dem(format("x:%d y:%d x:%d y:%d",pos.x,pos.y,tpos.x,tpos.y));
			
			//重なり同士が重なっていたら補正？
			//操作親だけでいいのか？
		}
	}
}



//配列だったらランダム抽選　違ったらそのまま返す
Battle_Std.array_rand <- function( foo )
{
	//print("\nfoo:"+foo);
	switch( typeof foo )
	{
	case "array":
		//print("\n配列だわ");
		return foo[ BMvEff.Random_Limit(foo.len()) ];
		break;
	default:
		//print("\nそのままー");
		return foo;
		break;
	}
}


//ゲーム座標を呼び出しからのオフセット座標に変換
Battle_Std.GamePos2ShiftPos <- function( pos )
{
	local me = BMvTbl.GetPosition(0);
	local sa = BMvTbl.CCharaPosition();
	sa.x = pos.x - me.x;
	sa.y = pos.y - me.y;
	//左向きの時は目標Ｘを反転
	if( BMvTbl.GetMuki()!=1 )
	{
		sa.x *= -1; 
	}
	return sa;
}

local get = function(tbl, x)
{
	return (x in tbl)? tbl[x] : 0;
}

Battle_Std.DrawBladeEffect <- function( tbl={} ) : (get)
{
	Battle_Std.CreateObjectEX( { x=get(tbl,"x"), y=get(tbl,"y"), pat=tbl.pat, flags=_Position_ToolShift,
	objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround
	} );
}

// Param0 == 10 の時SEを再生するオブジェクトを呼び出す関数
Battle_Std.Call_FootStepSE <- function()
{
	local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_Null_PlayFootstepSE" } ); //足音再生監視オブジェクト
	if( eff.push() )
	{
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
		
		eff.pop();
	}
}

//画面全体エフェクト
Battle_Std.ScreenEffect <- function( tbl={} ) : (get)
{
	local pos = 
	{
		x=get(tbl,"x"),
		y=-360*128 + get(tbl,"y")
	}
	local ret = Battle_Std.CreateObjectEX( { datatype=("datatype" in tbl)? tbl.datatype : 0, pat=tbl.pat, mvname=("mvname" in tbl)? tbl.mvname : "", 
	objectflags=_ObjFlags_NoGround|_ObjFlags_NoCamera
	initfunc = function() : (pos)
	{
		BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
	}
	} );
	return ret;
}

Battle_Std.ScreenEffect_LimitMv <- function( tbl={} )
{
	local e = Battle_Std.ScreenEffect( tbl );
	BMvCore.PushCharaData( e );	
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	BMvCore.PopCharaData();
	return e;
}

Battle_Std.DrawIncreaseEffect <- function( tbl={} ) : (get)
{
	Battle_Std.CreateObjectEX( { x=get(tbl,"x"), y=get(tbl,"y"), datatype=1, pat=26, flags=_Position_ToolShift,
	objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround
	} );
}


//CreateObjectの拡張
Battle_Std.CreateObjectEX <- function( tbl )
{

//	datatype		0:自分 1:汎用
//	x			X座標
//	y			Y座標
//	setx			ゲームX座標(Xはオフセット座標になる)
//	sety			ゲームY座標(Yはオフセット座標になる)
//	mvname		行動文字列
//	pat			初期パターン文字列可、配列可（配列の場合ランダムになる）
//	FrameID		初期フレームID、配列可（配列の場合ランダムになる）
//	flags		同じ
//	objectflags	SetObjectFlagsするもの
// 	objprocflags	ObjProcFlags_Setするもの
//	initfunc		呼び出してすぐにやりたい関数
//	angle		見た目角度
//	LP			LPSetを行う

	//CreateObjectに渡すテーブル
	local _x = ("x" in tbl)? tbl.x : 0;
	local _y = ("y" in tbl)? tbl.y : 0;
	
	//とりあえず最初にCreateObjectするときのテーブル
	//そのあとPushCharaDataして色々やる
	local o = 
	{
		datatype = ("datatype" in tbl)? tbl.datatype : 0,
		x = _x,
		y = _y,
		mvname = ("mvname" in tbl)? tbl.mvname : "",
		flags = ("flags" in tbl)? tbl.flags : 0
	}
	
	local _flags = ( (o.flags&_Position_ToolShift)!=0 )? _Position_CaptureShift : 0;

	local pat = 0;
	if( "pat" in tbl )
	{
		pat = Battle_Std.array_rand( tbl.pat );
		o.start_pat <- pat; //初期patを指定する <- なのは、スロットが無いのと0指定では挙動が違うらしいので
		//print("\n★これやろ？"+pat);
	}
	local FrameID = ( "FrameID" in tbl )? Battle_Std.array_rand( tbl.FrameID ) : 0;

	// print("\n pat:"+pat+" ID:"+FrameID);

	local e = BMvEff.CreateObject( o );	
	if( e.push() )
	{
		if( "objectflags" in tbl ) BMvEff.SetObjectFlags({ flags=tbl.objectflags });
		if( "objprocflags" in tbl ) BMvEff.ObjProcFlags_Set( { flags=tbl.objprocflags } );
		//if( pat!=0 ) BMvTbl.SetPattern( pat );
		if( FrameID!=0 ) BMvTbl.JumpFrameID( FrameID );
		if( "angle" in tbl )
		{
			if( tbl.angle=="rand" )
			{
				BMvTbl.SetAngle( { angle=BMvEff.Random_Limit(10000) } );				
			}
			else
			{
				BMvTbl.SetAngle( { angle=tbl.angle } );
			}
		}
		if( "initfunc" in tbl ) tbl.initfunc();
		if( "LP" in tbl )
		{
			BMvTbl.SetLP(tbl.LP.slot, tbl.LP.val);
		}
		if( "setx" in tbl )
		{
			BMvTbl.SetPosition( { x=tbl.setx, flags=_flags } );
			BMvTbl.SetPosition( { x=_x, y=_y, flags=_flags|_Position_Add|_Position_ChangeMuki } )
		}
		if( "sety" in tbl )
		{
			//_dm("くる？ y:"+_y);
			BMvTbl.SetPosition( { y=tbl.sety, flags=_flags } );
			BMvTbl.SetPosition( { x=_x, y=_y, flags=_flags|_Position_Add|_Position_ChangeMuki } )
		}
		
		e.pop();
	}
	return e; //一応つくったオブジェクトをかえそう
}

//ホーミング一応動いてるけど…
Battle_Std.DivHomingTarget <- function( tbl )
{
	// tbl
	// core = ターゲット 
	// x,y = オフセット座標
	// frame
	
	//ターゲットめがけて動く
	if( tbl.core.IsDone ) // 有効かどうか一応チェック
	{
		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //操作親の座標を取得
			local oya_muki = BMvTbl.GetMuki(); //親の向き
		BMvCore.PopCharaData(); //	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128;
	
		pos.x += offx;
		pos.y += offy;
	
		local posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		local speed = (posst.distance/tbl.frame)*2;
		local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );

		//_dm("Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		BMvTbl.SetVector( { x=v.x, y=v.y, addx=-v.x/tbl.frame, addy=-v.y/tbl.frame, flags=_Vector_DivKeep|_VecFlag_NoMuki } );				
		// ※ posst.angle は浮動少数点なので整数として使わないといけない場合はきっちり変換すること
	}

}

//ホーミング一応動いてるけど…
Battle_Std.HomingTarget <- function( tbl )
{
	// tbl
	// posst	BMvEff.CPointStatus() 目標座標（これかcoreの二択）
	// core = ターゲット 
	// x,y = オフセット座標
	// frame ※frameかspeedかどっちか
	// speed
	// 
	
	local do_flag = false;
	local posst;
	
	if( "posst" in tbl ) //指定座標へ飛ぶ
	{
		posst = tbl.posst;
		do_flag = true;
	}
	else if( tbl.core.IsDone ) // 指定ターゲットに飛ぶ
	{
		local my_pos = BMvTbl.GetPosition(0);

		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			local oya_muki = BMvTbl.GetMuki(); //向き
		BMvCore.PopCharaData(); //	
		
		local oya_zyouge = (pos.y>my_pos.y)? -1 : 1;	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128; //*oya_zyouge;
	
		pos.x += offx;
		pos.y += offy;
	
		posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
		
		do_flag = true;
	}
	
	if( do_flag )
	{
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		
		local speed = tbl.speed;
		if( "frame" in tbl )
		{
			speed = posst.distance/tbl.frame
		}
		
		if( speed<tbl.minSpeed ) speed = tbl.minSpeed; //最低スピード保障

		local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );
		

		//_dm("angle:"+posst.angle+" Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		local vec;
		vec = BMvTbl.GetVector(0);
		//_dm(format(" x:%d y:%d",vec.x, vec.y ));
		BMvTbl.SetVector( { x=v.x, y=v.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );				
		vec = BMvTbl.GetVector(0);
		//_dm(format(" x:%d y:%d",vec.x, vec.y ));
	}
}

//ホーミング処理少し調整版
Battle_Std.HomingTarget2 <- function( tbl )
{
	// tbl
	// posst	BMvEff.CPointStatus() 目標座標（これかcoreの二択）
	// core = ターゲット 
	// x,y = オフセット座標
	// frame ※frameかspeedかどっちか
	// speed
	// addangle_max １Ｆで許せる方向転換角度（急転換しないように）
	
	local do_flag = false;
	local posst;
	
	if( "posst" in tbl ) //指定座標へ飛ぶ
	{
		posst = tbl.posst;
		do_flag = true;
	}
	else if( tbl.core.IsDone ) // 指定ターゲットに飛ぶ
	{
		local my_pos = BMvTbl.GetPosition(0);

		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			local oya_muki = BMvTbl.GetMuki(); //向き
		BMvCore.PopCharaData(); //	
		
		local oya_zyouge = (pos.y>my_pos.y)? -1 : 1;	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128; //*oya_zyouge;
	
		pos.x += offx;
		pos.y += offy;
	
		posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
		
		do_flag = true;
	}
	
	if( do_flag )
	{
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		
		local speed = tbl.speed;
		if( "frame" in tbl )
		{
			speed = posst.distance/tbl.frame
		}
		
		if( speed<tbl.minSpeed ) speed = tbl.minSpeed; //最低スピード保障

		local addvec = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );
		

		

		//_dm("angle:"+posst.angle+" Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		local nowvec = BMvTbl.GetVector(0);
		
		local setvec = BMvTbl.CCharaVector();
		setvec.x = nowvec.x + addvec.x*BMvTbl.GetMuki();
		setvec.y = nowvec.y + addvec.y;
		
	
		if( "addangle_max" in tbl )
		{
			local safe = tbl.addangle_max;
			
			local nowangle = BMvEff.GetAngle_FromVector( { x=nowvec.x, y=nowvec.y } );
			local setangle = BMvEff.GetAngle_FromVector( { x=setvec.x, y=setvec.y } );
			local sa = (setangle.angle - nowangle.angle);
			if( sa >=  1.0 ) sa = 2.0 - sa;
			if( sa <= -1.0 ) sa = 2.0 + sa;
				
			if( sa > safe ) //|| sa < -0.05 )
			{
				local addvec = BMvEff.GetVector_FromAngle( { angle = nowangle.angle+safe, speed = speed } );
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
			else if( sa < -safe ) //|| sa < -0.05 )
			{
				local addvec = BMvEff.GetVector_FromAngle( { angle = nowangle.angle-safe, speed = speed } );
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
			else
			{
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
		}
		else
		{
			BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
		}
	}
}

//今のベクトルから角度を設定する
Battle_Std.SetAngle_fromVector <- function()
{
	/*
	local vec = BMvTbl.GetVector(0);	
	
	local rad = atan2(vec.y, vec.x);
	local angle = ((rad * 180 / PI)+90)/360*2.0;
	
	//local angle = tool_angle/5000.0;
	
	BMvTbl.SetAngle( { angle_float=angle });
	*/
	
	local vec = BMvTbl.GetVector(0);	
	local cpst = BMvEff.GetAngle_FromVector( { x=vec.x, y=vec.y } );
	BMvTbl.SetAngle( { angle_float=cpst.angle } );

}

//パターン内のみ継続の演出系画面全体オブジェクト
Battle_Std.ScreenEffect_LimitPat <- function( tbl )
{
	local e = Battle_Std.ScreenEffect( tbl ); //画面におくエフェクト
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_PatChangeNoLanding } );
		BMvCore.PopCharaData();
	}
	return e;
}

Battle_Std.DrawEffect_LimitPat <- function( tbl )
{
	tbl.flags <- _Position_ToolShift;
	tbl.objectflags <- _ObjFlags_EraseParentPatChange|_ObjFlags_NoGround|_ObjFlags_PatChangeNoLanding;
	
	return Battle_Std.CreateObjectEX( tbl );
}

//何かでキャンセルしなかった場合追撃不能にする（LastUpdate用）
//キャンセルしない追撃なんて考えられない
//相手が先に動き出すようなものでは使ってはいけない（使うときは追撃不能命令を入れない）
//行動可能のフリーモーションだとダメそう→修正(大丈夫これ？)
Battle_Std.NoCansel_NoAttackHit <- function( tbl={} )
{
	local hosei_uwagaki = ("上書き補正" in tbl)? tbl["上書き補正"] : 80; //デフォルト上書き補正
	local hosei_zyozan = ("乗算補正" in tbl)? tbl["乗算補正"] : 90; //デフォルト乗算補正
	local no_atk_hit = ("noattackhit" in tbl)? tbl.noattackhit : 1; //追撃不能にするかどうか　デフォは1
	local no_zurasi_hosei = ("no_zurasi_hosei" in tbl)? tbl.no_zurasi_hosei : 0;

	//NoAttackHit
	if( Battle_Std.CheckNoCansel() ) //キャンセルしないでFinalizeした
	{
		// フリーモーションを除外するため、行動可能からの抜けも含めた
		// _dm("NoCansel_NoAttackHit キャンセルしなかった");
		if( no_atk_hit==1 ) //追撃不可にする
		{
			Battle_Std.EnemyNoAttackHit(); // 相手を追撃不能にする
		}
	}
	else //キャンセルした、やられで途中でとまったとか
	{
		// _dm("NoCansel_NoAttackHit キャンセルした");
		//レインコンボもここなのがやや怖いので強制的に基底＋乗算補正をかける
		if( no_zurasi_hosei && BMvTbl.GetMvStatus().MvCount <=2 )
		{
			// _dpn("ズラし押しっぽいので補正処理をしない");
		}
		else
		{
			// _dpn("キャンセル時の抜け補正");
			BMvEff.StdCall( { type=6, no=112, param=[ hosei_uwagaki,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //上書き８０
			BMvEff.StdCall( { type=6, no=112, param=[ hosei_zyozan,1,0,0,0, 0,0,0,0,0, 0,0 ]} ); //乗算９０
		}
		// レインコンボのみの取得はできない（LastUpdateで被ダメかどうかを検知できない）
	}
}

//相打ち時は、!BMvTbl.FromFinalize()で行動不能なので0を返すため注意
Battle_Std.CheckNoCansel <- function()
{
	if( BMvTbl.FromFinalize() || !BMvTbl.FromFinalize() && BCMDTbl.CheckCancel(_SkillType_None) ) //キャンセルしないでFinalizeした
	{
		return 1;
	}
	return 0;
}

Battle_Std.EnemyNoAttackHit <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();

		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている

		//のけぞりorつかまれ
		if( bs.isBound == 1 || bs.isCapture != 0 )
		{
			BMvTbl.SetWallCount( 100 ); //追撃不能状態にする
			// _dm("追撃不能にされました");
		}
		//_dm("チェック");
		
		enemy.pop();
	}
}

//投げ系のＭｖを途中でキャンセルする時つかみを開放する
Battle_Std.ThrowMv_CanselRelease <- function( tbl={} )
{
	//NoAttackHit
	if( BMvTbl.FromFinalize() ) //キャンセルしなかった
	{
		//print("\nキャンセルしなかった");
		return 0; //キャンセルしなかったので開放しない
	}
	else //キャンセルした、やられで途中でとまったとか
	{
		// _dm("ThrowMv_CanselRelease キャンセルした");
		if( "nocheck_frameupdate" in tbl )
		{
		}
		else
		{
			tbl.nocheck_frameupdate <- 1; //フレームアップデートをチェックしない
		}
		Battle_Std.ThrowRelease( tbl );
		return 1; //キャンセルされたので開放した
	}
}

//ジャンプ攻撃Initでステータス設定
//ジャンプ攻撃（着地のMvが変化する攻撃）のMvからしかよんではいけない
Battle_Std.SetStatus_AirAtkStatus <- function()
{
	BMvTbl.SetPP(def_PP_AirAtkStatus,0); //ジャンプ攻撃ステータス初期化
	
	// この処理は一旦オフにしておく（あってもなくても低空アサルトの性能に差が出なかったので）
	// def_MC3_EnableJumpFramePPはジャンプのMVでだけ有効だが、ジャンプからジャンプ攻撃をズラし押ししてアサルトだしたときも使いたいので記憶しておく
	// Battle_Std.PassBeforeMoveCodeEx( 3, def_MC3_EnableJumpFramePP ); // JumpFrameが有効なMVであることの引継ぎ
	
	Battle_Std.MoveCode.AddFlag( def_MC_EnableAirAtkStatus ); // AirAtkStatusが有効なMvとする
	
	//アサルトから飛んできたらフラグを立てる	
	local mvs = BMvTbl.GetMvStatus();
	local mvs_DataPattern = mvs.DataPattern;
	if( mvs_DataPattern==def_PAT_Mv_Assault || mvs_DataPattern==def_PAT_Mv_Assault_Dodge || Battle_Std.ChangeMoveCodeEx_CheckFlag( 7, def_MC7_StdAssult ) || Battle_Std.ChangeMoveCodeEx_CheckFlag( 7, def_MC7_AirAssult ) )
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_inAssault ); // 各種アサルトからフラグを立てる
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_FromAssault ); // アサルトから
		
		local isAirAssult = Battle_Std.ChangeMoveCodeEx_CheckFlag( 7, def_MC7_AirAssult )? 1 : 0;
		
		//MEMO:LPの指定はもういらないと思うけど、念の為残している　※ケイアスで使ってたのも消した
		local type = BMvTbl.GetLP(1); //アサルトのmvからなら設定されているはず
		if( type==1 || isAirAssult ) //空中アサルトだったら
		{
			//空中ダッシュ的に使うのでキャンセル不可は設定しない
			Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_inAirAssault ); // 空中アサルトからフラグを立てる
		}
		else //空中アサルト以外のアサルトは、ジャンプ攻撃にキャンセル不可を設定するのだよ（チェインシフトだけは可能にしておく）
		{
			BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv }); //キャンセル不可
			Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_StdAssultLimitAirAtk2 );//行動不能なのをフラグたて2(def_MC7_StdAssultIgnoreNoMoveの影響なし)
			
			if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_StdAssultIgnoreNoMove ) )
			{
				BMvTbl.SetMoveableFlag( { move=0,time=254, flag=_ClearFlag_ChangeMv }); //着地のMvに行くまで行動不能にする
				Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_StdAssultLimitAirAtk );//行動不能なのをフラグたて
				
			}
			if( Def_Sys_AssultAirAtkCanGuardChainShift )
			{
				// これだけだとシールド成功時もCSできちゃうからCS側のコマンドチェックで弾いてるので注意
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GuardChainShiftOK ); // ガード時CS可能フラグを立てる
			}
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=254, flag=_ClearFlag_ChangeMv } );
			// if( Def_Dbg_AirAtkFlag ) _dm("アサルトによるキャンセル不可");
		}
	}
	
	//のぼりで出したらロケッティアフラグを立てるのだよ
	//ジャンプから出したものじゃないとフラグは立たない（ＣＳ使ったりアサルトからだとフラグは立たない）
	local pos = BMvTbl.GetPosition(); // 位置取得
	local vec = BMvTbl.GetVector(); //ベクトル取得
	local from_jump = ( // ジャンプから出したか
	mvs_DataPattern==def_PAT_Jump_F ||
	mvs_DataPattern==def_PAT_Jump_N ||
	mvs_DataPattern==def_PAT_Jump_B ||
	mvs_DataPattern==def_PAT_MultiJump_F ||
	mvs_DataPattern==def_PAT_MultiJump_N ||
	mvs_DataPattern==def_PAT_MultiJump_B ||
	Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_Jump ) )? 1 : 0;
	
	// print("\n mvs.MvCount:"+mvs.MvCount );
	// _dp("\n from_jump : "+from_jump+" pos.y:"+pos.y/128 );
	
	// TODO:
	// 着地際に発生が遅い攻撃を出した（本来は空振りするようなフレーム）
	// なのに相手にヒットするような場合は、着地際ため攻撃での崩しのはずである
	// 「停滞する遅いジャンプ攻撃」を検知する
	// 空中行動で、何フレーム後に着地予定かを計算していけば
	// 流星パンチみたいなのも同様に検知はできるはず
	
	// 切り替え中段自体無くすことも可能？
	// 攻撃があたる直前にチェックしないとダメなのでもう１段階処理が必要かな
	
	// 前のMvを取得して行動チェック
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_AirAtkGuardHosei ) && mvs.MvCount<21 )
	{
		_dp("\n ジャンプ攻撃を上段に修正")
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ZyodanAirAtk );
		BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
	}
	
	//print("\n vec.y"+vec.y+" pos.y:"+pos.y+" tooly:"+pos.y/128);
	if( from_jump==1 && vec.y < 0 && pos.y > -180*128 ) //のぼり中段の条件なのだよ
	{
		// if( Def_Dbg_AirAtkFlag ) _dm("ロケッティアフラグ");
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Rocketeer ); // ロケッティアフラグ
	}
	
	// アサルト以外のロケッティアは屈ガード可能に
	local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
	// ロケッティアフラグ　＆　アサルトからは除外　＆ＭｖＣｏｕｎｔが一定値以下
	// 地上からの攻撃じゃないとロケッティアフラグは無い方がいいんじゃないかなぁ
	if( ( ( airatk_st&def_PP_AAS_Rocketeer )!=0 ) && ( (airatk_st&def_PP_AAS_inAssault) ==0 ) && mvs.MvCount<21 )
	{
		//ロケッティアならしゃがみガード可能なのだよ
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ZyodanAirAtk );
		BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
		// if( Def_Dbg_AirAtkFlag ) _dm("アサルト以外のロケッティアによる上段化(18F)");
	}
	else if( Battle_Std.IsMatchChangeMvNameArray( ["Mv_Jump_F", "Mv_Jump_N", "Mv_Jump_B"] ) )
	{
		local mvs_bf = BMvTbl.GetMvStatusBF(); // 前の行動のmvstatus
		//限定的に垂直ジャンプからの上段処理を入れる
		local jumpF = mvs_bf.MvCount;
		// local jumpF = BMvTbl.GetPP(def_PP_JumpFrame);//上記MVからならこの値がセットされている　※MV指定なら使わないでOK
		
		local isIgnoreAtk = Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_FastJumpAtkNoThroughCrouch );
		
		if( !isIgnoreAtk )
		{
			local limitMinF = 20;//clrまで18
			local setF = limitMinF - jumpF;
			_dpn("setF:"+setF+" limitMinF:"+limitMinF+" jumpF:"+jumpF);
			if( setF > 0 )
			{
				_dpn("早すぎしゃがみに空振り予約:"+setF+" _GuardFlag_ThroughCrouch:"+_GuardFlag_ThroughCrouch);
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ZyodanAirAtk );
				// BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=setF, flag=_ClearFlag_ChangeMv } );
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_ThroughCrouch, time=setF, flag=_ClearFlag_ChangeMv } );
			}
		}
	}
}

//行動コード関係
Battle_Std.MoveCode <- {};

//行動コードフラグを加える
Battle_Std.MoveCode.AddFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()|flag );
}

//行動コードフラグを消す
Battle_Std.MoveCode.DelFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()&~flag );
}

//行動コードフラグが立ってるかチェックする
//複数書くとどれか一つでも立ってれば成功
Battle_Std.MoveCode.CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetMoveCode()&flag)!=0 )? 1 : 0 );
}

//拡張行動コード関係 ※フラグ間違えないようにMoveCode1とかにした
Battle_Std.MoveCodeEx <- {};

//拡張行動コードフラグを加える
Battle_Std.MoveCodeEx.AddFlag <- function( pos, flag )
{
	BMvTbl.SetMoveCodeEx( pos, BMvTbl.GetMoveCodeEx( pos )|flag );
}

//拡張行動コードフラグを消す
Battle_Std.MoveCodeEx.DelFlag <- function( pos, flag )
{
	BMvTbl.SetMoveCodeEx( pos, BMvTbl.GetMoveCodeEx( pos )&~flag );
}

//拡張行動コードフラグが立ってるかチェックする
Battle_Std.MoveCodeEx.CheckFlag <- function( pos, flag )
{
	return( ( (BMvTbl.GetMoveCodeEx( pos )&flag)!=0 )? 1 : 0 );
}

//前の行動
//拡張行動コードフラグが立ってるかチェックする
Battle_Std.ChangeMoveCodeEx_CheckFlag <- function( pos, flag )
{
	return( ( (BMvTbl.ChangeMv_GetMoveCodeEx( pos )&flag)!=0 )? 1 : 0 );
}

//行動コード関係（プログラム差し替え用）
Battle_Std.MvAction <- {};

//行動コードフラグを加える
Battle_Std.MvAction.AddFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()|flag );
}

//行動コードフラグを消す
Battle_Std.MvAction.DelFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()&~flag );
}

//行動コードフラグが立ってるかチェックする
Battle_Std.MvAction.CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetMoveCode()&flag)!=0 )? 1 : 0 );
}

//汎用全体ステータス関係（全体を初期化されることは無い）
Battle_Std.GS_AddFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_GlobalStatus, BMvTbl.GetPP(def_PP_GlobalStatus)|flag )
}

Battle_Std.GS_DelFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_GlobalStatus, BMvTbl.GetPP(def_PP_GlobalStatus)&~flag )
}

Battle_Std.GS_CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetPP(def_PP_GlobalStatus)&flag)!=0 )? 1 : 0 );
}

Battle_Std.EnemyGS_CheckFlag <- function( flag )
{
	local ret = 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret = Battle_Std.GS_CheckFlag(flag);
		enemy.pop();
	}
	return ret;
}

//BMvCore関係
Battle_Std.Core <- {};

Battle_Std.Core.Push <- function( core )
{
	//Pushしなかったら0を返す
	if( core.IsDone )
	{
		return BMvCore.PushCharaData( core );
	}
	return 0;
}

//coreにfuncをやって戻り値を返す
//戻り値はテーブルじゃないとダメ
Battle_Std.Core.FuncPush <- function( core, func )
{
	local ret = 
	{
		IsDone = 0,
	}
	if( core.IsDone )
	{
		if( BMvCore.PushCharaData( core ) )
		{
			ret = func();
			ret.IsDone <- 1;
		}
		BMvCore.PopCharaData();
	}
	return ret;
}


// スマートステア関係
Battle_Std.SmartSteer <- {};

// 通常技や必殺技のInitで呼ばれる
// スマートステア以外のコマンドを入れたらComboChainのPPを初期化する
Battle_Std.SmartSteer.ClearCheck <- function()
{
	local cmdNum = BMvTbl.GetCmdNumber();
	// _dp("\n cmdNum:"+cmdNum );
	if( cmdNum == 0 ) return 0; // 状態以降とか、コマンドを入れずに飛んできたらここ
	if( cmdNum >= def_CN_SmartSteer_00 && cmdNum <= (def_CN_SmartSteer_00+def_CNP_SmartSteerNumMAX) )
	{
		// _dp("\n スマートステア");
		// スマートステア
		return 0;
	}
	else
	{
		// _dp("\n コマンド入れたね");
		if(Def_Dbg_SmartSteerLog) _dp("\n スマートステア関係ないコマンドを出したらリセット");
		BMvTbl.SetPP(def_PP_StdComboChain,0);
		BMvTbl.SetPP(def_PP_CroComboChain,0);
		BMvTbl.SetPP(def_PP_AirComboChain,0);
		return 1; // クリアしました
	}
	return 0;
}

Battle_Std.SmartSteer.CheckBonus <- function( type=1/* 1:Std 2:Cro 3:Air */ )
{
	local combo_chain = 0;
	switch( type )
	{
	case 1:
		combo_chain = BMvTbl.GetPP(def_PP_StdComboChain);
		break;
	case 2:
		combo_chain = BMvTbl.GetPP(def_PP_StdComboChain); // def_PP_CroComboChain
		break;
	case 3:
		combo_chain = BMvTbl.GetPP(def_PP_AirComboChain);
		break;
	}
	
	/*
	if( Def_Dbg_SmartSteerLog )
	{
		_dp1p("\n[CheckBonus]"+
		" PPtype:"+type+
		" Std:"+BMvTbl.GetPP(def_PP_StdComboChain)+
		" Cro:"+BMvTbl.GetPP(def_PP_StdComboChain)+ // def_PP_CroComboChain
		" Air:"+BMvTbl.GetPP(def_PP_AirComboChain)+
		" combo_chain:"+combo_chain
		);
	}
	*/
	
	local cmdParam = BMvTbl.GetCmdParam(0);
	if( cmdParam&Def_CMDP_ComboChain )
	{
		//アナウンス
		if( def_AISW_SmartSteer ) BMvEff.AttackInfoString_Set({ word=def_AISW_SmartSteer,} );

		//【トロフィー】実戦でスマートステアを使用した。
		// BMvTbl.Achievement_Unlock(0);

		return 1;
	}
	return 0;
}

Battle_Std.SetComboChainMvParam <- function()
{
	local cmdParam = BMvTbl.GetCmdParam(0);
	if( cmdParam&Def_CMDP_StdComboChain )
	{
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_CallComboChainMv );
	}
}

//Cmd関係
// 通常技を出すときにチェックする内容
Battle_Std.CancelCheck_NormalAtk <- function()
{
	if( Def_Dbg_AllMoveAddCommand ) return 1;
	if( Def_Rule_CmdCancelCheck )
	{
		// 行動不能の時（キャンセルの時）
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//必殺技の時は不可
			if( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) )
			{
				// 必殺技から通常技へのキャンセルを許容する、じゃないとダメ
				if( !Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoAtk ) )
				{
					return 0;
				}
			}
			// 通常技へのキャンセルを除外するフラグがあったらそもそも失敗
			if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_NoAtkCansel ) )
			{
				return 0;
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
	}
	return 1;
}

// この辺基本的にサポートキャンセルのチェックにしか使ってないっぽい
Battle_Std.MvRule_Skill_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.Type & _HitType_Damage )
	{
		//print("\nダメージした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Damage );
	}
	else if( hs.Type & _HitType_Guard )
	{
		//print("\nガードした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Guard );				
	}
	if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_SetMutekiDamage ) )
	{
		local isDamage = (hs.Type & _HitType_Damage && hs.isCatchFlag == 0);
		if( isDamage )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=60, muteki_dage=60 } ); //ヒットしたら無敵で上書き
			Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_NoMutekiAnnounce ); // 無敵アナウンスなし
		}
	}
}

Battle_Std.MvRule_Skill_LastUpdate <- function()
{
	if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_SetMutekiDamage ) )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵状態を解除
		Battle_Std.MoveCodeEx.DelFlag( 7, def_MC7_NoMutekiAnnounce ); // 無敵アナウンスなしを解除
	}
}

Battle_Std.MvRule_Atk_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.Type & _HitType_Damage )
	{
		//print("\nダメージした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Damage );
	}
	else if( hs.Type & _HitType_Guard )
	{
		//print("\nガードした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Guard );				
	}
}

// ↑と合わせて呼ばれる
// ジャンプ攻撃
Battle_Std.MvRule_AirAtk_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.isFirstUpdate )
	{
		if( Def_Rule_GameSystem == Def_RGS_CLI )
		{
			// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
	}
}

local callmvname_ar = ["Mv_SupportCharaWait", "Mv_SupportCharaWait2"];

Battle_Std.CallSupport <- function() : (callmvname_ar)
{
}

Battle_Std.CallCancelSupport_Effect <- function()
{
}

Battle_Std.CallSupport_Effect <- function()
{
}

// キャンセルサポート呼べるかどうかざっくりチェック
Battle_Std.CheckSt_CancelSupportCall <- function()
{
}

// ゲージを使ってモーション無しで呼び出す
Battle_Std.CheckandCall_CancelSupport <- function( _spcost=10000 )
{
}

// 切り札効果中とかでモーション無しで呼び出す
Battle_Std.CheckandCall_NoMotionSupport <- function()
{
}

Battle_Std.CheckandCall_GuardCancelSupport <- function()
{
}


// 体力差を取得　0:取得失敗orドロー +:体力勝ち -:体力負け
Battle_Std.GetHPBalance <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	local enemy = BMvCore.GetEnemyCharaData();
	
	if( player.isdone() && enemy.isdone() )
	{
		local myhp = -1;
		local enhp = -1;
		if( player.push() )
		{
			myhp = BMvEff.SetHpGauge( { value=0 } );
			player.pop();
		}
		if( enemy.push() )
		{
			enhp = BMvEff.SetHpGauge( { value=0 } );
			enemy.pop();
		}
		if( myhp != -1 && enhp != -1 )
		{
			return (myhp - enhp);
		}
	}
	return 0;
}

// コンボポイントを乗算
Battle_Std.ComboPoint_Multi <- function( _par )
{
	local cp = BMvTbl.ComboPoint_Calc( { num=0 } );

	local calccp = cp * _par / 100;
	if( calccp < 0 ) calccp = 0; // 下限
	if( calccp > 100 ) calccp = 100; // 上限

	local addcp = calccp - cp;
	if( addcp < -100 || addcp > 100 ) return 0; // 失敗
	
	BMvTbl.ComboPoint_Calc( { num=addcp } );
	
	// _dp("\n CPM計算:"+cp+" -> "+calccp +" (x"+ _par+"%)" );
	return 1;
}
// 体力差を取得　0:取得失敗orドロー +:体力勝ち -:体力負け
Battle_Std.GetHPBalance <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	local enemy = BMvCore.GetEnemyCharaData();
	
	if( player.isdone() && enemy.isdone() )
	{
		local myhp = -1;
		local enhp = -1;
		if( player.push() )
		{
			myhp = BMvEff.SetHpGauge( { value=0 } );
			player.pop();
		}
		if( enemy.push() )
		{
			enhp = BMvEff.SetHpGauge( { value=0 } );
			enemy.pop();
		}
		if( myhp != -1 && enhp != -1 )
		{
			return (myhp - enhp);
		}
	}
	return 0;
}

Battle_Std.SoundStatus_CheckFlag <- function( _flag )
{
	return( BMvTbl.GetPP(def_PP_SoundStatus)&_flag ); // フラグチェック
}

Battle_Std.SoundStatus_AddFlag <- function( _flag )
{
	BMvTbl.SetPP( def_PP_SoundStatus, BMvTbl.GetPP(def_PP_SoundStatus)|_flag ); // フラグ追加
}

Battle_Std.SoundStatus_DelFlag <- function( _flag )
{
	BMvTbl.SetPP( def_PP_SoundStatus, BMvTbl.GetPP(def_PP_SoundStatus)&~_flag ); // フラグ消去
}


// IWE発動後一発殴るだけのオブジェクトを呼ぶ
// BoundCapture状態だと相手にベクトルが入らないため
Battle_Std.IWEXIST_CallOnePunch <- function()
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat=980 } );
}

// 自分のGRDを消費する
// 不足時はenemyadd分を相手に加算する
// costは個数、enemyaddは１個10000ポイントで単位が違うので注意
Battle_Std.UseGRDStock <- function( cost, enemyadd=0 )
{
	// _dp("\n GRD:"+cost+"消費 (相手増加:"+enemyadd+")" );
	if( BMvEff.GRD_CheckStock( { val=cost } ) ) //コストが足りている場合
	{
		BMvEff.GRD_UseStock( { val=cost } ); //消費
	}
	else //コストが足りない場合
	{
		BMvEff.GRD_UseStock( { val=cost } ); //消費して空にする
		
		//相手のGRDを増やす
		if( enemyadd )
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				Battle_Std.GRD_AddValue( { val=enemyadd, boundplus=1 } );
				
				enemy.pop();
			}
		}
	}
}

// Param1(_paramno)が8(_num)なら頭無敵(_flag)を設定する
// FrameUpdateで設定する
// Flag形式に変更
//  8:頭　_HitCheckFlag_Head　※弾のときもあるｗ
// 16:弾　_HitCheckFlag_FireBall
// 32:足　_HitCheckFlag_Legs
// 64:空突　Def_HitCheckFlag_AirDive
local debug_HitMutekiArray = array(1024," - ");
debug_HitMutekiArray[_HitCheckFlag_Head] = "空中攻撃";
debug_HitMutekiArray[_HitCheckFlag_Legs] = "下攻撃";
debug_HitMutekiArray[_HitCheckFlag_FireBall] = "飛び道具";
debug_HitMutekiArray[_HitCheckFlag_Legs|_HitCheckFlag_FireBall] = "飛び道具＆下攻撃";
debug_HitMutekiArray[_HitCheckFlag_Legs|_HitCheckFlag_Head] = "空中攻撃＆下攻撃";
debug_HitMutekiArray[_HitCheckFlag_Head|_HitCheckFlag_FireBall] = "空中攻撃＆飛び道具";

// フラグっぽいんだけど、Setなので上書きなので、複数登録はできない
Battle_Std.SetHitMuteki <- function( _paramno = 1, _num = 8, _flag=_HitCheckFlag_Head ) : (debug_HitMutekiArray)
{
	local lightLegsMutekiYoteiMv = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_LightLegsMuteki ); // 小足属性へ空振り予定
	if( BMvTbl.GetFrameParam( _paramno ) & _num )
	{
		//システムで小足属性へ空振り予定が入っていたら、この命令で消してしまわないようにする
		if( lightLegsMutekiYoteiMv ) _flag = _flag|Def_HitCheckFlag_LightLegs;
		
		// _dp("\n[無敵中です]"+_flag);
		BMvTbl.SetHitCheckFlag( { type=0, val=_flag , time=16, flag=_ClearFlag_ChangeFrame  } ); // 無敵
		
		if( Def_Dbg_HitMutekiLog )
		{
			local mvs = BMvTbl.GetMvStatus();
			if( mvs.CallCount == 0 )
			{
				// _dp("\n！"+debug_HitMutekiArray[_flag]+"無敵中！ F:"+(mvs.MvCount) );
			}
		}
		return 1;
	}
	else
	{
		// 小足無敵だけはフラグさえついていれば設定し続ける
		if( lightLegsMutekiYoteiMv )
		{
			BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs , time=16, flag=_ClearFlag_ChangeFrame  } ); // 無敵
		}
	}
	return 0;
}

// 複数登録する用
// こんな風につかう
// Battle_Std.SetHitMutekiParam1( { [40]=_HitCheckFlag_Legs|_HitCheckFlag_Head, [8]=_HitCheckFlag_Head, [32]=_HitCheckFlag_Legs } );
Battle_Std.SetHitMutekiParam1 <- function( param={} )
{
	local param_val = BMvTbl.GetFrameParam( 1 );
	if( param_val in param )
	{
		Battle_Std.SetHitMuteki( 1, param_val, param[param_val] );
		return 1;
	}
	return 0;
}

//↑の使いにくいので便利に
// Battle_Std.SetHitMuteki2_Param1( { [8]=_HitCheckFlag_Head, [32]=_HitCheckFlag_Legs } );
Battle_Std.SetHitMuteki2_Param1 <- function( param={} )
{
	local param_val = BMvTbl.GetFrameParam( 1 ); //ツールに指定してあるParamを取得
	local add_flag = 0;
	local add_param = 0;
	// _dp("\n param_val:"+param_val );
	foreach( slot, val in param )
	{
		if( param_val&slot )
		{
			// _dp("\n 一致:"+slot );
			add_flag = add_flag|val;
			add_param = add_param|slot;
		}
	}
	if( add_param )
	{
		//_dp("\n 結果["+add_param+"] "+add_flag );
		Battle_Std.SetHitMuteki( 1, add_param, add_flag );
		return 1;
	}
	return 0;
}

Battle_Std.SetHitCheckFlag <- function( _paramno = 1, _num = 8, _flag=_HitCheckFlag_Head, _defaultflag=0 ) : (debug_HitMutekiArray)
{
	if( _defaultflag )
	{
		if( BMvTbl.GetFrameParam( _paramno ) & _num )
		{
			BMvTbl.SetHitCheckFlag( { type=1, val=_flag, time=16, flag=_ClearFlag_ChangeFrame } ); // 属性をつける
		}
		else
		{
			BMvTbl.SetHitCheckFlag( { type=1, val=_defaultflag , time=16, flag=_ClearFlag_ChangeFrame  } ); // 属性をつける
		}
	}
	else
	{
		if( BMvTbl.GetFrameParam( _paramno ) & _num )
		{
			BMvTbl.SetHitCheckFlag( { type=1, val=_flag , time=16, flag=_ClearFlag_ChangeFrame  } ); // 属性をつける
		}
	}
	
	if( Def_Dbg_HitMutekiLog )
	{
		_dp("\n["+debug_HitMutekiArray[_flag]+"]");
	}
}

Battle_Std.SetThrowEnemyMuteki <- function( _mutekiframe = 0 )
{
	Battle_Std.SetCaptureCharaMuteki( _mutekiframe );
	Battle_Std.SetEnemyCharaMuteki( _mutekiframe );
}

// つかみ中の相手を無敵にする 1〜:無敵にする 0:無敵を解除する
Battle_Std.SetCaptureCharaMuteki <- function( _mutekiframe = 0 )
{
	local enemy = BMvCore.GetCaptureCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_dage=_mutekiframe } );
		
		enemy.pop();
	}
}

Battle_Std.SetEnemyCharaMuteki <- function( _mutekiframe = 0 )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_dage=_mutekiframe } );
		
		enemy.pop();
	}
}

// FrameIDっぽいものを返す
// 普段は FrameID を返すが、
// isFrameUpdateの時は　10000　を加算して返す
Battle_Std.GetFrameIDStatus <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	local ret_frameid = mvs.FrameID;
	if( mvs.isFrameUpdate ) ret_frameid += 10000;
	return ret_frameid;
}

// FrameIDっぽいものを返す2
// isFrameUpdateならFrameIDが返るが、そうじゃない時はマイナスにして返す
// ちな着地の時2回入ってくるので直した 150305
// 影響箇所それなりにあるかも
Battle_Std.GetUpdateFrameID <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_frameid = mvs.FrameID;
	// print("\n isup:"+mvs.isFrameUpdate +" isL:"+mvs.isLanding );
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_frameid *= -1;
	return ret_frameid;
}

Battle_Std.CheckFrameUpdateTiming <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) return 0;
	return 1;
}

// Paramっぽいものを返す
// isFrameUpdateならParam1が返るが、そうじゃない時はマイナスにして返す
Battle_Std.GetUpdateParam0 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param0;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam1 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param1;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam2 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param2;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam3 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param3;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}


// 相殺関係の処理
Battle_Std.Sousai <- {};

Battle_Std.Sousai.Init <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Init_NoHitFlag <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_NoHitFlag( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Init_NoGedan <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_NoGedan( _etcHantei ); // 相殺をセット
}

// 飛び道具だけ相殺する
Battle_Std.Sousai.Init_BallTarget <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_BallTarget( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Set <- function( _etcHantei=0 )
{
	// MEMO:_CatchSuccess_HitSub_None を使って、攻撃出現が1以上だと、1→1で減ってない→ヒットしてないで処理が入らない
	// 多段の１発目〜の処理が原因らしい
	// キャラの攻撃出現を0にしておけば大丈夫だけど、リープがダメ（元々これを直すために-1しないようにしたので、現状は×）
	// 攻撃判定が出ている時の相殺判定を消したので発生しなくなったので解決
	// 追撃判定には反応しないように修正
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Erase <- function( _etcHantei=2 )
{
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=0, flag=_ClearFlag_ChangeMv } );
}

Battle_Std.Sousai.Set_NoHitFlag <- function( _etcHantei=0 )
{
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Set_NoGedan <- function( _etcHantei=0 )
{
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkStandGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Set_BallTarget <- function( _etcHantei=0 )
{
	// BMvTbl.SetAtkCatchFlag( { hantei=0, catch_flags=_CatchFlag_AtkAllGuard, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv, check_etc=(1<<2)|(1<<3) } ); // 「飛び道具判定」か「相殺判定」が無いと無効
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv, check_etc=(1<<3) } ); // 「飛び道具判定」が無いと無効
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.FrameUpdate <- function( _etcHantei=0 )
{
	Set( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_NoHitFlag <- function( _etcHantei=0 )
{
	Set_NoHitFlag( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_NoGedan <- function( _etcHantei=0 )
{
	Set_NoGedan( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_BallTarget <- function( _etcHantei=0 )
{
	Set_BallTarget( _etcHantei ); // 相殺をセット
}

// 戻り値を1からMvHitStatusに変更
Battle_Std.Sousai.HitInterrupt <- function( param={} )
{
	local mvhs = BMvTbl.GetMvHitStatus();
	
	// 相殺判定処理
	if( (mvhs.isCatchFlag & (1<<0) ) && BMvTbl.GetLP(9)==0 )
	{
		BMvTbl.SetLP(9,1); // 相殺できない状態にする
		
		//判定チェック
		local enemy = BMvCore.GetLastHitCharaData( 0 ); // そのままの相手を取得
		if( enemy.isdone() )
		{
			if( "nosound" in param && param.nosound )
			{
			}		
			else
			{
				// BSound.SE_Play( { type=_SeType_Normal, num=195 } );
			}
			
			// 自分に補正をかける準備をする？
			// １ヒット目から効果が出ていないと単発と多段でまた変わってくる
			local enemy_exmvcode = 0;
			
			if( enemy.push() )
			{
				enemy_exmvcode = BMvTbl.GetMoveCodeEx( 1 );
				
				// BMvTbl.SetMvHitStatus( enemy_st ); // ヒットストップとか設定
				if( "erase_allhit" in param )
				{
					BMvTbl.CalcHitValue(-10000);
				}
				enemy.pop();
			}
			
			// 相殺時の処理色々
			// ゲーム全体を時間停止する
			// ヒットストップ形式だと飛び道具とかのヒットストップの影響を受けない系がとれなくなっちゃう
			// hitstop_f - 攻撃のヒットストップF（＝先行でチェーンが繋がる猶予F）が仕込みができるフレームになるよ
			local hitstop_f = 24; // 両者が止まる時間停止（ヒットストップのようなもの）
			local pride_win = 0; // 得意属性に打ち勝ったかどうか
			
			//当て身系の相殺は自分専用のフラグをたてておく
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_AtemiSousaiSuccess ); // 当身相殺を成功した
			BMvEff.CreateObject( { mvname="Mv_Null_DelSousaiMutekiFlag" } ); // 相殺の3F無敵の間を無敵状態としないためのフラグ立て

			// 指定があったら固定
			if( "hitstop" in param )
			{
				hitstop_f = param.hitstop;
			}
			else
			{
				// 得意属性のチェック
				local pride = ( "pride" in param )? param.pride : 0;
				if( pride )
				{
					if( enemy_exmvcode&pride )
					{
						// _dp("\n 得意属性なので打ち勝つ");
						pride_win = 1; // 得意属性に打ち勝った
						hitstop_f = 18; // ストップが短い
					}
				}

				// デフォルトで得意属性なもの
				if( enemy_exmvcode&def_MC1_AtkLow )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // 弱攻撃に対しては常にストップが短い
				}
				if( enemy_exmvcode&def_MC1_AtkImpact )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // インパクトも同じ
					
					// さらに自分に打撃無敵をつける？
					// XXX:これやるとMv抜けちゃったときヤバイけど見なかったことに
					BMvEff.SetPlayerTimer( { muteki_dage=12 } );
				}
				if( enemy_exmvcode&def_MC1_VeryWeakImpactAtk )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 8; // 超弱い
				}
				
				
				if( pride_win )
				{
					// 相手のヒットストップを増やす
					if( enemy.push() )
					{
						BMvTbl.SetHitStop( 8, _ValAdd ); // 相手のヒットストップだけ伸ばす
						
						enemy.pop();
					}
				}
			}
			
			// インパクトしたらキャンセルできないバージョン
			// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
			
			Battle_Std.CallAntenStopObject();//これを呼んで暗転中として無敵アナウンスが呼ばれないようにする
			BMvEff.SetStopTime( { time=hitstop_f, stopme=2, bounderase=1 } );
			
			if( enemy.push() )
			{
				local setNoCommandDelay = ("nocommanddelay" in param && param.nocommanddelay == 1)? 1 : 0;
				if( hitstop_f <= 3 || setNoCommandDelay )
				{
					// ヒットストップ短くて受付時間増加すると暴発する
					_dpn("ヒットストップ短いのでやらない");
				}
				else
				{
					// 時間停止後先行入力がきくように処理を追加
					// これがないと、時間停止が終わった瞬間にボタンを押さないと次の技が出せない
					// あってもややシビアなレベル
					BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
				}
				enemy.pop();
			}			

			if( "noquake" in param && param.noquake )
			{
			}
			else
			{
				BMvEff.SetCamera_Quake( { time=hitstop_f, type=2, } );
			}
			
			if( "noeffect" in param && param.noeffect )
			{
			}
			else
			{
				local eff = BMvEff.CreateObject( { datatype=1, start_pat="Eff_Sousai", y=-200*128 } );
				if( eff.push() )
				{
					BMvTbl.SetPrio( _CharaPrio_Near );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
					
					eff.pop();
				}
			}
			
			// 相殺成功状態を消す。これをしないと何度もヒットインタラプト入ってくる
			BMvTbl.ClearHitStatus(); //ヒット情報初期化（ヒット情報が消えるのでキャンセルとかに影響がある）
			
			return mvhs; // ヒットステータスを返す
		}
		return 0;
	}
	return 0;
}

//互換性のために↑は残す
//新相殺処理
Battle_Std.Atemi <- {};

Battle_Std.Atemi.Init <- function( param={} )
{
	local _etcHantei = ("hantei" in param )? param.hantei : 0;
	local _sousaiFlags = ("flags" in param )? param.flags : 0;

	BMvTbl.SetPP(def_PP_SousaiEtcHantei,_etcHantei);
	BMvTbl.SetPP(def_PP_SousaiFlags,_sousaiFlags);
	
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set(); // 相殺をセット
}

Battle_Std.Atemi.Set <- function()
{
	local _etcHantei = BMvTbl.GetPP(def_PP_SousaiEtcHantei);
	// MEMO:_CatchSuccess_HitSub_None を使って、攻撃出現が1以上だと、1→1で減ってない→ヒットしてないで処理が入らない
	// 多段の１発目〜の処理が原因らしい
	// キャラの攻撃出現を0にしておけば大丈夫だけど、リープがダメ（元々これを直すために-1しないようにしたので、現状は×）
	// 攻撃判定が出ている時の相殺判定を消したので発生しなくなったので解決
	// 追撃判定には反応しないように修正
	
	local flags = BMvTbl.GetPP(def_PP_SousaiFlags);
	
	local c_flags = _CatchFlag_AtkStandGuard|_CatchFlag_AtkAirGuard|_CatchFlag_AtkCrouchGuard|_CatchFlag_Invalid_Through_ExceptBound;
	local s_flags = _CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy;
	local c_etc = 0;
	
	if( flags&def_PP_SFS_NoHit )
	{
		s_flags = Battle_Std.Val_DelFlag( s_flags, _CatchSuccess_FlagHit_Enemy );
	}
	if( flags&def_PP_SFS_BallTarget )
	{
		c_etc = (1<<3);// 「飛び道具判定」が無いと無効
	}
	if( flags&def_PP_SFS_NoGedan )
	{
		// _dp("\n 下段とれなーい");
		c_flags = Battle_Std.Val_DelFlag( c_flags, _CatchFlag_AtkCrouchGuard );
	}
	
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=c_flags, success_flags=s_flags, check_etc=c_etc, time=64, flag=_ClearFlag_ChangeMv } );
	Battle_Std.PP_DelFlag(def_PP_SousaiFlags,def_PP_SFS_NoSousai); // HitInterruptで1になるのを初期化
}

Battle_Std.Atemi.FrameUpdate <- function()
{
	Set(); // 相殺をセット
}

// 戻り値を1からAtemiHitStatusに変更
//当身戻り値用クラス

class AtemiHitStatus{

	done_ = 0;
	mvhs_ = 0; //MvHitStatus

    constructor()
    {
		done_ = 0;
		mvhs_ = 0;
    }
	
	function IsOk( mvhs )
	{
		done_ = 1;
		mvhs_ = mvhs;
	}
	
	function IsTiming()
	{
		if( IsDone() )
		{
			return (mvhs_.isFirstUpdate)? 1 : 0;
		}
		return 0;
	}

	function IsDone()
	{
		return done_;
	}
};

Battle_Std.Atemi.HitInterrupt <- function( param={} )
{
	local ahs = AtemiHitStatus();
	local mvhs = BMvTbl.GetMvHitStatus();
	
	// 相殺判定処理
	if( (mvhs.isCatchFlag & (1<<0) ) && Battle_Std.PP_CheckFlag(def_PP_SousaiFlags,def_PP_SFS_NoSousai)==0 )
	{
		Battle_Std.PP_AddFlag(def_PP_SousaiFlags,def_PP_SFS_NoSousai);// 相殺できない状態にする
		
		//判定チェック
		local enemy = BMvCore.GetLastHitCharaData( 0 ); // そのままの相手を取得
		if( enemy.isdone() )
		{
			ahs.IsOk( mvhs ); // 有効化
			
			if( "nosound" in param && param.nosound )
			{
			}		
			else
			{
				BSound.SE_Play( { type=_SeType_Normal, num=195 } );
			}
			
			// 自分に補正をかける準備をする？
			// １ヒット目から効果が出ていないと単発と多段でまた変わってくる
			local enemy_exmvcode = 0;
			
			if( enemy.push() )
			{
				enemy_exmvcode = BMvTbl.GetMoveCodeEx( 1 );
				
				// BMvTbl.SetMvHitStatus( enemy_st ); // ヒットストップとか設定
				if( "erase_allhit" in param )
				{
					BMvTbl.CalcHitValue(-10000);
				}
				enemy.pop();
			}
			
			// 相殺時の処理色々
			// ゲーム全体を時間停止する
			// ヒットストップ形式だと飛び道具とかのヒットストップの影響を受けない系がとれなくなっちゃう
			// hitstop_f - 攻撃のヒットストップF（＝先行でチェーンが繋がる猶予F）が仕込みができるフレームになるよ
			local hitstop_f = 24; // 両者が止まる時間停止（ヒットストップのようなもの）
			local pride_win = 0; // 得意属性に打ち勝ったかどうか

			//当て身系の相殺は自分専用のフラグをたてておく
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_AtemiSousaiSuccess ); // 当身相殺を成功した
			BMvEff.CreateObject( { mvname="Mv_Null_DelSousaiMutekiFlag" } ); // 相殺の3F無敵の間を無敵状態としないためのフラグ立て

			if( "e_hitstopAdd" in param )
			{
				// 相手のヒットストップを増やす
				if( enemy.push() )
				{
					// Addにするとどんどん増えていってしまう
					// Setもおかしい気はするが、Addよりはマシ
					// オブジェクトに対してやるとき、そのオブジェクトのフラグ次第で親のアニメがおかしくなるのでチェックを厳密にした
					if( !enemy.isPlayer() )
					{
						if( !BMvEff.CheckObjectFlags( { flags=_ObjFlags_ToParentStop } ) )
						{
							// _dpn("プレイヤーじゃなくて親に伝えないならそもそもヒットストップ加算する意味はほとんどない");
							if( Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_EnableAtemiCatchedHitStopAddObject ) ) // 当身取られたときにヒットストップを増やす処理あり
							{
								BMvTbl.SetHitStop( param.e_hitstopAdd, _ValSet ); // 相手のヒットストップだけ伸ばす
							}
						}
						else if( BMvEff.CheckObjectFlags( { flags=_ObjFlags_ToParentStop } ) && !BMvEff.CheckObjectFlags( { flags=_ObjFlags_FromParentStop } ) )
						{
							// _dpn("オブジェクト＆親にヒットストップを伝えるけど自分は影響を受けない＝無限ループになる");
						}
						else
						{
							BMvTbl.SetHitStop( param.e_hitstopAdd, _ValSet ); // 相手のヒットストップだけ伸ばす
						}
					}
					else
					{
						BMvTbl.SetHitStop( param.e_hitstopAdd, _ValSet ); // 相手のヒットストップだけ伸ばす
					}
					enemy.pop();
				}
			}
			
			// 指定があったら固定
			if( "hitstop" in param )
			{
				hitstop_f = param.hitstop;
			}
			else
			{
				// 得意属性のチェック
				local pride = ( "pride" in param )? param.pride : 0;
				if( pride )
				{
					if( enemy_exmvcode&pride )
					{
						// _dp("\n 得意属性なので打ち勝つ");
						pride_win = 1; // 得意属性に打ち勝った
						hitstop_f = 18; // ストップが短い
					}
				}

				// デフォルトで得意属性なもの
				if( enemy_exmvcode&def_MC1_AtkLow )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // 弱攻撃に対しては常にストップが短い
				}
				if( enemy_exmvcode&def_MC1_AtkImpact )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // インパクトも同じ
					
					// さらに自分に打撃無敵をつける？
					// XXX:これやるとMv抜けちゃったときヤバイけど見なかったことに
					BMvEff.SetPlayerTimer( { muteki_dage=12 } );
				}
				if( enemy_exmvcode&def_MC1_VeryWeakImpactAtk )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 8; // 超弱い
				}
				
				
				if( pride_win )
				{
					// 相手のヒットストップを増やす
					if( enemy.push() )
					{
						BMvTbl.SetHitStop( 8, _ValAdd ); // 相手のヒットストップだけ伸ばす
						
						enemy.pop();
					}
				}
			}
			
			// インパクトしたらキャンセルできないバージョン
			// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
			
			Battle_Std.CallAntenStopObject();//これを呼んで暗転中として無敵アナウンスが呼ばれないようにする
			BMvEff.SetStopTime( { time=hitstop_f, stopme=2, bounderase=1 } );
			
			if( enemy.push() )
			{
				local setNoCommandDelay = ("nocommanddelay" in param && param.nocommanddelay == 1)? 1 : 0;
				if( hitstop_f <= 3 || setNoCommandDelay )
				{
					// ヒットストップ短くて受付時間増加すると暴発する
					// _dpn("ヒットストップ短いのでLongDelayをやらない");
				}
				else
				{
					// 時間停止後先行入力がきくように処理を追加
					// これがないと、時間停止が終わった瞬間にボタンを押さないと次の技が出せない
					// あってもややシビアなレベル
					BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
				}
				enemy.pop();
			}
			
			if( "noquake" in param && param.noquake )
			{
			}
			else
			{
				BMvEff.SetCamera_Quake( { time=hitstop_f, type=2, } );
			}
			
			if( "noeffect" in param && param.noeffect )
			{
			}
			else
			{
				local limiteffect = ( "limiteffect" in param && param.limiteffect )
				local eff = BMvEff.CreateObject( { datatype=1, start_pat=(limiteffect)? "Eff_SousaiLimit" : "Eff_Sousai", y=-200*128 } );
				if( eff.push() )
				{
					BMvTbl.SetPrio( _CharaPrio_Near );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
					
					eff.pop();
				}
			}
			
			// 相殺成功状態を消す。これをしないと何度もヒットインタラプト入ってくる
			BMvTbl.ClearHitStatus(); //ヒット情報初期化（ヒット情報が消えるのでキャンセルとかに影響がある）
			
			return ahs;
		}
	}
	return ahs;
}




// ■ジャンプステータスフラグ
// 前後Ｎジャンプから着地まで有効、着地で０になるフラグ
// 空中必殺技の回数制限にも使用する
// サンプル
// Battle_Std.JumpStatus.Set( def_PP_JS_SkillLimit0 );

Battle_Std.JumpStatus <- {};

Battle_Std.JumpStatus.Set <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)|flag ) ); 
}

// 他と書式がちがうのでAddもいちおう追加
Battle_Std.JumpStatus.Add <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)|flag ) ); 
}

Battle_Std.JumpStatus.Del <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)&~flag ) ); 
}

Battle_Std.JumpStatus.Check <- function( flag )
{
	if( BMvTbl.GetPP(def_PP_JumpStatus)&flag ) return 1;
	return 0;
}

// オブジェクトの食らい判定に攻撃判定があたっているかの汎用チェック
// 飛び道具相殺効果もデフォルトでつけるようにした
// 戻す値をフラグにした
// (1<<0) : やられ
// (1<<1) : 相殺
Battle_Std.CheckObjectisYarare <- function( param={} )
{
	local ret_flags = 0;
	local subed = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_YarareObject_AnySousai );
	if( !subed )
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_CheckSousaiYarareObject ); // 飛び道具と相殺する壊せるオブジェクト 毎フレーム設定する意味はないが影響範囲を狭めた
		Battle_Std.CheckSousai(); // ここでフラグ付与して下の処理にいく
	}
	if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_YarareObject_AnySousai ) )
	{
		// 相手側からしかフラグが立たないこともある
		Battle_Std.MoveCodeEx.DelFlag( 2, def_MC2_YarareObject_AnySousai )
		
		ret_flags = Battle_Std.Val_AddFlag(ret_flags,(1<<1)); // 相殺成功
	}
	local check_yarare = Battle_Std.CheckObjectHanteiCross( _Hantei_Kurai, param );
	if( check_yarare )
	{
		ret_flags = Battle_Std.Val_AddFlag(ret_flags,(1<<0)); // やられ
	}
	// _dpn("ret_flags:"+ret_flags+" subed:"+subed);
	return ret_flags;
}

// オブジェクトの判定に攻撃判定があたっているかの汎用チェック
// 当身ではなくオブジェクトが被弾して消える処理に使う
Battle_Std.CheckObjectHanteiCross <- function( _hantei, param={} )
{
	local stoptime = ("stoptime" in param)? param.stoptime : 0;
	local pride = ("pride" in param)? param.pride : 0;
	local checkflag = ("checkflag" in param)? param.checkflag : _HC_EnemyPc|_HC_EnemyObj|_HC_WithoutNoHanteiFlagObj;
	local retcore = ("retcore" in param)? param.retcore : 0;

	local enemy = BMvEff.CheckHantei( { src=[ _hantei, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=checkflag } );
	if( enemy.push() )
	{
		// 攻撃出現チェック
		local lefthitcount = BMvTbl.CalcHitValue(0);
		
		local e_mvcode = BMvTbl.GetMoveCode();
		local e_mvcode_2 = BMvTbl.GetMoveCodeEx(2);
		local atkGuardFlag = BMvTbl.GetAtkGuardFlag();
		local fbs = Battle_Std.GetFireBallStatus();
		
		enemy.pop();
		
		/*
		// このチェックは行わない
		// 本体でガードして防ぐみたいなのは一切不可能にして、一気に消えてしまうのを許容する
		// 設置＞前にいく＞ガード＞持続部分で設置に攻撃、のときに守れてしまうのを除外
		if( lefthitcount <= 0 )
		{
			return 0;// 残りヒット数が0の矩形は無視
		}
		*/
		if( atkGuardFlag&_GuardFlag_ThroughExceptBound )
		{
			return 0; // 追撃判定は除外
		}
		/*
		if( e_mvcode_2&def_MC2_NoBreakObject )
		{
			return 0;// 壊せない属性
		}
		*/
		
		// 以前は投げで壊せる攻撃もあったが今作はナシで揃えたい
		if( e_mvcode_2&def_MC2_SkillThrow )
		{
			return 0;// 投げ属性
		}
		if( e_mvcode&def_MC_Throw )
		{
			return 0; // 投げ属性
		}

		// ここからは個別に変更可能
		// 弱で消せるのか、飛び道具で消せるのかは重要になってくる
		if( Def_Sys_NewTrapYarareCheck >= 3 )
		{
			// 弱のチェックをしない
		}
		else
		{
			if( e_mvcode&def_MC_GRDLowBreak && pride && 0 in pride && pride[0]&def_MC_GRDLowBreak )
			{
				return 0; // 弱攻撃
			}
		}
		
		if( Def_Sys_NewTrapYarareCheck >= 2 )
		{
			// 弾のチェックをしない
		}
		else
		{
			if( e_mvcode&def_MC_FireBall && pride && 0 in pride && pride[0]&def_MC_FireBall )
			{
				return 0; // 弾属性
			}
			if( e_mvcode&def_MC_FireBallRect && pride && 0 in pride && pride[0]&def_MC_FireBallRect )
			{
				return 0; // 弾属性2（本体とか・FireBallじゃないやつ）
			}
		}
		
		// 飛び道具のInit通過前はSousaiでの処理がうまくいかないので検知しない
		// FireBallの相殺フラグがInit_Stdで設定されるので、単純に矩形が触れてすぐ処理をするとうまくいかない
		if( fbs.isFireBall && fbs.isBeforeFireBallInit )
		{
			// _dpn("まだInit通過していないので当たってないことにする");
			return 0;
		}
		if( retcore ) return enemy;
		return 1;
	}
	return 0;
}

Battle_Std.SetVector_ReduceYVecNoLanding <- function( _offydot=0 )
{
	// 着地しない程度にベクトル収束
	local vec = BMvTbl.GetVector(0);
	if( vec.y > 0 )
	{
		//div0回避がないので変更、落下中しかそもそもやらない
		local pos = BMvTbl.GetPosition(0);
		local count = -((_offydot<<7) + pos.y ) / vec.y;
		
		BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=0, addy=0, flags=_Vector_Normal } );
		if( count > 0 )
		{
			BMvTbl.SetVector( { y=vec.y, addy=-vec.y/count, flags=_Vector_Div } );
		}
	}
}

// 指定フレームで着地するベクトルを与える
Battle_Std.SetVector_YVecFrameLanding <- function( _frame=22 )
{
	// 着地しない程度にベクトル収束
	local vec = BMvTbl.GetVector(0);
	local pos = BMvTbl.GetPosition(0);
	local yvec = -( pos.y ) / _frame;
	// _dp("\n count:"+count);
	
	BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=yvec, addy=0, flags=_Vector_Normal } );
	if( count > 0 )
	{
		// BMvTbl.SetVector( { y=vec.y, addy=-vec.y/count, flags=_Vector_Div } );
	}
}

// HitInterruptで使うもの
// 攻撃があたるタイミングで１を返す
Battle_Std.CheckDamageTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckDamageTiming_OnlyPartner <- function( _check_strict = 0 )
{
	return 0;
}

//FrameIDの一致チェック、配列にも対応
Battle_Std.CheckFrameID <- function( _FrameID )
{
	local mvs = BMvTbl.GetMvStatus();
	switch( typeof _FrameID )
	{
	case "integer":
		if( mvs.FrameID == _FrameID ) return 1;
		break;
	case "array":
		foreach( i_param in _FrameID )
		{
			if( mvs.FrameID == i_param ) return 1;
		}
		break;
	}
	return 0;
}

Battle_Std.CheckDamageTiming_FrameID <- function( _FrameID = 0 )
{
	if( Battle_Std.CheckFrameID( _FrameID ) && Battle_Std.CheckDamageTiming() )
	{
		return 1;
	}
	return 0;
}

Battle_Std.GetUpdateFrameID_DamageTiming <- function()
{
	if( Battle_Std.CheckDamageTiming() )
	{
		return Battle_Std.GetUpdateFrameID();
	}
	return 0;
}

// ↑のダウン追い討ちを除外したバージョン
Battle_Std.CheckDamageTiming_ExceptDown <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 && mvhs.IsDown() == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckDamageTiming_ExceptDownFrameID <- function( _FrameID = 0 )
{
	if( Battle_Std.CheckFrameID( _FrameID ) && Battle_Std.CheckDamageTiming_ExceptDown() )
	{
		return 1;
	}
	return 0;
}

// ガードされた時
// 相殺・シールド時も入る
Battle_Std.CheckGuardTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Guard && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckGuardTiming_FrameID <- function( _FrameID = 0 )
{
	if( Battle_Std.CheckFrameID( _FrameID ) && Battle_Std.CheckGuardTiming() )
	{
		return 1;
	}
	return 0;
}

// ヒット時(ダメージ・ガード)
// 相手のMS当て身成功時は入ってこない
// シールド時は入る
// 攻撃判定同士の相殺でも入る
Battle_Std.CheckHitTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	// 当身関係だと_HitType_Playerの処理が抜けている
	// UNIだとパートナーキャラが居ないので、一旦そのチェックをなくして対応する
	// 当身取られてるときは除外している（基本的に分岐してほしくないため）
	if( mvhs.isFirstUpdate && (mvhs.Type&_HitType_Hit || mvhs.Type&_HitType_SuperArmor) && mvhs.isCatchFlag == 0 ) // && mvhs.Type&_HitType_Player
	{
		return 1;
	}
	return 0;
}

// 当身で取られててもヒット扱い
// 触れてりゃいいだろみたいなてきとーなヒット分岐
Battle_Std.CheckAnyHitTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	// 当身関係だと_HitType_Playerの処理が抜けている
	// UNIだとパートナーキャラが居ないので、一旦そのチェックをなくして対応する
	// 当身取られてるときは除外している（基本的に分岐してほしくないため）
	if( mvhs.isFirstUpdate && (mvhs.Type&_HitType_Hit || mvhs.Type&_HitType_SuperArmor) ) // && mvhs.Type&_HitType_Player
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckHitTiming_FrameID <- function( _FrameID = 0 )
{
	if( Battle_Std.CheckFrameID( _FrameID ) && Battle_Std.CheckHitTiming() )
	{
		return 1;
	}
	return 0;
}


//相手の相殺判定にとられた or 攻撃判定同士があたって相殺したら
//シールドされたときは入らない
Battle_Std.CheckSousaiHitTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	// mvhs.Type&_HitType_Player : ヒットじゃないので入らない
	// mvhs.isCatchFlag&(1<<1)   : 相手の相殺判定に取られたときは有効
	// if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Sousai && mvhs.isCatchFlag&(1<<1) ) // 
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Sousai ) // シンプルに各種相殺で有効にする
	{
		return 1;
	}
	return 0;
}

//ヒット扱いになる当身をとられた時
//エンキドゥの214+AorBが該当。Cやアカツキは空振り扱いなので入ってこない
//ヒット扱い = _CatchSuccess_FlagHit_Enemy がついた当身のみ
Battle_Std.CheckCatchedTiming_FlagHit <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag )
	{
		return 1;
	}
	return 0;
}


//HitInterrupt用
Battle_Std.AddDamageFlagInterrupt <- function( flag )
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 )
	{
		//0やisFirstUpdateだと初段ヒット時に入らないので二回やるためにCount<=1にしている
		if( mvhs.Count <= 1 )
		{
			Battle_Std.EnemyDamageFlag_Add( flag );
			return 1;
		}
	}
	return 0;
}

// 切り札空振り時の効果セット
Battle_Std.SetKirifudaKaraburiEffect <- function()
{
}

Battle_Std.AddBlast_SPSkill <- function()
{
}

// ボール化やられ関係
Battle_Std.BallBound <- {};

Battle_Std.BallBound.CallDummy <- function( param={} )
{
}

// 空中ダッシュの最低高さを保障するためにベクトルをセットする
// ※DivKeepなので、着地した後に浮く可能性があるので使用には気をつける(_safeVec=0のときが危ない)
Battle_Std.SetDivKeepVector_AirDashMinHeight <- function( _minHeight = def_POS_AirDashHoseiMinHeight, _safeVec=1 )
{
	// 高度が低い場合上ベクトルの補正をかける
	local pos = BMvTbl.GetPosition( 0 );
	if( pos.y >= -_minHeight )
	{
		local divf = 5;
		local hosei = (-_minHeight - pos.y)/divf; // 10Fでいくよ
		local hosei_add = -hosei/(divf*2);
		// _dp("\n hosei:"+hosei+" hosei_add:"+hosei_add );
		if( hosei < 0 && hosei_add <= 0 )
		{
			hosei_add = 1; // これを入れないと浮き続ける
		}
		// _dp("\n pos.y:"+(pos.y/128)+" _minHeight:"+(-_minHeight/128)+" 修正:"+(hosei/128)+"*"+divf )
		// _dp("\n hosei:"+hosei+" -hosei/(divf*2):"+ (-hosei/(divf*2)) );
		local useFlags = (_safeVec==1)? _Vector_Normal : _Vector_DivKeep;
		BMvTbl.SetVector( { y=hosei, addy=hosei_add, flags=useFlags } );
		return 1;
	}
	return 0;
}

// 数フレーム無敵にしてつかみを開放する
// 通常投げの演出用
Battle_Std.ThrowRelease_SetMuteki <- function( param={} )
{
	BMvEff.ThrowRelease( param );
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=2, muteki_dage=2 } );
		enemy.pop();
	}
}

// 投げ演出用の攻撃判定でるまで相手を無敵にする関数
// def_PP_GS_ThrowAtkAppearedを見る
Battle_Std.SetEnemyMuteki_Throw <- function()
{
	// ↑の後じゃないとダメ？
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc  } );
	// _dp("\n "+enemy.isdone() +" flag:"+ Battle_Std.GS_CheckFlag( def_PP_GS_ThrowAtkAppeared ) );
	if( Battle_Std.GS_CheckFlag( def_PP_GS_ThrowAtkAppeared ) ) // 過去に攻撃判定が相手に重なったことがあるかどうか
	{
		// 攻撃判定が一度でも出た後なので、基本的に何もしないでいいはず
	}
	else
	{
		// まだ攻撃判定がでたことがないので、判定が出るまでは相手を無敵にします
		if( enemy.isdone() )
		{
			// 攻撃判定が重なっているので、相手の無敵を解除
			if( enemy.push() )
			{
				// _dp(" -> 攻撃判定が重なっている" );
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
				
				enemy.pop();
				
				Battle_Std.GS_AddFlag( def_PP_GS_ThrowAtkAppeared );
			}
		}
		else
		{
			local n_enemy = BMvCore.GetEnemyCharaData();
			// 攻撃判定がまだ重なってないので、無敵にしておく
			if( n_enemy.push() )
			{
				// _dp(" -> 攻撃判定が重なってない" );
				BMvEff.SetPlayerTimer( { muteki_nage=6, muteki_dage=6 } );
				
				n_enemy.pop();
			}
		}
	}
}


// 無敵で投げ開放まとめ
Battle_Std.MutekiThrowRelease_Init <- function()
{
	Battle_Std.GS_DelFlag( def_PP_GS_ThrowAtkAppeared );
}

Battle_Std.MutekiThrowRelease <- function( param={} )
{
	local mvs = BMvTbl.GetMvStatus(); // ステータス取得
	if( mvs.isFrameUpdate )
	{
		if( mvs.FrameID == param.FrameID )
		{
			BMvEff.ThrowParam( { x=param.x, y=param.y } );
			Battle_Std.ThrowRelease_SetMuteki( { type=param.type, airrecover=0, flags=0 } );
		}
	}
	Battle_Std.SetEnemyMuteki_Throw(); // 攻撃判定が出るまで相手を無敵にする
}


// 相手との距離が一定以下にならないように近づく
Battle_Std.AddXPos_NearEnemy <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		local eposst = BMvEff.GetPointStatus( { target=enemy } );
		
		// 相手との距離から最低距離を引いて、あと何ドットまで近づいていいか出す
		local e_maxx = (eposst.distance_x - _minx);
		if( e_maxx < addx ) addx = e_maxx; // 補正をかける
	}
	BMvTbl.SetPosition( { x=addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 相手との距離が一定以下にならないように相手を引き寄せる
Battle_Std.SnapNearEnemy <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		local eposst = BMvEff.GetPointStatus( { target=enemy } );
		
		// 相手との距離から最低距離を引いて、あと何ドットまで近づいていいか出す
		local e_maxx = (eposst.distance_x - _minx);
		if( e_maxx < addx ) addx = e_maxx; // 補正をかける
		
		if( enemy.push() )
		{
			BMvTbl.SetPosition( { x=addx, flags=_Position_Add|_Position_ChangeMuki } );
			
			enemy.pop();
		}
	}
}

// ステージ端との距離が一定以下にならないように近づく
Battle_Std.AddXPos_CheckFrontStage <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local kabe_kyori = Battle_Std.GetFrontStageDistance(); // 壁までの距離
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < addx ) addx = kabe_maxx; // 補正をかける
	// _dp("\n kabe_kyori:"+kabe_kyori+" kabe_maxx:"+kabe_maxx+" -> "+addx );
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 背後のステージ端との距離が一定以下にならないように近づく
Battle_Std.AddXPos_CheckBackStage <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local kabe_kyori = Battle_Std.GetBackStageDistance(); // 壁までの距離
	// _dp("\n kabe_kyori:"+kabe_kyori );
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < -addx ) addx = -kabe_maxx; // 補正をかける
	// _dp("\n kabe_kyori:"+kabe_kyori+" kabe_maxx:"+kabe_maxx+" -> "+addx+" _offx:"+_offx );
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 前方の画面端との距離
Battle_Std.AddXPos_CheckFromtCorner <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離

	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } ); // 画面内の端座標取得
	local kabe_kyori = ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx; // 自分の向きに応じて画面端とする座標を変える
	
	if( kabe_kyori < 0 )
	{
		kabe_kyori *= -1; // 距離にしたいので正の値にする
	}
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < addx ) addx = kabe_maxx; // 補正をかける
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 背後の画面端から出現
Battle_Std.SetXPos_BackCorner <- function( _offx=0 )
{
	_offx = _offx<<7;
	
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local muki = BMvTbl.GetMuki();
	local target_xpos = ( muki == 1 )? pos.sx : pos.ex;
	BMvTbl.SetPosition( { x=target_xpos+(muki*_offx) } );
}

// 前方の画面端から出現
Battle_Std.SetXPos_FrontCorner <- function( _offx=0 )
{
	_offx = _offx<<7;
	
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local muki = BMvTbl.GetMuki();
	local target_xpos = ( muki == 1 )? pos.ex : pos.sx;
	BMvTbl.SetPosition( { x=target_xpos+(muki*_offx) } );
}

// 相手までの距離
// 相手との距離を見て近かったら1を返す
// 自分の背後に相手がいる場合も1を返すので注意（歩きすぎとかはおこらないので安全）
Battle_Std.CheckEnemyDistance <- function( _xkyori )
{
	_xkyori = _xkyori<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori < _xkyori )
		{
			return 1;
		}
	}
	return 0;
}

// 範囲内なら
// ※Battle_Std.CheckEnemyDistanceと組み合わせて使うと、==_xminや==_xmaxの時取得できないので注意
// そういうときは「Battle_Std.GetEnemyDistanceStatus」使って
Battle_Std.CheckEnemyDistance2 <- function( _xmin, _xmax )
{
	_xmin = _xmin<<7;
	_xmax = _xmax<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori > _xmin && kyori < _xmax )
		{
			return 1;
		}
	}
	return 0;
}

// 相手との距離を見る
// -4:範囲より手前
//  1:範囲内
// -6:範囲より外
//  0:敵取得失敗
Battle_Std.GetEnemyDistanceStatus <- function( _xmin, _xmax )
{
	_xmin = _xmin<<7;
	_xmax = _xmax<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori > _xmin && kyori < _xmax )
		{
			return 1;
		}
		else if( kyori <= _xmin )
		{
			return -4;
		}
		else if( kyori >= _xmax )
		{
			return -6;
		}
	}
	return 0;
}


// 相手との距離を返す
// 自分の背中にいる場合はマイナスを返す
Battle_Std.GetEnemyDistance <- function()
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		return kyori;
	}
	return 0;
}

// 向いてる向きでの距離チェック系 似たような関数が別にあるけどこっちを使おう
// ステージ端までが近いかどうかチェック
Battle_Std.CheckFrontStageDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetFrontStageDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckBackStageDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetBackStageDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 前方のステージ端までの距離を返す
Battle_Std.GetFrontStageDistance <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	return( ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX - pos.x ) : ( def_POS_GamenHajiX + pos.x) );
}

// 後方のステージ端までの距離を返す
Battle_Std.GetBackStageDistance <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	return( ( BMvTbl.GetMuki() == -1 )? ( def_POS_GamenHajiX - pos.x ) : ( def_POS_GamenHajiX + pos.x) );
}

// 近いステージ端までの距離を返す
Battle_Std.GetNearStageDistance <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	return( ( pos.x > 0 )? ( def_POS_GamenHajiX - pos.x ) : ( def_POS_GamenHajiX + pos.x) );
}

// ラウンド終了時はチェックする壁を変える
Battle_Std.CheckFromtCornerDistance_with_RoundEnd <- function( _xkyori=0 )
{
	// ラウンドが終了しているかどうか
	if( Battle_Std.RoundisEnd() )
	{
		// 見た目どおりの端の距離でチェック
		return Battle_Std.CheckFromtDispCornerDistance( _xkyori );
	}
	else
	{
		// 拡縮とかの影響を受けない端の距離でチェック
		return Battle_Std.CheckFromtCornerDistance( _xkyori );
	}
}

// ラウンド終了時はチェックする壁を変える
Battle_Std.CheckBackCornerDistance_with_RoundEnd <- function( _xkyori=0 )
{
	// ラウンドが終了しているかどうか
	if( Battle_Std.RoundisEnd() )
	{
		// 見た目どおりの端の距離でチェック
		return Battle_Std.CheckBackDispCornerDistance( _xkyori );
	}
	else
	{
		// 拡縮とかの影響を受けない端の距離でチェック
		return Battle_Std.CheckBackCornerDistance( _xkyori );
	}
}

// 画面端までが近いかどうかチェック
Battle_Std.CheckFromtCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetFrontCornerDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 画面端までが近いかどうかチェック
Battle_Std.CheckBackCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetBackCornerDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 前方の画面端までの距離を返す
Battle_Std.GetFrontCornerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx;
}

// 後方の画面端までの距離を返す
Battle_Std.GetBackCornerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return ( BMvTbl.GetMuki() == -1 )? -c_pos.ex : -c_pos.sx;
}

// 見た目の天井までの距離を返す
Battle_Std.GetCeilCprnerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return -c_pos.sy;
}

// 見た目通りの画面端までが近いかどうかチェック２（勝利とかでカメラが動いている影響を受ける）
Battle_Std.CheckFromtDispCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera|_GetPos_Offset|_GetPos_NoMuki } );
	local kabe_kyori = ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx;
	if( kabe_kyori < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 見た目通りの画面端までが近いかどうかチェック２（勝利とかでカメラが動いている影響を受ける）
Battle_Std.CheckBackDispCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera|_GetPos_Offset|_GetPos_NoMuki } );
	local kabe_kyori = ( BMvTbl.GetMuki() == -1 )? -c_pos.ex : -c_pos.sx;
	if( kabe_kyori < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 判定が触れている敵を引き寄せる
// やられ中は効果なし？
Battle_Std.PullEnemy_HanteiCross <- function( _frame=100, _src = [ _Hantei_Etc, 0, 1 ], _dst=[ _Hantei_Kurai, 0, -1 ] )
{
	local enemy = BMvEff.CheckHantei( { src=_src, dst=_dst, flags=_HC_EnemyPc } );
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x; // 向きを計算しない
		local move_pow = -kyori/_frame;
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			
			if( bs.isDone == 0 )
			{
				BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add } );
				// _Position_ChangeMuki はつけない
			}
			enemy.pop();
		}
	}
}

Battle_Std.PushEnemy_HanteiCross <- function( _frame=100, _src = [ _Hantei_Etc, 0, 1 ], _dst=[ _Hantei_Kurai, 0, -1 ] )
{
	local hantei = BMvEff.GetHanteiRect( { check=_src, flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Offset } );
	local enemy = BMvEff.CheckHantei( { src=_src, dst=_dst, flags=_HC_EnemyPc } );
	if( enemy.isdone() && hantei.sx != _Hantei_Error )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x;//*BMvTbl.GetMuki();
		// 相手が前にいると＋、後ろにいるとマイナス
		// local kyori = posst.distance_x;
		
		local hantei_right = -hantei.sx; // 判定の右端までの距離
		local hantei_left = hantei.ex; // 判定の左端までの距離
		local muki = BMvTbl.GetMuki();
		if (muki==-1) // 左向き時は左右逆転
		{
			hantei_right = hantei.ex;
			hantei_left = -hantei.sx;
		}
		
		local move_pow = 0;//(hantei.ex - kyori)/_frame;
		if( kyori > 0 ) // 敵が左にいる
		{
			move_pow = (hantei_left - kyori)/_frame;
			if( move_pow<0 ) move_pow=0; // 判定の外側にいる場合、引き寄せにならないように
		}
		else // 敵が右にいる
		{
			move_pow = -(hantei_right + kyori)/_frame;
			if( move_pow>0 ) move_pow=0; // 判定の外側にいる場合、引き寄せにならないように
		}
		
		// _dp("\n kyori:"+kyori/128+" move_pow:"+move_pow+" hantei.ex:"+hantei.ex+" x:"+posst.pos_x/128 );
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			
			if( bs.isDone == 0 )
			{
				BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add } );
				// _Position_ChangeMuki はつけない
			}
			enemy.pop();
		}
	}
}

// 特殊判定０とやられ判定のチェック
Battle_Std.PullEnemy_Etc0xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 0, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// 特殊判定１とやられ判定のチェック
Battle_Std.PullEnemy_Etc1xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 1, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

Battle_Std.PushEnemy_Etc1xKurai <- function( _frame )
{
	Battle_Std.PushEnemy_HanteiCross( _frame, [ _Hantei_Etc, 1, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// 特殊判定４とやられ判定のチェック
Battle_Std.PullEnemy_Etc4xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 4, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// ターゲットにマーキングするオブジェクトの座標セット
Battle_Std.SetPos_MarkingTarget <- function( _core, _par=5, _dfoy=-150, _miny=0 )
{
	_miny = _miny<<7;
	if( _core.push() )
	{
		local pl_pos = BMvTbl.GetPosition(0);
		local pl_kasanari = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		
		_core.pop();
		local set_posy = pl_pos.y+(_dfoy<<7); // 基本値
		if( pl_kasanari.sx != _Hantei_Error )
		{
			set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * _par / 10 );
		}
		if( _miny && set_posy > _miny ) set_posy = _miny; // 低くなりすぎないように最低値をつける
		BMvTbl.SetPosition( { x=pl_pos.x, y=set_posy } );
	}
}

Battle_Std.GetPos_MarkingTarget <- function( _core, _par=5, _dfoy=-150, _miny=0 )
{
	_miny = _miny<<7;
	if( _core.push() )
	{
		local pl_pos = BMvTbl.GetPosition(0);
		local pl_kasanari = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		
		_core.pop();
		local set_posy = pl_pos.y+(_dfoy<<7); // 基本値
		if( pl_kasanari.sx != _Hantei_Error )
		{
			set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * _par / 10 );
		}
		if( _miny && set_posy > _miny ) set_posy = _miny; // 低くなりすぎないように最低値をつける
		
		local ret_pos = BMvTbl.CCharaPosition();
		ret_pos.x = pl_pos.x;
		ret_pos.y = set_posy;
		return ret_pos;
	}
	return 0;
}

Battle_Std.SetPos_MarkingPlayer <- function( _par=5, _dfoy=-150 )
{
	local player = BMvCore.GetPlayerCharaData();
	Battle_Std.SetPos_MarkingTarget( player, _par, _dfoy );
}

Battle_Std.SetPos_MarkingEnemy <- function( _par=5, _dfoy=-150 )
{
	local enemy = BMvCore.GetEnemyCharaData();
	Battle_Std.SetPos_MarkingTarget( enemy, _par, _dfoy );
}

// 特定のＭｖ中、演出長時間背景の色を変える系処理
// 変えている最中はフラグがたっている
// 自分以外の誰かにフラグがたっていたらフェードは消さない
// とりあえず黒のみ
// 暗転中時間が進むので長めに入れないとダメよ
Battle_Std.BackScreenBlack_Start <- function( _time=600 )
{
}

Battle_Std.BackScreenBlack_Check <- function()
{
}




Battle_Std.CheckDownOiuti <- function()
{
	return 0;
}


Battle_Std.EnemyDamageFlag_Add <- function( _flag )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvTbl.DamageFlag_Func( _flag, _ValAdd );
		
		enemy.pop();
	}
}

Battle_Std.EnemyDamageFlag_Del <- function( _flag )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvTbl.DamageFlag_Func( _flag, _ValErase );
		
		enemy.pop();
	}
}

Battle_Std.EnemyDamageFlag_Check <- function( _flag )
{
	local ret = 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret = BMvTbl.DamageFlag_Func( _flag, _ValCheck ); // 0 or 1
		
		enemy.pop();
	}
	return ret;
}

// 今のMvとMvNameの配列が一致しているかチェック
// BCMDTbl.CheckMoveNameとの互換性をつけるため、文字列の時もチェックするように変更
Battle_Std.IsMatchMvNameArray <- function( _ar )
{
	return Battle_Std.IsMatchNameArray( BMvTbl.GetMvName(), _ar );
}

Battle_Std.IsMatchChangeMvNameArray <- function( _ar )
{
	return Battle_Std.IsMatchNameArray( BMvTbl.ChangeMv_GetMvName(), _ar );
}

Battle_Std.IsMatchNameArray <- function( _name, _ar )
{
	switch( typeof _ar )
	{
	case "array":
		foreach( x in _ar )
		{
			if( _name == x )
			{
				return 1;
			}
		}
		break;
	case "string":
		if( _name == _ar ) return 1;
		break;
	}
	return 0;
}

// 必殺技系ですぐ呼ばれるものに
Battle_Std.CallSkillSoonCache <- function( _frameid, _rest )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	local checkframe = BMvEff.GetFrameIDNum( _frameid );
	if( checkframe != -1 ) // FrameIDがあるかどうか
	{
		BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
	}
}

//同一PATのFrameIDを予約する
Battle_Std.CallSkillSoonCaches <- function( ... )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	
	for(local i = 0; i < vargc; i++)
	{
		local checkframe = BMvEff.GetFrameIDNum( vargv[i][0] );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=vargv[i][1] } );
		}
	}
}

// FrameID指定ではなく、単純に今のパターンの予約をする
// ダハーカとかで使ってる
Battle_Std.CallSoonCaches_noFrameID <- function( ... )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	
	for(local i = 0; i < vargc; i++)
	{
		// _dp("\n["+_pat+"_"+vargv[i][0]+"]"+vargv[i][1]);
		BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=vargv[i][0], rest=vargv[i][1] } );
	}
}

Battle_Std.CallSkillSoonCaches_AnoterPat <- function( _patstr, ... )
{
	local mvs = BMvTbl.GetMvStatus();
	local target_pat = BMvEff.GetPatternNum( { datatype=0, pat=_patstr } );
	
	for(local i = 0; i < vargc; i++)
	{
		local checkframe = BMvEff.GetFrameIDNum( vargv[i][0] );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			// _dpn("["+target_pat+"_"+vargv[i][0]+"]"+vargv[i][1]);
			BMvCore.CallEntryBCCachePreTransfer( { pat=target_pat, frame=checkframe, rest=vargv[i][1] } );
		}
	}
}

// Param2が指定した値の時に指定したFrameIDをキャッシュに乗せる
Battle_Std.CallSkillLandCache_Param2 <- function( _param2, _frameid, _rest=4)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isFrameUpdate && mvs.isLanding == 0 && mvs.Param2 == _param2 )
	{
		local _pat = mvs.DataPattern;
		local checkframe = BMvEff.GetFrameIDNum( _frameid );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
		}
	}
}


// 追加技の派生予約
Battle_Std.CallAddSkillCache <- function( _patstr, _rest )
{
	local target_pat = BMvEff.GetPatternNum( { datatype=0, pat=_patstr } );
	// _dp("\n[BCCache]:"+target_pat+"_0 ... "+_rest+"F後");
	BMvCore.CallEntryBCCachePreTransfer( { pat=target_pat, frame=0, rest=_rest } ); // 追加派生予約
}

// ループアニメの抜け先をキャッシュに載せる(パターン番号+FrameID指定)
Battle_Std.CallLoopEndCache_FrameID <- function( _pat, _frameid, _frame=10, _rest=2 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.MvCount % _frame == 0 && mvs.isLanding == 0 && _pat == mvs.DataPattern )
	{
		local checkframe = BMvEff.GetFrameIDNum( _frameid );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			// _dp("\n["+_pat+"-"+checkframe+"]を予約");
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
		}
	}
}

// 同一パターンのループアニメの抜け先をキャッシュに載せる(FrameID指定)
Battle_Std.CallSamePatLoopEndCache_FrameID <- function( _frameid, _frame=10, _rest=2 )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	if( mvs.MvCount % _frame == 0 && mvs.isLanding == 0 )
	{
		local checkframe = BMvEff.GetFrameIDNum( _frameid );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			// _dp("\n["+_pat+"-"+checkframe+"]を予約");
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
		}
	}
}

// 数フレーム後に空中必殺技制限をかける関数
Battle_Std.AddAirSkillCount <- function( _slot = 0, _val = 1, _mvs = 0 )
{
	local mvs = ( _mvs == 0 )? BMvTbl.GetMvStatus() : _mvs;
	// 出て少したったら空中必殺技回数制限をかける
	if( mvs.MvCount == 4 && mvs.CallCount == 0 )
	{
		// 空中必殺技の制限をかけました
		BMvTbl.AddAirCount( _slot, _val );
		return 1;
	}
	return 0;
}


// VORPAL攻撃の強化関数
Battle_Std.SetVorpalPattern <- function( _pat = 0 )
{
	if( BMvEff.GRD_GetJudgeResult() > 0 )
	{
		if( _pat ) BMvTbl.SetPattern( _pat );
		// Battle_Std.SetVorpalAtkEffect(); // VPAtk発動エフェクト仮
		return 1;
	}
	return 0;
}

Battle_Std.SetVorpalAtkEffect <- function()
{
	// BMvEff.CreateObject( { datatype=1, start_pat=88 } ); // テスト
	// Battle_Std.SetCharaFlash_GRDJudgeFlash();
}


// 相手のGRDを減らす処理はコンボ中1回のみにする
// 10000 で1ブロック
// 2回目以降は補正がかかるとかでもいいかも？
// 減らす量と吸収する量を指定する
// useflag:0〜2 ※他のやつがかかっていると増加量に補正がかかる
// ※仕様:打撃で始動に使った場合、使った技にカウントされない
local use_grd_minus_flag = [def_DF_GRD_Minused_TypeA, def_DF_GRD_Minused_TypeB, def_DF_GRD_Minused_TypeC];

Battle_Std.EnemyGRD_Minus <- function( _val, _drainval=0, _useflag = 0 ) : (use_grd_minus_flag)
{
	local grd_type_cnt = 0; // 何種類の技で吸収したか
	_dp("\n GRD変動処理開始:"+_val+" 吸収:"+_drainval );
	_dp("\n ["+_useflag+"] チェックフラグ:"+use_grd_minus_flag[_useflag] );
	foreach( val in use_grd_minus_flag )
	{
		local is_minused = Battle_Std.EnemyDamageFlag_Check( val );
		_dp("\n val:"+val+" is_minused:"+is_minused );
		if( is_minused )
		{
			if( val == use_grd_minus_flag[_useflag] )
			{
				grd_type_cnt ++;
				_dp(" -> スキップ");
				return 0; // コンボ中は1回のみ
			}
			else
			{
				grd_type_cnt ++;
				_dp(" -> 他で吸ってる:"+grd_type_cnt);
			}
		}
	
	}
	
	_dp("\n 付与したフラグ:"+use_grd_minus_flag[_useflag] );
	Battle_Std.EnemyDamageFlag_Add( use_grd_minus_flag[_useflag] ); // 「GRDを減らされた」を相手に記憶
	
	local useval = _val; // 実際にGRD操作する値
	
	switch( grd_type_cnt )
	{
	case 3:
		useval = useval * 0;
		break;
	case 2:
		useval = useval * 80 / 100;
		break;
	case 1:
		useval = useval * 40 / 100;
		break;
	default:
		break;
	}
	
	_dp("\n useval:"+useval+" grd_type_cnt:"+grd_type_cnt );
	
	// 減らす
	Battle_Std.GRD_AddValue({ val=-_val, boundplus=1, target=1 }); 
	if( _drainval )
	{
		Battle_Std.GRD_AddValue({ val=_drainval, boundplus=1, target=0 }); 
	}
	_dp(" -> 完了");
}

// 吸収を一応別処理にしてみた
// Battle_Std.EnemyGRD_Drain( 5000 ); // 相手のGRDを吸収する
Battle_Std.EnemyGRD_Drain <- function( _val, _useflag = 0 )
{
	if( Def_Sys_EnemyGRDDrainPar != 100 )
	{
		_val = _val * Def_Sys_EnemyGRDDrainPar / 100;
	}
	Battle_Std.EnemyGRD_Minus( _val, _val, _useflag );
}

Battle_Std.LP_Rebagatya_Init <- function( _LP0=0, _LP1=1, _LP2=2 )
{
	BMvTbl.SetLP(_LP0,0); // 連打カウンタ
	BMvTbl.SetLP(_LP1,0); // 前回のボタン
	BMvTbl.SetLP(_LP2,0); // 前回のレバー
}

Battle_Std.LP_Rebagatya_Update <- function( _LP0=0, _LP1=1, _LP2=2 )
{
	// レバー回しながらボタンですごい増えるようにするので別チェック
	local button = BMvTbl.CheckCommandString( [ "A", "B", "C" ] );
	if( button && button != BMvTbl.GetLP(_LP1) )
	{
		// _dp("\n ボタン押した");
		BMvTbl.AddLP(_LP0,1); // 連打回数を加算
	}
	BMvTbl.SetLP(_LP1,button);
	
	// ZERO3っぽく斜めも受け付ける
	local stick = BMvTbl.CheckCommandString( [ "4", "6", "2", "8", "1", "3", "9", "7" ] );
	if( stick && stick != BMvTbl.GetLP(_LP2) )
	{
		// _dp("\n レバーまわした");
		BMvTbl.AddLP(_LP0,1); // 連打回数を加算
	}
	BMvTbl.SetLP(_LP2,stick);
	
	// print("\n 連打カウンタ:"+BMvTbl.GetLP(0) );
}

Battle_Std.DrawDebugRect <- function( param={} )
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_rect", x=("x" in param)? param.x : 0, y=("y" in param)? param.y : 0 } );
	if( eff.push() )
	{
		if( "setx" in param) BMvTbl.SetPosition( { x=param.setx } );
		if( "sety" in param) BMvTbl.SetPosition( { y=param.sety } );
		eff.pop();
	}
}

Battle_Std.DrawDebugRectPos <- function( pos )
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_rect" } );
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
		BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
		
		eff.pop();
	}
}

// サポートキャラの汎用ステータス（全体を初期化されることは無い）
Battle_Std.SupSt_AddFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupStatus, BMvTbl.GetPP(def_PP_SupStatus)|flag )
}

Battle_Std.SupSt_DelFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupStatus, BMvTbl.GetPP(def_PP_SupStatus)&~flag )
}

Battle_Std.SupSt_CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetPP(def_PP_SupStatus)&flag)!=0 )? 1 : 0 );
}

Battle_Std.SetPP_JumpStartHeight <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	BMvTbl.SetPP( def_PP_JumpStartHeight, pos.y ); // ジャンプをしたときの高さを入れる
	
	// _dp("\n ジャンプ時の高さ:"+pos.y );
}

// 見た目のサポートとサポートの親の向きを合わせて振り向かせる
Battle_Std.SupportSetMuki <- function( _flag = _Direction_Auto )
{
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		BMvTbl.SetMuki( _flag ); // 相手の方を振り向く
		
		player.pop();
	}
	BMvTbl.SetMuki( _flag ); // 相手の方を振り向く
}



Battle_Std.LP_Rebagatya_Check <- function( param={} )
{
	local lp0 = param.CheckLP;
	local cnt = BMvTbl.GetLP(lp0);
	
	for( local i=0; i<param.List.len(); i++ )
	{
		if( cnt >= param.List[i] )
		{
			BMvTbl.AddLP(lp0,-param.List[i]);
			local ret = param.List.len() - i;
			_dp("\n レバガチャLV:"+ret+"/"+param.List.len() );
			return ret;
		}
	}
	return 0;
}

Battle_Std.SetHosyoHosei <- function( _val=100 )
{
	local now_val = BMvTbl.GetHoseiMinValue();
	if( _val < now_val )
	{
		_dp("\n 保証補正:"+now_val+"% -> "+_val+"%");
		BMvTbl.SetHoseiMinValue( _val ); // 以降のコンボの保証ダメージを変更
	}
	else
	{
		_dp("\n 保証補正:"+now_val+"% のまま("+_val+"%)が大きい");
	}
}

// 最低保証補正を乗算
Battle_Std.SetHosyoHosei_Multi <- function( _par )
{
	local now_val = BMvTbl.GetHoseiMinValue();

	local calc_val = now_val * _par / 100;
	if( calc_val < 1 ) calc_val = 1; // 下限 0だとむしろ100扱いになってダメ
	if( calc_val > 130 ) calc_val = 130; // 上限

	_dp("\n 保証補正("+_par+"%):"+now_val+"% -> "+calc_val+"%");
	BMvTbl.SetHoseiMinValue( calc_val ); // 以降のコンボの保証ダメージを変更
}


local hosyoParams = {
	EX =
	{
		flag = def_DF_SpHosyoHoseiSeted_DoubleEx,
		hosei=def_HosyoHosei_NoDyingComboUsedExSkill_Init,
		suddundyinghosei=def_HosyoHosei_SuddenDyingComboUsedExSkill_Init
		dyinghosei=def_HosyoHosei_DyingComboUsedExSkill_Init
	},
	VO =
	{
		flag = def_DF_SpHosyoHoseiSeted_VOsukasi,
		hosei=def_HosyoHosei_NoDyingVO_Init,
		suddundyinghosei=def_HosyoHosei_SuddenDyingVO_Init
		dyinghosei=def_HosyoHosei_DyingVO_Init
	},
	CVO =
	{
		flag = def_DF_SpHosyoHoseiSeted_CVO,
		hosei=def_HosyoHosei_NoDyingComboVO_Init,
		suddundyinghosei=def_HosyoHosei_SuddenDyingComboVO_Init
		dyinghosei=def_HosyoHosei_DyingComboVO_Init
	},
	SP =
	{
		flag = def_DF_SpHosyoHoseiSeted_SP,
		hosei=def_HosyoHosei_NoDyingComboUsedSpSkill_Init,
		suddundyinghosei=def_HosyoHosei_SuddenDyingComboUsedSpSkill_Init
		dyinghosei=def_HosyoHosei_DyingComboUsedSpSkill_Init
	},
	Muteki =
	{
		flag = def_DF_MutekiHosyoHoseiSeted,
		hosei=def_HosyoHosei_Muteki_Init,
		suddundyinghosei=def_HosyoHosei_Muteki_Init,
		dyinghosei=def_HosyoHosei_Muteki_Init
	},
	Throw =
	{
		flag = def_DF_ThrowHosyoHoseiSeted,
		hosei=def_HosyoHosei_Throw_Init,
		suddundyinghosei=def_HosyoHosei_Throw_Init,
		dyinghosei=def_HosyoHosei_Throw_Init
	},
}
	
//EX2回、VOスカ、CVOでの保証補正処理
//基本的に今の値に対して乗算するが…
Battle_Std.SetSpHosyoHosei <- function( param = {} ) : ( hosyoParams )
{
	local hosyoParam = {
		flag = 0,
		hosei = 0,
	}
	
	local isDying = ( BMvTbl.GetMvStatus().flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
	local vpcombo = Battle_Std.EnemyDamageFlag_Check( def_DF_Vorpaled );
	local checkPPFlag = ("checkPPFlag" in param)? param.checkPPFlag : 0;
	
	local useparam = hosyoParams[ param.type ];
	hosyoParam.flag = useparam.flag;
	
	if( Def_Sys_DyingVeilOffHosei ) // UNI2 1.04
	{
		// 瀕死時は最低保障補整が緩く。初めからVPだったなら更に最低保障補整が緩くなる
		hosyoParam.hosei = ( isDying && vpcombo )? useparam.dyinghosei : ( isDying )? useparam.suddundyinghosei : useparam.hosei;
	}
	else
	{
		// 常に最低保障補整を緩めにする（瀕死時に緩くする仕様を廃止）
		hosyoParam.hosei = useparam.dyinghosei;
	}
	
	_dp("\n ■SetSpHosyoHosei:"+param.type+" 補正:"+hosyoParam.hosei+"%" );

	// const def_DF_SpHosyoHoseiSeted_DoubleEx = 512; // EXの同技
	// const def_DF_SpHosyoHoseiSeted_VOsukasi = 1024; // VOスカ
	// const def_DF_SpHosyoHoseiSeted_CVO = 2048; // CVO発動
	// const def_DF_SpHosyoHoseiSeted = 3584; // EXの同技やVOスカ、CVO発動で保証補正をかけたかどうか
	
	// const def_HosyoHosei_DyingComboVO_Init = 90; // コンボヴェールオフ、瀕死時　※CVOは瀕死の時の補正がゆるめ(キャラ差が少ないので)
	// const def_HosyoHosei_SuddenDyingComboVO_Init = 70; // 瀕死CVO（コンボ中にVPになった場合）
	// const def_HosyoHosei_NoDyingComboVO_Init = 70; // コンボヴェールオフ、瀕死じゃない時の保証補正

	// const def_HosyoHosei_DyingVO_Init = 85; // ヴェールオフ、瀕死時
	// const def_HosyoHosei_SuddenDyingVO_Init = 70; // ヴェールオフ、瀕死時
	// const def_HosyoHosei_NoDyingVO_Init = 70; // ヴェールオフ、瀕死じゃない時の保証補正

	// const def_HosyoHosei_DyingComboUsedExSkill_Init = 85; // コンボ中にEX技を２回出そうとしたとき
	// const def_HosyoHosei_SuddenDyingComboUsedExSkill_Init = 70; // コンボ中にEX技を２回出そうとしたとき
	// const def_HosyoHosei_NoDyingComboUsedExSkill_Init = 70; // コンボ中にEX技を２回出そうとしたとき
	
	if( Battle_Std.EnemyDamageFlag_Check( hosyoParam.flag ) )
	{
		_dp("\n 既に同じ補正をかけています");
		return 0;
	}
	
	//EnemyDamageFlagのチェックは完了した
	//けど同じFにヒットするとうまく行かないので最終チェック
	//Mutekiの補正をかけるのはDamageTimingとLastUpdateがあるので、DamageTimingのみにするためcheckPPFlagを見る
	if( param.type == "Muteki" && checkPPFlag ) 
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local flagFind = 0;
			if( Battle_Std.PP_CheckFlag(def_PP_ImpactAnnounce,def_PP_IA_MutekiHosei) )
			{
				flagFind = 1;
			}
			else
			{
				Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_MutekiHosei);
			}
			enemy.pop();
			
			if( flagFind )
			{
				_dpn("同F中に同じMuteki補正をかけ済み(PP)");
				return 0;
			}
		}
	}	
	
	// 実際に設定する補正を計算
	local minHosei = 100; // 今までかけてきた補正で一番キツい値を調べる
	foreach( slot, val in hosyoParams )
	{
		local usehosei = ( isDying && vpcombo )? val.dyinghosei : ( isDying )? val.suddundyinghosei : val.hosei;
		if( Battle_Std.EnemyDamageFlag_Check( val.flag ) )
		{
			_dp("\n "+slot+" : ◯ 補正:"+usehosei );
			if( minHosei > usehosei )
			{
				minHosei = usehosei;
			}
		}
		else
		{
			_dp("\n "+slot+" : × 補正:"+usehosei );
		}
	}
	_dp("\n 現在までのキツい補正:"+minHosei+" 今かけたい補正:"+hosyoParam.hosei );
	
	if( minHosei < 1 ) minHosei = 1; // 0div
	if( minHosei > hosyoParam.hosei )
	{
		// それよりも重いやつをかけたい場合は、その差分をかけるようにする
		// local setHosei = 100 - ( minHosei - hosyoParam.hosei );
		local setHosei = ( hosyoParam.hosei * 100 / minHosei );
		Battle_Std.SetHosyoHosei_Multi( setHosei );
	}

	// 補正をかけようとしたのを記憶
	Battle_Std.EnemyDamageFlag_Add( hosyoParam.flag );

	return 1; // 成功
}


Battle_Std.PP_CheckFlag <- function( _PPSlot, _flag )
{
	return( BMvTbl.GetPP(_PPSlot)&_flag ); // フラグチェック
}

Battle_Std.PP_AddFlag <- function( _PPSlot, _flag )
{
	BMvTbl.SetPP( _PPSlot, BMvTbl.GetPP(_PPSlot)|_flag ); // フラグ追加
}

Battle_Std.PP_DelFlag <- function( _PPSlot, _flag )
{
	BMvTbl.SetPP( _PPSlot, BMvTbl.GetPP(_PPSlot)&~_flag ); // フラグ消去
}

// 
Battle_Std.Val_CheckFlag <- function( _val, _flag )
{
	return( _val&_flag ); // フラグチェック
}

Battle_Std.Val_AddFlag <- function( _val, _flag )
{
	return (_val|_flag); // フラグ追加
}

Battle_Std.Val_DelFlag <- function( _val, _flag )
{
	return (_val&~_flag ); // フラグ消去
}

Battle_Std.LP_AddFlag <- function( _lp, _flag )
{
	BMvTbl.SetLP( _lp, BMvTbl.GetLP(_lp)|_flag )
}

Battle_Std.LP_DelFlag <- function( _lp, _flag )
{
	BMvTbl.SetLP( _lp, BMvTbl.GetLP(_lp)&~_flag )
}

Battle_Std.LP_CheckFlag <- function( _lp, _flag )
{
	return( BMvTbl.GetLP(_lp)&_flag );
}

Battle_Std.SP_AddFlag <- function( _sp, _flag )
{
	//BMvTbl.SetSP( _sp, BMvTbl.GetSP(_sp)|_flag )
}

Battle_Std.SP_DelFlag <- function( _sp, _flag )
{
	//BMvTbl.SetSP( _sp, BMvTbl.GetSP(_sp)&~_flag )
}

Battle_Std.SP_CheckFlag <- function( _sp, _flag )
{
	//return( BMvTbl.GetSP(_sp)&_flag );
}

Battle_Std.CreateIgnitionPAni <- function( _pat, _team, _prio, _delay, _type=-1 )
{
}

Battle_Std.CheckIgnition <- function( _type )
{
}

Battle_Std.CheckDoubleIgnition <- function( _type )
{
}

Battle_Std.CheckSubSupportType <- function( _type )
{
}

Battle_Std.SetObjectSousaiLv <- function()
{
}

Battle_Std.SupportAtk_Init <- function()
{
}

Battle_Std.SupportAtk_DamageFinalize <- function()
{
}

Battle_Std.SupportAtk_EscapeFinalize <- function()
{
}

// 追撃タイミングかどうかチェック
// 相原延寿、ハルユキで使用中
// つかみ中や投げ抜け関係には反応しない優秀な追撃チェック
Battle_Std.CheckTuigeki <- function()
{
	/*
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local mvname = BMvTbl.GetMvName();

		enemy.pop();
		
		if( bs.isBound == 1 && bs.isCapture == 0 && mvname!="Mv_Bound_0023" && mvname!="Mv_Bound_0024" )
		{
			return 1;
		}
	}
	return 0;
	*/
}


//格ゲー的に「打撃無敵」といっていい状態かどうか
//オブジェクトに対してチェックすると無敵になってしまうので注意
Battle_Std.CheckDagekiMuteki <- function()
{
	local isMuteki = BMvEff.GetPlayerMuteki( 0 ); // 打撃無敵
	if( isMuteki )
	{
		//暗転中の無敵や相殺中の無敵は除外する
		if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_Anten ) || Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_SousaiMuteki ) )
		{
			// 除外
		}
		else
		{
			return 1;
		}
	}
	
	if( BMvEff.IsKuraiRect() ) return 0;//判定があるので無敵ではない
	return 1;//無敵
}

// 自分が空中状態の時のみチェック
// ジャンプ攻撃の攻撃判定が出たらそこで消滅（チェックはここまでにやっている）

// 条件：「相手が立ちガードで、さらに
// （　…ヒットストップの影響を受けている間（ベクトルのフレームが0だと真）」は不要っぽいので消す　）
// 自分がジャンプ攻撃を出すと、しゃがみガード可能なフラグが立つ
// 条件が満たされない場合、ジャンプ攻撃につけたしゃがみガード可能なフラグは消される（上段が中段になるわけでなく、判定データを参照するようになる）

Battle_Std.CheckAirAtkFsiki <- function()
{
	if( !Battle_Std.MoveCode.CheckFlag( def_MC_EnableAirAtkStatus ) ) return;
	
	// ヒットしたらもういいでしょ
	if( Battle_Std.MoveCode.CheckFlag( def_MC_HitStatus_Damage|def_MC_HitStatus_Guard ) ) return;
	
	if( !Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ) )
	{
		// _dp("\n 前のMvのチェックでアウト");
		return;
	}
	
	// _dp("\n チェック中。。。");
	
	local isStandHitStopFrame = 0; // 立ち状態でヒットストップ中
	local isHitOnlyStand = 0; // 立ちのみにあたる（しゃがんでたら当たらないはずの攻撃）
	local isStandGuardFrame = 0;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local isStand = BCMDTbl.CheckPosState( _PosState_Stand );
		local croRc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 15 ], flags=0 } );

		enemy.pop();
		
		if( bs.isBound == 2 ) // ガード状態
		{
			// 立ちのガード状態＆しゃがみ用の特殊判定が指定してある
			if( isStand && croRc.sx != _Hantei_Error  )
			{
				isStandGuardFrame = 1;
			}
			// if( bs.BoundTime == 0 && isStand )
			// {
				// isStandHitStopFrame = 1;
			// }
		}
	}
	
	local isAirSt = BCMDTbl.CheckPosState( _PosState_Air );
	local isAirAtk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump ); // 自分がジャンプ攻撃を出していると1
	
	// しゃがみの判定の矩形に触れているかチェック
	// これに触れていなかったら、立ちにしか当たらない攻撃になるので、Ｆ式での崩しになる
	// _dp("\n BMvEff.IsAttackRect():"+BMvEff.IsAttackRect() );
	if( BMvEff.IsAttackRect()==2 ) // 攻撃が出現し、残りHIT数が０でない状態
	{
		local hitCrouch = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Etc , 15, 1 ], flags=_HC_EnemyPc } );
		if( !hitCrouch.isdone() ) // 触れていない
		{
			// _dp("\n isHitOnlyStand:"+isHitOnlyStand );
			isHitOnlyStand = 1;
		}
	}			
	if( isAirSt && isAirAtk )
	{
		if( isStandGuardFrame && isHitOnlyStand )
		{
			_dp("\n しゃがんでいると当たらなそうなので上段に変更");
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
			Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHosei );
		}
		else
		{
			if( !Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_RockerteerHosei ) && 
			Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHosei ) &&
			!Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHoseiClear )
			) // 上段化した 
			{
				_dp("\n 上段にしてたのを戻す:"+isStandGuardFrame+" ,"+isHitOnlyStand );
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=0, flag=0 } );
				Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHoseiClear );
			}
		}
	}
}

Battle_Std.CallFreezObject <- function()
{
}

local debugwrite = { val=[{},{}] };

Battle_Std.DebWrite_ValTiming <- function( _param ) : (debugwrite)
{
	if( !Def_Dbg_LocalDebugMode ) return;
	
	local pside = BMvTbl.GetPlayerSide();
	
	if( _param == 0 )
	{
		debugwrite.val[0] = {}; // 初期化
		debugwrite.val[1] = {}; // 初期化
		return;
	}
	
	foreach( name, v in _param )
	{
		if( !( name in debugwrite.val[pside] ) )
		{
			// _dp("\n "+name+" がないので追加");
			debugwrite.val[pside][name] <- null;
		}
		
		if( debugwrite.val[pside][name] != v )
		{
			_dp("\n ["+name+"] "+debugwrite.val[pside][name] +" -> "+ v );
		}
		debugwrite.val[pside][name] = v;
	}
}

// ジャンプの高さを始まり〜終わりで0〜100にして表す関数
// 0だと最初、50だと頂点、100だと着地、みたいな感じ
// _Vector_Normalのみで動く単純なジャンプにしか使えない
Battle_Std.GetJumpVectorPar <- function( _start_y_vec )
{
	local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
	local par = 50 - (vec.y-vec.addy)*50/_start_y_vec;
	if( par <   0 )
	{
		par =   0; // 落ちすぎる、は検知しない
	}
	else if( par > 100 )
	{
		par = 100; // 飛びすぎる、は検知しない
	}
	// _dp("\n _start_y_vec:"+_start_y_vec+" vec.y:"+vec.y+" par:"+par );
	return par;
}

Battle_Std.AddMoveCode_CSAntenGaesiSkill <- function()
{
	// チェインシフト状態かどうか
	// 直前の行動がチェインシフトである
	// CSして追撃しようとするとダメ
	// _dp("\n BMvEff.GRD_GetConvertCount():"+BMvEff.GRD_GetConvertCount() );
	// _dp("\n Battle_Std.CheckEnemyisBound():"+Battle_Std.CheckEnemyisBound() );
	if( BMvEff.GRD_GetBreak( 0 ) == 100 && BMvEff.GRD_GetConvertCount() == 0 && !Battle_Std.CheckEnemyisBound() )
	{
		// 相手がやられ中以外で、CSゲージがあるとフラグが立ちます
		_dp("\n CSゲージがある最中の発動です");
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CSAntenGaesiSkill );
	}
}

// CSからの暗転返しで出したら追撃不能にする
Battle_Std.CSAntenGaesi_NoAttackHit <- function()
{
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CSAntenGaesiSkill ) )
	{
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();

			// short BtlMvStd::MvBoundStatus::isBound
			// 0 --- のけぞり状態でない
			// 1 --- のけぞり状態
			// 2 --- のけぞり状態でガードしている

			//のけぞりorつかまれ
			if( bs.isBound == 1 || bs.isCapture != 0 )
			{
				BMvTbl.SetWallCount( 100 ); //追撃不能状態にする
				_dp("\n CS暗転返し技なので追撃不能にします");
			}
			
			enemy.pop();
		}
	}
}

//CSしなかった場合ダメージ補正をかける
//また、暗転返しで出した場合
Battle_Std.CSAntenGaesi_DamageHosei <- function( _zyozanHosei=70, _uwagakiHosei=70 )
{
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CSAntenGaesiSkill ) )
	{
		// _dp("\n ★CSの暗転返しから出したので補正をかけます");
		// BMvEff.ComboView_Set( { val=_uwagakiHosei, type=0 } ); // 上書き補正
		// BMvEff.ComboView_Set( { val=_zyozanHosei, type=1 } ); // 乗算補正
		
		Battle_Std.EnemyDamageFlag_Add( def_DF_CSAntenGaesied ); // 相手にCS暗転返しされたフラグをたてる
	}
	
	// 監視オブジェクト生成
	// CS無しで追撃した場合にダメージを低下させる
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill ) )
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_CSHoseiChecker" } );
		if( eff.push() )
		{	
			// かける予定の補正値を入れる
			// 上書き補正だけでいいのでは説はある？
			
			BMvTbl.SetLP(0,_uwagakiHosei);
			BMvTbl.SetLP(1,_zyozanHosei);
			
			eff.pop();
		}
	}
}

Battle_Std.PassBeforeMoveCodeEx <- function( _pos, _flag )
{
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( _pos, _flag ) )
	{
		Battle_Std.MoveCodeEx.AddFlag( _pos, _flag );
		return 1;
	}
	return 0;
}

// １つ前の行動のMvActionを引き継ぐ
Battle_Std.CopyBeforeMoveAction <- function()
{
	BMvTbl.SetMvAction( BMvTbl.ChangeMv_GetMvAction() );
}

Battle_Std.SetKezurareDamage <- function( _dmg_val )
{
	if( BMvEff.GuardSP_Get() == 0 ) // シールドじゃなかったら
	{
		// 確定で凄く削る
		BMvEff.SetHpGauge( { value=-_dmg_val } ); // 削り
	}
}
Battle_Std.CheckMainisDamage <- function()
{
}

Battle_Std.CheckMainisBound <- function()
{
}

// ヒット分岐で引き継ぐものまとめ
// 必殺技のヒット分岐だと自動で実行されるが、通常技のやつは手動で追加が必要(def_AtkTmplFlags_Enable時は自動)
Battle_Std.PassHitMoveCodes <- function()
{
	// _dpn("PassHitMoveCodes()");
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_CounterHit ); // カウンターヒット引継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_SidouHitSkill ); // 始動技であることの引継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_ThrowCounter ); // 投げで硬直を掴んだことの引継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_Muteki ); // 無敵技扱いであることの引き継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_MutekiAnnounce ); // 無敵技アナウンスを出し終えたことの引き継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 4, def_MC4_AddMv ); // 追加技

	Battle_Std.PassBeforeMoveCodeEx( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_ExtendAction ); // タメ版フラグを引き継ぐ
	Battle_Std.PassBeforeMoveCodeEx( 0, def_MC_Shielded ); // シールドをとられた

	Battle_Std.PassBeforeMoveCodeEx( 5, def_MC5_FromSidouAddSkill ); // 始動技の追加攻撃
	
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_GRDBreakAttack ); // GRDブレイクを発生させた攻撃
	Battle_Std.PassBeforeMoveCodeEx( 4, def_MC4_DelayMutekiSidouHosei ); // 無敵技始動の補正をLastUpdateでかける
	
}

// 着地時に引き継ぐコードまとめ（ジャンプ攻撃、空中特殊技と一部空中必殺技）
Battle_Std.PassLandMoveCodes <- function()
{
	Battle_Std.PassBeforeMoveCodeEx( 0, def_MC_Atk );
	// Battle_Std.PassBeforeMoveCodeEx( 0, def_MC_BCAction ); // ※FFの着地でMVを変えるときは呼び出すこと
	Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_AtkJump );

	Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_SidouHitSkill ); // 始動技であることの引継ぎ

	Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_Muteki ); // 無敵技扱いであることの引き継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_MutekiAnnounce ); // 無敵技アナウンスを出し終えたことの引き継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 4, def_MC4_AddMv ); // 追加技

	Battle_Std.PassBeforeMoveCodeEx( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_ExtendAction ); // タメ版フラグを引き継ぐ
	Battle_Std.PassBeforeMoveCodeEx( 0, def_MC_Shielded ); // シールドをとられた
	
	Battle_Std.PassBeforeMoveCodeEx( 5, def_MC5_FromSidouAddSkill ); // 始動技の追加攻撃
}


// アサルト中ならフラグが立ってないとダメにする
Battle_Std.CheckEnableFlag_AssaultAirA <- function()
{
	if( Battle_Std.IsMatchMvNameArray( ["Mv_Assault_Std","Mv_Assault_Air"] ) )
	{
		if( !Battle_Std.LP_CheckFlag( 2, 1 ) ) return 0;
	}
	return 1;
}

Battle_Std.CheckEnableFlag_AssaultAirB <- function()
{
	if( Battle_Std.IsMatchMvNameArray( ["Mv_Assault_Std","Mv_Assault_Air"] ) )
	{
		if( !Battle_Std.LP_CheckFlag( 2, 2 ) ) return 0;
	}
	return 1;
}

Battle_Std.CheckEnableFlag_AssaultAirC <- function()
{
	if( Battle_Std.IsMatchMvNameArray( ["Mv_Assault_Std","Mv_Assault_Air"] ) )
	{
		if( !Battle_Std.LP_CheckFlag( 2, 4 ) ) return 0;
	}
	return 1;
}

//_mvs : MvStatusを直接指定する用
Battle_Std.CheckParamFlags <- function( paramNum, checkFlag, _mvs=0 )
{
	local mvs = ( _mvs )? _mvs : BMvTbl.GetMvStatus();
	local useParam = 0;
	switch( paramNum )
	{
	case 0:
		useParam = mvs.Param0;
		break;
	case 1:
		useParam = mvs.Param1;
		break;
	case 2:
		useParam = mvs.Param2;
		break;
	case 3:
		useParam = mvs.Param3;
		break;
	default:
		return 0;
		break;
	}
	if( useParam&checkFlag ) return 1;
	return 0;
}

//壁チェックを無くした超技のあとに使う（超技以外で使うと、ヴォーパルの湯気とか色々ダメだと思う）
//キャラが行ける限界内にカメラ座標を動かして、両者の座標も相対的に動かす
//キャラを動かすのでエフェクトとか飛び道具が出ているとダメなので注意
Battle_Std.SetBothCharaInStagePosition <- function()
{
	//向きで判断するんじゃなくて、左右どちらの端が近いかで判断する
	local pos = BMvTbl.GetPosition(0);
	local muki = ( pos.x > 0 )? 1 : -1;
	
	local crect = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local stage_corner = ( muki == 1 )? def_POS_GamenHajiX : -def_POS_GamenHajiX;//A

	//def_POS_GamenHajiXはキャラが行ける限界値なので、カメラはもうちょい外にある（def_POS_GamenGaiYuuyoX）
	local camera_corner = ( muki == 1 )? crect.ex - def_POS_GamenGaiYuuyoX : crect.sx + def_POS_GamenGaiYuuyoX;//B
	local camera_zure = stage_corner - camera_corner;//これだけキャラが行ける限界座標をカメラが超えている
	
	if( camera_zure*muki < 0 )
	{
		local cpos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_NoMuki } );
		
		BMvEff.SetCamera_Focus( { x=cpos.x+camera_zure, y=cpos.y, time=[0,0,0] } );
		
		BMvTbl.SetPosition( { x=camera_zure, flags=_Position_Add } );
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetPosition( { x=camera_zure, flags=_Position_Add } );
			enemy.pop();
		}
		//次のフレームにカメラ位置をリセットする
		BMvEff.CreateObject( { datatype=1, mvname="Mv_Null_NextFrameResetViewCamera" } );
	}
}

// ゲーム座標を渡すと自分からの相対座標にして返す
Battle_Std.GetCreatePosition <- function( pos )
{
	local mypos = BMvTbl.GetPosition();
	mypos.x = (pos.x-mypos.x)*BMvTbl.GetMuki();
	mypos.y = pos.y-mypos.y;
	return mypos;
}

//ヒットベクトルから角度を取得（ランダム加算あり）
//ベース指定があるときはベース半分残して処理する
Battle_Std.GetHitEffectAngle <- function( info, base_angle=0 )
{
	local angle = BMvEff.GetBoundVectorAngle( info.vectortype );//info.vectortypeはベクトル番号
	if( BMvTbl.GetMuki() == -1 ) angle = 1.0 - angle;//向きによる補正
	local rand_angle = BMvEff.Random_FAbs( 6 )/100;//ランダム補正
	// _dpn("★angle:"+angle+" rand_angle:"+rand_angle+" base_angle:"+base_angle );

	if( base_angle != 0 ) // 指定があったらベースに寄せる
	{
		angle = (angle+base_angle)/2;
	}
	
	return (angle+rand_angle)*2;
}

//判定の左上座標を取得
Battle_Std.GetPoint <- function( param={} )
{
	local pot = { x=_Hantei_Error, y=_Hantei_Error };
	local use_flags = ( "flags" in param )? param.flags : 0;
	local rc = BMvEff.GetHanteiRect( { check=param.rect, flags=use_flags } );
	local muki = BMvTbl.GetMuki();
	
	if( rc.sx != _Hantei_Error )
	{
		if( use_flags&_HanteiFlag_NoMukiChange )
		{
			pot.x = rc.sx; // 多分こう
		}
		else
		{
			pot.x = ( muki == 1 )? rc.sx : rc.ex;
		}
		pot.y = rc.sy;
	}
	return pot;
}

Battle_Std.SetInActiveEffect <- function()
{
	if( !Battle_Std.GS_CheckFlag( def_PP_GS_KeepInActive ) )
	{
		Battle_Std.DrawInActiveEffect(); // 相手にもやもやを出す
		
		// GRD減少のデメリット
		// でばなをくじかれた…カウンター的なニュアンス
		// ダメージアップだと運ゲーの加速がすごいので、ダメージ以外＝GRD
		Battle_Std.GRD_AddValue({ val=def_GRD_InActive, pressure=0, boundplus=1 });
		
		//InActive検知のあと相手が行動可能になるまで継続するオブジェクトを生成
		//def_PP_GS_KeepInActive フラグ管理
		//これが生きている間に殴ると相手のゲージ増加量が減る
		BMvEff.CreateObject( { mvname="Mv_Null_KeepInActive" } );
	}
}

Battle_Std.DrawInActiveEffect <- function()
{
	// 行動不能でガードでもやられでも無敵でもない
	BMvEff.SetCharaFlash( { color = 0xFFA0A0, type = 0, time = 15 } ); //動けないので赤く光る
	BMvEff.SetCharaColor( { color = 0xFFA0A0, type = 0, time = 40 } ); //動けないので赤く光る
	
	local sety = -150; // 重なりがないときのデフォ位置
	local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		sety = (rc.ey - rc.sy)/4 + rc.sy; // 重なりの真ん中よりちょい上
		// _dp("\n sety:"+sety);
	}
	Battle_Std.CreateObjectEX( { x=0, y=sety, datatype=1, pat="sternness", flags=_Position_ToolShift,
	objectflags=_ObjFlags_MoveTimeStopAll } );
}

//何が何でも相手の方を向く、振り向く
Battle_Std.SetMukiAuto <- function( param={} )
{
	local ppos = BMvTbl.GetPosition();

	local epos = Battle_Std.GetEnemyPosition();

	if( "CheckEnemyVector" in param && param.CheckEnemyVector )
	{
		local evec = Battle_Std.GetEnemyVector( { flags=_Vector_Bound|_VecFlag_NoMuki } );
		
		// 相手がやられ中のときはやられベクトルも計算に含める
		// 色々調べてみたが、PAT重なりの有無は関係なく、ベクトルの有無でのズレがあるのみだった
		if( Battle_Std.CheckEnemyisBound() )
		{
			_dpn("相手のやられベクトルも考慮して厳密に振り向く");
			epos.x += evec.x;
		}
	}

	
	if( ppos.x >  def_POS_GamenHajiX ) ppos.x =  def_POS_GamenHajiX;
	if( ppos.x < -def_POS_GamenHajiX ) ppos.x = -def_POS_GamenHajiX;
	if( epos.x >  def_POS_GamenHajiX ) epos.x =  def_POS_GamenHajiX;
	if( epos.x < -def_POS_GamenHajiX ) epos.x = -def_POS_GamenHajiX;
	
	if( ppos.x < epos.x )
	{
		BMvTbl.SetMuki( _Direction_Right );
		return;
	}
	else if( ppos.x > epos.x )
	{
		BMvTbl.SetMuki( _Direction_Left );
		return;		
	}
	else
	{
		BMvTbl.SetMuki( _Direction_Auto );		
	}
	return;
	//BMvEff.GetPointStatusを使うと壁めり込み押し戻し処理前なのでうまくいかねぇっす
}

// PATの1F目にベクトルがあって向きをAutoしたいとき用の関数
// addxには未対応
Battle_Std.SetMukiAuto_RevAutoVec <- function()
{
	local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
	if( BMvTbl.CheckFurimuki() )
	{
		BMvTbl.SetVector( { x=-vec.x, flags=_Vector_Normal } );
	}
	BMvTbl.SetMuki(_Direction_Auto);
}

Battle_Std.ExtendTiming <- function()
{
}

// システム的に絶対に行動可能やキャンセル可能にならない行動
// 保険処理
Battle_Std.SetNoMovableMove <- function()
{
	BMvTbl.SetMoveableFlag( { move=0, time=255, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
	BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=255, flag=_ClearFlag_ChangeMv } );
	
	//FlagのEXキャンセルは可能になってしまうので注意
}

//トロフィー開放のデバッグ用かませ
Battle_Std.Achievement_Unlock <- function( slot, training_ok=0 )
{
	//トレーニングやチュートリアルのデフォは取得不能に
	if( training_ok == 0 )
	{
		local is_training = BMvTbl.GetMvStageStatus().IsTrainingBattle();
		if( is_training ) return;
	}
	
	if( Def_Dbg_LocalDebugMode )
	{
		if( Def_Dbg_AchiveMessage )
		{
			local debug_str = "トロフィー　スロット:"+slot;
			debugfontL.draw_message( debug_str );
			_dpn(debug_str);
		}
	}
	BMvTbl.Achievement_Unlock( slot );
}

//slotのアチーブメントを開放
//slotは配列でもOK
//掛け合いの場合もあるためcpuでも処理をする
//ボイスのときは事前にcpuは除外している
//リプレイ、観戦もOK、トレモもOK
//条件付き勝利も、CPUがやってきた場合もOK（ほぼなんでもOKというイメージ）
Battle_Std.CharaAchievement_Increment <- function( slot, name="" )
{
	local chara_no = BMvCore.GetCharaNo(); // タッグならタッグ用のキャラ番号を取得する
	
	local use_slot = ( typeof slot=="array" )? slot : [slot];
	
	for( local i=0; i<use_slot.len(); i++ )
	{
		if( Def_Dbg_LocalDebugMode )
		{
			if( Def_Dbg_AchiveMessage )
			{
				local debug_str = "アチーブメント　キャラ:"+chara_no+" スロット:"+use_slot[i]+" "+name;
				debugfontL.draw_message( debug_str );
				_dpn(debug_str);
			}
		}
		BMvTbl.Achievement_Increment( chara_no, use_slot[i] );
	}
}


//バトルアクティビティのスロット
//  50  カウンターヒット
//  51  被カウンターヒット
//  55  下段ガード
//  56  下段ガードミス
//  60  中段ガード
//  61  中段ガードミス
//  65  空中ガード
//  66  空中ガードミス
//  70〜87　※シールド関係
//  90　ヴェールオフ回数
//  95　チェインシフト回数
// 100　ヴォーパル回数
// 101　両者ヴォーパル回数
// 110  地上投げ使用
// 111  地上投げ成功
// 115  地上投げ失敗
// 121  投げでつかまれた回数
// 122  地上投げ抜け成功
	

//戦績記憶の動作イメージ用
//type:0 操作キャラ時のみ 1:相手キャラ時のみ
Battle_Std.CharaBattleActivity_Increment <- function( slot, str )
{
	local chara_no = BMvCore.GetCharaNo(); // タッグならタッグ用のキャラ番号を取得する
	
	local count = 0;
	if( Def_Dbg_LocalDebugScriptPath )
	{
		if( !( chara_no in BattleActivetySlot ) )
		{
			BattleActivetySlot[chara_no] <- {};
		}
		if( !( str in BattleActivetySlot[chara_no] ) )
		{
			BattleActivetySlot[chara_no][str] <- 0;
		}
		BattleActivetySlot[chara_no][str] ++;
		count = BattleActivetySlot[chara_no][str];
	}
	if( Def_Dbg_AchiveMessage )
	{
		local debug_str = "アクティビティ　キャラ:"+chara_no+" "+str+"("+count+")";
		debugfontL.draw_message( debug_str );
		_dpn(debug_str);
	}
	
	local netInfo = BMvTbl.GetMvNetworkInfo();
	if( netInfo.NetworkVsMode == _NetworkVsMode_VsRankMatch )
	{
		if( netInfo.NetworkVsControlType == _NetworkVsControlType_Controller )
		{
			BMvTbl.BattleActivity_Increment( slot );
		}
	}
}

// デバッグ確認用の処理
// プログラム側でやる演算式が正しい結果になるか見る用に仮組するためのもの
Battle_Std.CharaBattleActivity_Calc <- function( tbl={} )
{
	local chara_no = BMvCore.GetCharaNo(); // タッグならタッグ用のキャラ番号を取得する
	local val = 0;
	
	local molecule = ( "molecule" in tbl )? tbl.molecule : 0;
	local denominator = ( "denominator" in tbl )? tbl.denominator : 0;
	if( denominator == 0 ) denominator = 1;//0div回避
	local val = molecule * 100 / denominator;
	
	if( Def_Dbg_AchiveMessage )
	{
		local debug_str = "アクティビティ　キャラ:"+chara_no+" "+tbl.title+"("+val+") "+molecule+"/"+denominator;
		debugfontL.draw_message( debug_str );
		_dpn(debug_str);
	}
}

// デバッグ用
Battle_Std.CharaBattleActivity_Count <- function( str )
{
	if( Def_Dbg_LocalDebugScriptPath )
	{
		local chara_no = BMvCore.GetCharaNo(); // タッグならタッグ用のキャラ番号を取得する
		if( chara_no in BattleActivetySlot && str in BattleActivetySlot[chara_no] )
		{
			return BattleActivetySlot[chara_no][str];
		}
	}
	return 0;
}

//敵関係
Battle_Std.EnemyCharaBattleActivity_Increment <- function( slot, str )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		Battle_Std.CharaBattleActivity_Increment( slot, str );
		
		enemy.pop();
	}
}

Battle_Std.EnemyCharaBattleActivity_Calc <- function( tbl={} )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		Battle_Std.CharaBattleActivity_Calc( tbl );
		
		enemy.pop();
	}
}

Battle_Std.EnemyCharaBattleActivity_Count <- function( str )
{
	local ret = 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret = Battle_Std.CharaBattleActivity_Count( str );
		
		enemy.pop();
		
	}
	return ret;
}

//生出しかどうかをチェックしてフラグをたてる
//厳密にはおかしい、同時押しのズラし押しにも未対応なので、コマンドチェックの方で何か準備するべき
Battle_Std.SetFromNoCancelFlag <- function()
{
	local from_movable = (BMvTbl.GetMvCancel( _SkillType_None ) == 255);
	if( from_movable )
	{
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_FromNoCancelMv );//生出しかどうか
	}
}

//CPU用　※動作未確認
Battle_Std.CheckSPTuigekiDamage <- function()
{
	//どれくらいのけぞっているか
	if( !Battle_Std.CheckEnemyisDamage() ) return 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		//
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		if( bs.isBound && bs.Power&def_BS_Pow_LV3 ) return 1;
	}
	return 0;
}



Battle_Std.ClearHitStatus_SetChangeMv <- function()
{
	//初期化＆Mv記憶
	/*
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.Type & _HitType_Damage && !(hs.Type&_HitType_SuperArmor) )
	{
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_ChangeMv_HitStatus_Damage );
	}
	//
	if( hs.Type&_HitType_Guard || hs.Type&_HitType_SuperArmor )
	{
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_ChangeMv_HitStatus_Guard );
	}
	*/
	
	BMvTbl.ClearHitStatus(); //ヒット情報のクリア
	BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
}

Battle_Std.Play_SubtitleVoice <- function( _se, _delay=120, _timelinetype=0 )
{
	// _dpn("_timelinetype:"+_timelinetype);
	local use_delay = _delay;
	local tag = format("battlevoice_chr%03d_%03d",BMvTbl.GetMvStatus().CharaNo,_se );
	local string = sqfunc.GetExStringText( tag );
	local param = BSound.SE_GetUserParam( { type=_SeType_Player, num=_se, } );//音声のフレーム数を取得
	// if( param != 0 )
	// {
		// use_delay = param + 10;//少しマージンあり
	// }
	local file_size = BSound.SE_GetBufferSize( { type=_SeType_Player, num=_se } );
	local calc_frame = ((file_size / (48 * 2))*60)/1000;

	local debug_str = ("BT:"+tag+" "+use_delay+"F Num:"+_se+" Calc:"+calc_frame+"F「"+string+"」");
	_dpn( debug_str );
	
	if( abs(param-calc_frame) > 1 )
	{
		debugfontL.draw_message( debug_str );
	}
	
	
	//未定義のときは*が入るのでそこでチェック
	if( string != "*" )
	{
		if( _timelinetype == 0 ) // common
		{
			// 1Pと2Pが同時にしゃべるとき
			// 話者を表示する必要あり
			local pside = BMvTbl.GetPlayerSide();
			if( pside == 0 )
			{
				BMvEff.Chara_SetMessage( 640, 640-20, string, use_delay, _se );
			}
			else
			{
				BMvEff.Chara_SetMessage( 640, 640+10, string, use_delay, _se );
			}
		}
		else
		{
			BMvEff.Chara_SetMessage( 640, 640, string, use_delay, _se );
		}
	}
	else
	{
		BSound.SE_Play( { type=_SeType_Player, num=_se } );
	}
}

//Battle_Std.SetJumpCtrlVector( { max=1000, min=-1000, plus=96 } );

Battle_Std.SetJumpCtrlVector <- function( param={} )
{
	local max = ("max" in param)? param.max :  1000;
	local min = ("min" in param)? param.min : -1000;
	local plus = ("plus" in param)? param.plus :  96;

	local vec = BMvTbl.GetVector();

	local x = 0; //BMvTbl.GetLP(0); //今のXベクトル取得
	//commandだと相手方向基準か？
	if( BMvTbl.CheckStickHold( (1<<4) | (1<<7) | (1<<1) ) )
	{
		// _dpn("<");
		if( vec.x > min )
		{
			x -= plus;
		}
		else
		{
			// _dp("制限");
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_MaxJumpCtrlVector );
		}
	}
	else if( BMvTbl.CheckStickHold( (1<<6) | (1<<9) | (1<<3) ) )
	{
		// _dpn(">");
		if( vec.x < max )
		{
			x += plus;
		}
		else
		{
			// _dp("制限");
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_MaxJumpCtrlVector );
		}
	}
	
	if( x )
	{
		vec.x += x;
		BMvTbl.SetVector( { x=vec.x, flags=_Vector_Normal } );	
	}
}

// ミカの214EXやリンネの63214EXなど
// 何もしないでもジャンプする技に対して、距離が遠いときに少しジャンプ力を増やしてセットする関数
// ジャンプ力が減ることはない
// seachDistance : チェックする距離
// vec.addy : 
// vec.x : 
// flags : (1<<0) : 高さは変えない
Battle_Std.SetVector_SeachJump <- function( param={} )
{
	local flags = ("flags" in param)? param.flags : 0;
	local min_frame = ("min_frame" in param)? param.min_frame : 8;
	local max_frame = ("max_frame" in param)? param.max_frame : 20;
	
	local edis = Battle_Std.GetEnemyDistance();
	if( edis > param.seachDistance ) edis = param.seachDistance;
	local vec = BMvTbl.GetVector();
	if( vec.addy == 0 ) vec.addy = param.vec.addy; // 適当div0
	if( vec.x == 0 ) vec.x = param.vec.x; // 適当div0
	
	local landFra = -vec.y * 2 / vec.addy;
	if( landFra <  min_frame ) landFra =  min_frame;
	if( landFra > max_frame ) landFra = max_frame;
	
	local xVec = edis / landFra;
	local yVec = vec.y;
	if( xVec > vec.x )
	{
		//
		local jumpPow = xVec * 100 / vec.x; // ジャンプ距離増加倍率
		// 倍率が多い時はすこしジャンプの高さもあげて、着地までの時間を遅くする？
		// その分遠くまで飛ぶんだけど、それを補正かけると、今度は境目が微妙では？大丈夫か？
		
		local par = 35; // これが0だと着地まで同じ、100だと倍率分遅くなる
		local jumpParCalc = ( 100 + ((jumpPow-100)*par/100) );
		if( jumpParCalc == 0 ) jumpParCalc = 1; // div0

		xVec = xVec * 100 / jumpParCalc;
		if( !(flags&(1<<0)) ) yVec = yVec * jumpParCalc / 100;
		
		BMvTbl.SetVector( { x=xVec, y=yVec, flags=_Vector_Normal } );
		// _dp("\n 着地まで:"+landFra+" Vec:"+xVec+","+yVec+" jumpPow:"+jumpPow );
	}
	// 近いからっていってジャンプが弱くなることはない
}

// 相手が近かったら減速・遠かったら加速する
// Battle_Std.AddVector_TargetXLen( { x=450*128, xlen=170*128, power_plus=1500, power_minus=600 } );
Battle_Std.AddVector_TargetXLen <- function( param={} )
{
	local base_x_len = ("x" in param)? param.x : 0; // ここより相手が遠いか近いかで見る
	local base_x_max = ("xlen" in param)? param.xlen : 0; // ベース位置から+-ここまでを最大とする
	if( base_x_max <= 0 )
	{
		return; // 失敗 0div回避
	}
	
	local kyori = Battle_Std.GetEnemyDistance();
	local x_sa = kyori - base_x_len; // -なら後ろ +なら前
	if( x_sa >  base_x_max ) x_sa =  base_x_max;
	if( x_sa < -base_x_max ) x_sa = -base_x_max;

	local power_x_plus = ("power_plus" in param)? param.power_plus : 0;
	local power_x_minus = ("power_minus" in param)? param.power_minus : 0;

	local use_power = ( x_sa > 0 )? power_x_plus : power_x_minus;
	
	local add_vec = x_sa * use_power / base_x_max;
	_dpn("kyori:"+kyori/128+" x_sa:"+x_sa/128+" add_vec:"+add_vec);
	
	BMvTbl.SetVector( { x=add_vec, flags=_Vector_Normal|_VecFlag_Add } );
}

//キャッチ判定での当身成功時、とったものが飛び道具だったときの処理
//当身成功後のHitInterrupt内で呼び出す
//hit_status : 弾と親に伝えるヒットストップ（ BMvTbl.MvHitStatus() ）
Battle_Std.SetFireBallFlags_InAtemiHitInterrupt <- function( param={} )
{
	// 取られ側
	local ene = BMvCore.GetLastHitCharaData(0); // 当て身で入ってくるのは「LastHitChara」なので注意 0なのでそのまま相手
	if( ene.push() )
	{
		BMvTbl.CalcHitValue(-1); //残りヒット数を１減らす
		BMvTbl.SetMvHitStatus( param.hit_status ); // ヒットストップとか設定
		
		// 飛び道具の時の処理
		local ets = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得
		local e_mvcode = BMvTbl.GetMoveCode();
		
		//_dp("\n "+ets.isSousaiObj + ", "+ets.HitCount +", "+ets.isFireBall );
		if( e_mvcode&def_MC_Sousai && ets.HitCount <= 0 )
		{
			if( ets.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
			{
				Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
			}
		}
		// とったオブジェクトの親が操作親じゃない場合はそれにもヒットストップをかける
		local oya = BMvCore.GetParentCharaData();
		if( oya.isdone() && oya.isPlayer()==0 )
		{
			if( oya.push() )
			{
				BMvTbl.SetMvHitStatus( param.hit_status ); // ヒットストップとか設定
				oya.pop();
			}
		}
		ene.pop();
	}
}

Battle_Std.CheckParentIsSkill <- function()
{
	if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
	{
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			local is_skill = Battle_Std.MoveCode.CheckFlag( def_MC_Skill );
			
			oya.pop();
			
			if( is_skill )
			{
				return 1;
			}
		}
	}
	return 0;
}

//飛び道具生成時に親から引き継がれるもの
// Battle_Std.CreateFireBall
// Mv_AtkObj〜
// Mv_LanAtkObj〜
Battle_Std.PassPlayerToFireBallMvCode <- function()
{
	//XXX:整理する
	local oya = BMvCore.GetParentCharaData();
	if( oya.push() )
	{
		local oya_code = {
			[0] = BMvTbl.GetMoveCodeEx( 0 ),
			[1] = BMvTbl.GetMoveCodeEx( 1 ),
			[3] = BMvTbl.GetMoveCodeEx( 3 ),
			[4] = BMvTbl.GetMoveCodeEx( 4 ),
			[5] = BMvTbl.GetMoveCodeEx( 5 ),
			[7] = BMvTbl.GetMoveCodeEx( 7 ),
		}
		oya.pop();
		
		local pass_codes = [
			[0,def_MC_Skill],
			[0,def_MC_EXAction],
			[0,def_MC_SPAction],
			//[0,def_MC_BCAction],
			[1,def_MC1_ExtendAction],
			//[3,def_MC3_AirSkill],
			//[4,def_MC4_NoDFSkillVecAdded],
			[4,def_MC4_AddMv],
			[7,def_MC7_Muteki],
			// [4,def_MC4_MutekiSidou],
			//[5,def_MC5_SmallSkillBonusYoteiMv],
			//[5,def_MC5_ArcDriveSkill],
			[5,def_MC5_FromSidouAddSkill],
			[1,def_MC1_SidouHitSkill],
		]
		foreach( slot, val in pass_codes )
		{
			if( oya_code[val[0]]&val[1] )
			{
				Battle_Std.MoveCodeEx.AddFlag( val[0], val[1] );
			}
		}
	}
}

//必殺技の追加技のときに引き継がれるもの
//通常技や特殊技は入らない(def_AtkTmplFlags_Enable時は入る)
Battle_Std.PassAddSkillMoveCodes <- function()
{
	// _dpn("[PassAddSkillMoveCodes]");
	
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_SidouHitSkill ) || Battle_Std.ChangeMoveCodeEx_CheckFlag( 5, def_MC5_FromSidouAddSkill ) )// 始動技
	{
		// _dpn("始動技から出した追加技なのを記憶");
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_FromSidouAddSkill );
	}
}

Battle_Std.SetSpecialEXSLimit_Enemy <- function( exs_limit=70 )
{
	if( !Battle_Std.EnemyDamageFlag_Check( def_DF_SetedEXSLimit ) )
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_SetedEXSLimit );

		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			_dpn("ゲージ増加制限");
			BMvEff.AttackInfoString_Set({ word=def_AISW_CCSEXLimit,} ); // 相手に出す
			BMvEff.SpGauge_SetLimitBound( { val=exs_limit, time=420 } );
		
			enemy.pop();
			
			return 1;
		}
	}
	return 0;
}

Battle_Std.SetSkillMvChipDamage <- function()
{
	//※攻撃力を1/8した値に削り係数が適用される
	//value=100でデフォルト
	BMvTbl.SetChipDamStatus( { type=0, value=100, time=9999, flag=_ClearFlag_ChangeMv } ); // 必殺技の削り値
}


//EX技で設置する技の間ゲージ増加制限をかける用の関数
Battle_Std.EXSLimit_EXSkillObject <- function()
{
	if( Def_Dbg_EXSLimit_EXSkillOki )
	{
		// _dpn("EX起き攻め制限中...");
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
			
			player.pop();
		}
	}
}

//単純な取得ではなく、振り向きをチェックする
//振り向き予定なら反転する
//このコマンドのあと相手の方向に振り向く技だった場合、これを使ったほうがいい（例えば地上技など）
//TODO:コマンド入力時のレバーの向き、という処理で作ったほうがスマート
//コマンド成立時のキャラの向きとレバー方向を記憶しておき、チェック時と向きが異なっていたら反転するみたいなイメージ
Battle_Std.GetStickHold_FurimukiReverse <- function()
{
	local stick = BMvTbl.GetStickHold();
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		local stick_rev_ar = [0,3,2,1,6,5,4,9,8,7];//左右反転用
		stick = BMvTbl.GetStickHold(); // 面倒なので２回取得する
		local furimuki = BMvTbl.CheckFurimuki();
		
		player.pop();
		
		if( furimuki )
		{
			if( stick <= stick_rev_ar.len()-1 )
			{
				stick = stick_rev_ar[stick];//反転
			}
		}
	}
	return stick;
}


//XXX:未実装
//この辺の処理は重いので毎フレームやる場合は別の処理を使うこと
// Battle_Std.EasyCheckCharaIsSPActionProduction();
//自分か相手が超技の演出中（LAヒットやロック技のAD中）かどうか
Battle_Std.CheckCharaIsSPActionProduction <- function()
{
	if( Battle_Std.CheckPlayerIsSPActionProduction() ) return 1;
	if( Battle_Std.CheckEnemyIsSPActionProduction() ) return 1;
	return 0;
}

//相手キャラが超技の演出中（LAヒットやロック技のAD中）かどうか
Battle_Std.CheckEnemyIsSPActionProduction <- function()
{
	return 0;
	/*
	local isSpProduction = 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_SPActionProduction ) )
		{
			isSpProduction = 1;
		}
		enemy.pop();
	}
	return isSpProduction;
	*/
}

//自キャラが超技の演出中（LAヒットやロック技のAD中）かどうか
Battle_Std.CheckPlayerIsSPActionProduction <- function()
{
	return 0;
	/*
	local isSpProduction = 0;
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_SPActionProduction ) )
		{
			isSpProduction = 1;
		}
		player.pop();
	}
	return isSpProduction;
	*/
}

//EXキャンセルを見る
//そのままだと空振りでも出せてしまうのがデフォなので
//フラグ次第ではヒット情報を見るようになる(ほぼCS用の処理。cmdとは別にやってるので注意)
Battle_Std.CheckExSpecialCancel <- function()
{
	if( !BCMDTbl.CheckCancel( _SkillType_ExSpecial ) ) return 0;
	if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NoWhiffEXCancel ) )
	{
		local hs = BMvTbl.GetMvHitStatus();
		if( !(hs.Type & _HitType_Hit) )
		{
			return 0;
		}
	}
	return 1;
}

//ロックなどでダメージ中無敵にする　※LastUpdateで解除するのを忘れないように
Battle_Std.SetDamageMutekiFrame <- function( _frame=60 )
{
	local hs = BMvTbl.GetMvHitStatus();
	local isDamage = (hs.Type & _HitType_Damage && hs.isCatchFlag == 0);
	
	if( isDamage )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=_frame, muteki_dage=_frame } ); //ヒットしたら無敵で上書き
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_NoMutekiAnnounce ); // 無敵アナウンスはださないMVに変更
	}
}

Battle_Std.CheckLastDamageCharaIsPlayer <- function()
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		// 自分が最後に「殴られた相手」を取得
		local lastDamageChara = BMvCore.GetLastDamageCharaData( 0 );
		
		enemy.pop();
		
		if( lastDamageChara.isPlayer() )
		{
			return 1;
		}
	}
	return 0;
}

Battle_Std.EnemyDamageFlag_DelayAdd <- function( flags )
{
	// _dpn("EnemyDamageFlag_DelayAdd");
	local eff = BMvEff.CreateObject( { mvname="Mv_Null_EnemyDamageFlag_DelayAdd" } );
	if( eff.push() )
	{
		BMvTbl.SetLP(0,flags);
		BMvTbl.SetLP(1,0); // 相手がisDamageのときだけフラグを立てる
		eff.pop();
	}
}

Battle_Std.EnemyDamageFlag_DamageOnlyDelayAdd <- function( flags )
{
	// _dpn("EnemyDamageFlag_DelayAdd");
	local eff = BMvEff.CreateObject( { mvname="Mv_Null_EnemyDamageFlag_DelayAdd" } );
	if( eff.push() )
	{
		BMvTbl.SetLP(0,flags);
		BMvTbl.SetLP(1,1); // 相手がisDamageのときだけフラグを立てる
		eff.pop();
	}
}

//EX技2回の保証補正をちょっと戻す
Battle_Std.RecoverDoubleExHohoHosei <- function()
{
	//EX>EX>IWなどが減らない問題対策
	//EX>IW のときの保証より減りすぎるのがキツい
	//EX>EXが検知できたとき、ある程度元に戻すような係数をかける
	local check_double_ex_hosei = Battle_Std.EnemyDamageFlag_Check( def_DF_SpHosyoHoseiSeted_DoubleEx );
	if( check_double_ex_hosei )
	{
		// local plHosyoHosei = BMvTbl.GetHoseiMinValue();
		// local isDying = ( BMvTbl.GetMvStatus().flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
		// local vpcombo = Battle_Std.EnemyDamageFlag_Check( def_DF_Vorpaled );
		// local val =  { dyinghosei=130, suddundyinghosei=130, hosei=130 };//ある程度戻す
		// local usehosei = ( isDying && vpcombo )? val.dyinghosei : ( isDying )? val.suddundyinghosei : val.hosei;
		//全部結局同じじゃん…
		
		Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_SpRecoverDoubleEx );
	}
}


Battle_Std.InitRecover <- function()
{
	BMvEff.AttackInfoString_Set({ word=def_AISW_Recover,} );
	
	Battle_Std.GRD_AddValue({ val=def_GRD_Recover }); //受身で増加	
	
	if( Battle_Std.RoundisEnd() == false ) // 決着ついた後はボイスを無くす
	{
		Battle_Std.TypeSE_Play({ type="受け身" });
	}
	BMvEff.CreateObject( { mvname="Mv_RecoverInitObject_Mask" } ); //121015追加
	
	Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定

	Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
	
	if( _isDebugModeExe )
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.CreateObject( { mvname="Mv_Obj_RecoverLateCombo", datatype=1, start_pat=999 } );	
		}
		BMvCore.PopCharaData(); //
	}
}

Battle_Std.CallSystemHereYouAre <- function()
{
	// ネットワーク対戦時に操作キャラに「YOU」を出す
	local data = BMvTbl.GetMvNetworkInfo();
	if( data.NetworkVsControlType == _NetworkVsControlType_Controller )
	{
		// ネットワーク対戦で、自分が操作キャラの場合
		local eff = BMvEff.CreateObject( { datatype=1, start_pat="sys_you", mvname="Mv_SystemHereYouAre" } );
	}
}

//事前にみつけたEX暗転マーク箇所にエフェクトをよびつつ暗転する
Battle_Std.CallEXSkillAntenEffect <- function( param={} )
{
	if( !Battle_Std.PP_CheckFlag( def_PP_SkillEffecType, def_PP_SET_CalledEffect ) ) // エフェクトをよんでない
	{
		if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_AfterFrameUpdateStartTiming ) ) //Startの後（コスト消費後？）
		{
			if( Battle_Std.PP_CheckFlag( def_PP_SkillEffecType, def_PP_SET_FindEffectPos ) ) // 特殊判定0を発見済みならその座標に出す
			{
				// 暗転のエフェクトの設定
				local cutinGrpParam = { x=0, y=-200, frame=def_FL_EXCutinBGChangeTime };
				cutinGrpParam.x = BMvTbl.GetPP(def_PP_SkillEffectPos_X);
				cutinGrpParam.y = BMvTbl.GetPP(def_PP_SkillEffectPos_Y);

				// 暗転のタイプによって処理が変わる
				if( Battle_Std.PP_CheckFlag( def_PP_SkillEffecType, def_PP_SET_AntenMove ) )
				{
					// _dpn("暗転中進む");
					Battle_Std.SetSkillStopTime(def_FL_EXCutinStopTime); //時間停止
				}
				else
				{
					// _dpn("暗転中進まない");
					BMvEff.SetStopTime( { time=def_FL_EXCutinStopTime, stopme=2, bounderase=1 } ); //時間停止
					
					Battle_Std.CallAntenStopObject();
					if( Def_Sys_EXCutinNageMuteki )
					{
						BMvEff.SetPlayerTimer( { muteki_nage=Def_Sys_EXCutinNageMuteki, muteki_nageX=Def_Sys_EXCutinNageMuteki } ); // 投げ無敵だけつける
					}
				}
				
				// 暗転する時にカットインを入れる処理
				Battle_Std.PP_AddFlag( def_PP_SkillEffecType, def_PP_SET_CalledEffect ); //エフェクトを呼んだ
				
				Battle_Std.SetEXCutinCameraFocus( def_FL_EXCutinStopTime );
				Battle_Std.SetEXCutinGrp( cutinGrpParam );
				
				if( Def_Sys_EXSkillVorpalBonus )
				{
					if( "vpexs" in param && param.vpexs != -1 ) // -1:未指定
					{
						local val = param.vpexs;
						// _dpn("val:"+val);
						Battle_Std.CallVorpalEXSChaege( val );
					}
					else
					{
						Battle_Std.CallVorpalEXSChaege(); // 初期値
					}
				}
			}
		}
	}	
}


Battle_Std.CallVorpalEXSChaege <- function( _fra = 25, _val = 100 )
{
	// VP中だけでなく、CS効果発動中も含める
	// 倒しきりのときに、CS>EX必殺技でゲージ回収するテクが無駄にならないようにした
	if( BMvEff.GRD_GetJudgeResult() > 0 || BMvEff.GRD_GetBreak(0) == 100 )
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_EXSCharge" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			
			BMvTbl.SetLP(0,_fra);
			BMvTbl.SetLP(1,_val);
			
			eff.pop();
		}
	}
}


//位置関係を元に今現在の予想されるガード方向を取得する（位置関係的に後ろに入れる方向を返す）
// 1:左に入れるとガードの位置関係
//-1:右に入れるとガードの位置関係
// 使いやすさ担保のため、エラーは起きない作りにした
// pl ... 0:自分のを取得 1:相手のを取得
Battle_Std.GetGuardMuki <- function( pl=0 )
{
	local pos_side = BMvTbl.GetMuki();
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		local ppos = BMvTbl.GetPosition();
		player.pop();
		
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local epos = BMvTbl.GetPosition();
			enemy.pop();
			
			pos_side = (epos.x>ppos.x)? -1 : 1;
		}
	}
	if( pl == 1 ) pos_side = pos_side * -1; // 反転
	return pos_side;
}


// 特殊練習中かどうか
Battle_Std.CheckExtraTraining <- function()
{
	local chara_gauge = BMvEff.TM_GetCharaGauge(Def_TMCG_ExtraTraining);
	if( chara_gauge ) return chara_gauge;
	return 0;
}

Battle_Std.EnableExtraTrainingMode <- function()
{
	if( Battle_Std.GS_CheckFlag( def_PP_GS_ExtraTrainingMode ) )
	{
		return 1;
	}
	return 0;
}


Battle_Std.InvalidateObjectMixupInit_SetLP <- function( lp_slot=0 )
{
	if( Def_Sys_CheckObjectEnemyGuardMuki )
	{
		local enemy_guard_muki = Battle_Std.GetGuardMuki(1);
		BMvTbl.SetLP(lp_slot,enemy_guard_muki);
		// _dpn("表裏記憶:"+enemy_guard_muki);
	}
}

Battle_Std.InvalidateObjectMixupUpdate_SetLP <- function( lp_slot=0 )
{
	if( Def_Sys_CheckObjectEnemyGuardMuki )
	{
		local init_enemy_guard_muki = BMvTbl.GetLP(lp_slot);
		local now_enemy_guard_muki = Battle_Std.GetGuardMuki(1);
		if( init_enemy_guard_muki != 100 )
		{
			// _dpn("表裏チェック中... "+init_enemy_guard_muki+" -> "+now_enemy_guard_muki)
			if( init_enemy_guard_muki != now_enemy_guard_muki )
			{
				// _dpn("ガード方向なんでもOK");
				BMvEff.SetGuardPlusFlag(1<<0); // 逆方向でもガードができるようになる
				BMvTbl.SetLP(lp_slot,100); // 処理を終わりにする
			}
		}
	}
}

Battle_Std.CheckDrawMutekiAnnounce <- function( param={} )
{
	if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_MutekiAnnounce ) && !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_NoMutekiAnnounce ) )
	{
		if( BMvCore.GetCaptureCharaData().isdone() )
		{
			//ヒット分岐は除外
			//コマンドを入れてない（自動で派生）
			//つかみ状態
			//上記は無敵アナウンスが不要なので出し済みにしてしまう
			Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_NoMutekiAnnounce );
		}
		else
		{
			local mvs = BMvTbl.GetMvStatus();
			local mvcount = mvs.MvCount;
			//FrameCallCount!=0のとき、0Fだけ無敵でFrameIDジャンプとかしてる技にひっかかるので変更
			if( Battle_Std.CheckDagekiMuteki() && mvs.FrameCallCount==0 )
			{
				if( mvcount <= 3 && Battle_Std.ChangeMoveCodeEx_CheckFlag( 4, def_MC4_AtemiSousaiSuccess ) && BMvEff.GetPlayerMuteki( 0 ) )
				{
					// _dpn("ここは耐える"); // 3F待つ必要はないかもだが一応保険
				}
				else
				{
					// _dpn("無敵アナウンス付与");
					//でかかりは同時押しなどがあるので除外するが、フラグはつける
					Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_Muteki );
				}
			}
			
			if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki ) )
			{
				if( mvcount >= 3 )
				{
					Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_MutekiAnnounce );
					
					//アナウンス
					BMvEff.AttackInfoString_Set({ word=def_AISW_Invincibility,} );
				}
			}
		}
	}
}

//早すぎるベクトルで相手をすり抜けないように座標調整をする
Battle_Std.PosShiftFastVector <- function()
{
	if( !Battle_Std.PP_CheckFlag(def_PP_SkillUpdateVal,def_PP_SUV_FastVecPosShift) )
	{
		//すり抜けないようにチェックする
		local vec_nm = BMvTbl.GetVector( { flags=_Vector_Normal } );
		local vec_dv = BMvTbl.GetVector( { flags=_Vector_Div } );
		local vec_dk = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
		local x_vec = vec_nm.x + vec_dv.x + vec_dk.x;
		
		//前方向のみ
		local kasanari_w = 55*128;
		if( x_vec > kasanari_w )
		{
			//位置関係が変わりそうかどうか
			local enemy = BMvCore.GetEnemyCharaData();
			local posst = BMvEff.GetPointStatus( { target=enemy } );
			local kyori = posst.pos_x * BMvTbl.GetMuki();
			
			//相手が動いてる可能性があるので「x_vec > kyori/2」だとやや心もとないので重なり半分をマージンにする
			if( x_vec > (kyori/2)-(kasanari_w/2) )
			{
				//自分と相手に重なりがある
				//お互い地上
				local p_is_ground = BCMDTbl.CheckPosState(_PosState_Ground );
				local p_kasanari = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
				if( p_kasanari.sx != _Hantei_Error && p_is_ground )
				{
					if( enemy.push() )
					{
						local e_is_ground = BCMDTbl.CheckPosState(_PosState_Ground );
						local e_kasanari = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
						enemy.pop();
						
						if( e_kasanari.sx != _Hantei_Error && e_is_ground )
						{
							Battle_Std.PP_AddFlag(def_PP_SkillUpdateVal,def_PP_SUV_FastVecPosShift);//1Fに2回以上処理をしない
							
							local minus_xpos = kasanari_w - x_vec;

							//保険処理
							if( minus_xpos >  kasanari_w ) minus_xpos =  kasanari_w;
							if( minus_xpos < -kasanari_w ) minus_xpos = -kasanari_w;
							
							_dpn("FastSafeShift "+kyori/128+" x:"+minus_xpos/128);
							BMvTbl.SetPosition( { x=minus_xpos, flags=_Position_Add|_Position_ChangeMuki } );
						}
					}
				}
			}
		}
	}
}

Battle_Std.CheckShieldHoldCommandStrict <- function( checkButtonPos=0 )
{
	if( Def_Sys_ShieldHoldCommandCheckStrict )
	{
		local cmd_spos = BCMDTbl.GetSuccessButtonPos();
		if( cmd_spos == checkButtonPos )
		{
			// 別のボタンが押されていたら多分無関係なので失敗（lastdelayを入れてA離し>D離しになっても良くした）
			if( BMvTbl.CheckCommandString( { command=["@H,A@","@H,B@","@H,C@"], lastdelay=1 } ) )
			{
				return 0;
			}
		}
	}
	return 1;
}

Battle_Std.SetShieldSuccessGRDEffect <- function( _type=0 ) // 0:シールド　1:CE
{
	if( _type == 0 ) // シールド
	{
		//自分のＧＲＤにボーナス
		Battle_Std.GRD_AddValue( { val=def_GRD_Shield_Success, boundplus=1 } );	
			
		//相手のＧＲＤを無条件に１つ減らす
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			BMvEff.GRD_AddValue( { val=def_GRD_Shield_Success_Enemy, pressure=0 } ); //val:10000で１ストック
			
			enemy.pop();
		}
	}
	else if( _type == 1 ) // CE(3D回避)
	{
		Battle_Std.GRD_AddValue( { val=def_GRD_ForwordShift_Success, boundplus=1 } );
		
		//相手のＧＲＤを無条件に１つ減らす
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			BMvEff.GRD_AddValue( { val=def_GRD_ForwordShift_Success_Enemy, pressure=0 } ); //val:10000で１ストック
			
			enemy.pop();
		}
	}
	
	//TSを少し進める
	if( Def_Sys_Shield_AddTS )
	{
		BMvEff.GRD_TS_AddValue( { val=Def_Sys_Shield_AddTS } );
	}	
}

Battle_Std.SetShieldSuccessCancelEffect <- function()
{
	local isJumpAtk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump );
	
	if( isJumpAtk ) //ジャンプ攻撃なら
	{
		// _dm("キャンセル不可＋行動不可＋空ガ可能を受けた");
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Shielded ); // シールドを取られた
	}
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_Shield_CanselNG ) )
	{
		_dp("\n シールドによるキャンセル不能");
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
	}	
}

Battle_Std.SetRapidAtkAHosei <- function( hosei=0 )
{
	if( Def_Sys_RapidAtkA_Hosei && hosei )
	{
		// 連キャン補正をかけるべきかチェック
		local mvs = BMvTbl.GetMvStatus();
		local mvs_bf = BMvTbl.GetMvStatusBF();
		local now_pat = mvs.DataPattern;
		local old_pat = mvs_bf.DataPattern;
		
		if( now_pat == old_pat )
		{
			if( now_pat == def_PAT_Atk_StdA || now_pat == def_PAT_Atk_CroA )
			{
				if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_SidouHitSkill ) )
				{
					local val = BMvEff.ComboView_Set( { val=hosei, type=1 } ); // 補正を乗算
					_dpn("連キャン補正:"+hosei+" -> "+val );
			
					return 1;
				}
			}
		}
	}
	return 0;
}

// 被弾でLastUpdateを抜けたかどうか（使える場所はLastUpdateのみ）
// EX技とかの発動時に潰されたとき、ゲージ消費させるため
Battle_Std.CheckDamagedLastUpdate <- function()
{
	local blocked = (BMvTbl.FromFinalize()==0 && ( Battle_Std.CheckPlayerisBound() || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Damaged ) ));
	return blocked;
}

// キャラ固有ゲージの有効かのチェック
Battle_Std.CheckTrainingCharaGaugeMode <- function()
{
	local gauge = BMvEff.TM_GetCharaGauge(Def_TMCG_Chr011Bullet);
	if( gauge != 0 )
	{
		// _dpn("gauge:"+gauge); // 1:有効　2:自分側有効　3:相手側有効
		
		local st = BMvTbl.GetMvStageStatus();

		if( st.IsTrainingBattle() )
		{
			local isPlayerSide = (BMvTbl.GetPlayerSide() == st.GetStartSide()); // 開始側か？
			
			if( gauge == 2 ) // 自分側有効
			{
				if( isPlayerSide ) return 1;
			}
			else if( gauge == 3 ) // 相手側有効
			{
				if( !isPlayerSide ) return 1;
			}
			else // 有効
			{
				return 1;
			}
		}
	}	
	return 0;
}

// TSゲージがどこまで進んだか取得する
// TSゲージの周期はBattleInfo.txtで定義している
Battle_Std.GetTsRatio <- function()
{
	// 最大値と進行時間からどこまで進んだか割合を取得
	local GRDJudge_DefaultTime = 60*13; // 最大値　これを100倍した値がTS一周の最大値
	local now_ts = BMvEff.GRD_GetTime( 0 ); // どれだけTSゲージが進んだか　1Fで100増加する
	local ratio = now_ts/GRDJudge_DefaultTime;
	// _dp("\n ratio:"+ratio);
	return ratio;
}

// GRDストック数の優劣を取得
Battle_Std.GetGRDStockLead <- function()
{
	local judge = 0;
	local p_grdstock = BMvEff.GRD_CheckStock( { val=-1 } );
	local e_grdstock = 0;
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		e_grdstock = BMvEff.GRD_CheckStock( { val=-1 } );
		enemy.pop();
	}
	judge = p_grdstock - e_grdstock;
	return judge;
}

Battle_Std.CheckChargeCommandActivation_DashF <- function()
{
	local mvname = BMvTbl.GetMvName();
	if( mvname == "Mv_DashWait_F" || mvname == "Mv_Dash_F" )
	{
		local dash_frame = 0;
		if( mvname == "Mv_DashWait_F" )
		{
			local mvs = BMvTbl.GetMvStatus();
			dash_frame = mvs.MvCount;
		}
		else if( mvname == "Mv_Dash_F" )
		{
			local mvs = BMvTbl.GetMvStatus();
			local mvsbf = BMvTbl.GetMvStatusBF();
			// _dpn("mvsbf.MvCount:"+mvsbf.MvCount+" mvs.MvCount:"+mvs.MvCount);

			dash_frame = mvsbf.MvCount + mvs.MvCount;
		}
		
		if( dash_frame <= 16 ) // ダッシュでかかり
		{
			return 1; // タメ分割で漏れそう
		}
	}
	return 0;
}

Battle_Std.CheckChargeCommandActivation_Assault <- function()
{
	local mvname = BMvTbl.GetMvName();
	if( mvname == "Mv_Assault_Std" || mvname == "Mv_Assault_Air" )
	{
		local dash_frame = 0;

		local mvs = BMvTbl.GetMvStatus();
		dash_frame = mvs.MvCount;
		
		if( dash_frame <= 16 ) // アサルトでかかり
		{
			return 1; // タメ分割で漏れそう
		}
	}
	return 0;
}

// 相手がガードシールド中で攻撃判定が触れてたらガード中空振りのフラグを消す
Battle_Std.EnemyGuardShield_ThroughRemoveBound <- function( param={} )
{
	Battle_Std.MoveCodeEx.DelFlag( 2, def_MC2_GRDBreak_WeakDmgHosei ); // まず初期化
	BMvTbl.SetPP(def_PP_WeakBreakDamageHosei,0); // 基本的に毎フレーム初期化
	
	local mvs = BMvTbl.GetMvStatus();
	// _dpn("フラグ:"+BMvTbl.GetMvStatus().Param1+" flag:"+param.Param1+" ?"+BMvTbl.GetFrameParam( 1 )+" mvs:"+mvs.Param1 );
	if( "Param1" in param && mvs.Param1&param.Param1 )
	{
		// このタイミングで処理する
	}
	else
	{
		return 0;
	}
	local damageHosei = ("Hosei" in param)? param.Hosei : 0; // 0は補整なし
	
	// この検知だと移動ベクトルは考慮されておらず、1F前の座標で見てるので少し問題がある
	// とはいえあたってもないのにフラグをかけるのはまずいので、一旦は現象ので仕様としておく（ほぼ問題はないはず）
	local leftHitCount = BMvTbl.CalcHitValue(0);
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc } );
	if( leftHitCount > 0 && enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local isGuardShield = ( bs.isDone && bs.isBound == 2 && BMvEff.GuardSP_Get() )? 1 : 0;
		// local isGuardShieldFlag = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_GuardShiled ); // 見なくて良さそう
		enemy.pop();
		
		if( isGuardShield )
		{
			_dpn("★ガードシールド中なので掴む");
			
			// BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_ThroughRemoveBound, time=1, flag=_ClearFlag_ChangeMv|_ClearFlag_ChangeFrame } );
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_ThroughRemoveGuardBound, time=1, flag=_ClearFlag_ChangeMv|_ClearFlag_ChangeFrame } );
			
			if( damageHosei )
			{
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_GRDBreak_WeakDmgHosei );
				BMvTbl.SetPP(def_PP_WeakBreakDamageHosei,damageHosei);
			}
			return 1;
		}
	}
	return 0;
}

// ステアエンダーのあとだけ受け付けるコマンド範囲のチェック
Battle_Std.CheckSSRelayAtkExCancel <- function( check_cmd_pos )
{
	local cmd_pos = BCMDTbl.GetSuccessButtonPos();
	if( cmd_pos >= check_cmd_pos )
	{
		local cancel = BCMDTbl.CheckCancel(_SkillType_ExSpecial );
		if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_SSRelayAtk ) && !Battle_Std.CharaisKO() && cancel!=255 && cancel!=0 )
		{
			_dpn("SS技っぽいので受付めっちゃ長い1");
			return 1;
		}
		else
		{
			return 0;
		}
	}
	return 1; // cmdposが手前なら成功
}

// かなり簡易的な演出系の検知
Battle_Std.EasyCheckSPActionProduction <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		local mva = BMvTbl.GetMvAction();
		player.pop();
		
		if( mva == def_MVA_LASkill ) return 1;
	}
	local eneny = BMvCore.GetEnemyCharaData();
	if( eneny.push() )
	{
		local mva = BMvTbl.GetMvAction();
		eneny.pop();

		if( mva == def_MVA_LASkill ) return 1;
	}
	return 0;
}

print("\n btl_MvFunc.....OK");